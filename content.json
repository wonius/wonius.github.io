{"meta":{"title":"Gavin's 自留地儿","subtitle":"","description":"","author":"Gavin","url":"https://wonius.github.io","root":"/"},"pages":[{"title":"about","date":"2017-06-06T13:30:00.000Z","updated":"2020-11-05T09:15:14.000Z","comments":false,"path":"about/index.html","permalink":"https://wonius.github.io/about/index.html","excerpt":"","text":"📝记录生活"},{"title":"标签","date":"2017-06-06T13:30:00.000Z","updated":"2017-06-06T14:11:26.000Z","comments":false,"path":"tags/index.html","permalink":"https://wonius.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-06-06T13:35:46.000Z","updated":"2017-06-06T14:15:13.000Z","comments":true,"path":"categories/index.html","permalink":"https://wonius.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"macOS设置jenv","slug":"macOS设置jenv","date":"2022-06-28T14:05:17.000Z","updated":"2022-06-28T14:10:51.152Z","comments":true,"path":"2022/06/28/macOS设置jenv/","link":"","permalink":"https://wonius.github.io/2022/06/28/macOS%E8%AE%BE%E7%BD%AEjenv/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435# 安装brew install jenv# 修改配置echo &#x27;export PATH=&quot;$HOME/.jenv/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrcecho &#x27;eval &quot;$(jenv init -)&quot;&#x27; &gt;&gt; ~/.zshrc# 查看版本jenv versions# 到官网下载对应版本，安装，省略# 需要手动将jdk添加到jenvjenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_321.jdk/Contents/Homejenv add /Library/Java/JavaVirtualMachines/jdk-11.0.15.1.jdk/Contents/Homejenv add /Library/Java/JavaVirtualMachines/jdk-17.0.3.1.jdk/Contents/Home# 手动删除某版本jenv remove *# 设置某版本，如果之前有设置JAVA_HOME，需要注释掉jenv local 1.8java -version# 查看jenv中所有java对应的路径ll $/.jenv/versions# 查看当前目录java版本jenv which java# 设置全局默认版本为1.8jenv global 1.8# 单独为某文件设置版本echo 1.8 &gt;&gt; ./.java-version","categories":[{"name":"MacOS","slug":"MacOS","permalink":"https://wonius.github.io/categories/MacOS/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"https://wonius.github.io/tags/MacOS/"}]},{"title":"macOS安装sentencepiece模块失败","slug":"macOS安装sentencepiece模块失败","date":"2022-05-02T09:48:08.000Z","updated":"2022-05-02T10:27:42.914Z","comments":true,"path":"2022/05/02/macOS安装sentencepiece模块失败/","link":"","permalink":"https://wonius.github.io/2022/05/02/macOS%E5%AE%89%E8%A3%85sentencepiece%E6%A8%A1%E5%9D%97%E5%A4%B1%E8%B4%A5/","excerpt":"","text":"环境1234567macOS Monterey 12.2.1，Apple M1 Pro版本$ python --versionPython 3.8.9$ pip --versionpip 22.0.4 from /Users/gavin/Library/Python/3.8/lib/python/site-packages/pip (python 3.8) 问题1234567891011121314151617181920212223242526272829303132333435363738# 安装模块时报错，信息如下$ pip install sentencepieceRunning setup.py install for sentencepiece ... error error: subprocess-exited-with-error × Running setup.py install for sentencepiece did not run successfully. │ exit code: 1 ╰─&gt; [25 lines of output] /Users/gavin/Library/Python/3.8/lib/python/site-packages/setuptools/dist.py:757: UserWarning: Usage of dash-separated &#x27;description-file&#x27; will not be supported in future versions. Please use the underscore name &#x27;description_file&#x27; instead warnings.warn( running install /Users/gavin/Library/Python/3.8/lib/python/site-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools. warnings.warn( running build running build_py creating build creating build/lib.macosx-10.14-arm64-cpython-38 creating build/lib.macosx-10.14-arm64-cpython-38/sentencepiece copying src/sentencepiece/__init__.py -&gt; build/lib.macosx-10.14-arm64-cpython-38/sentencepiece copying src/sentencepiece/sentencepiece_model_pb2.py -&gt; build/lib.macosx-10.14-arm64-cpython-38/sentencepiece copying src/sentencepiece/sentencepiece_pb2.py -&gt; build/lib.macosx-10.14-arm64-cpython-38/sentencepiece running build_ext /bin/sh: pkg-config: command not found mkdir: bundled: File exists fatal: destination path &#x27;sentencepiece&#x27; already exists and is not an empty directory. fatal: destination path &#x27;sentencepiece&#x27; already exists and is not an empty directory. mkdir: build: File exists ./build_bundled.sh: line 15: cmake: command not found ./build_bundled.sh: line 16: nproc: command not found make: *** No targets specified and no makefile found. Stop. make: *** No rule to make target `install&#x27;. Stop. env: pkg-config: No such file or directory Failed to find sentencepiece pkg-config [end of output] note: This error originates from a subprocess, and is likely not a problem with pip.error: legacy-install-failure 解决既然无法在线安装，遂尝试下载安装包，本地安装。 下载安装包登录官方下载页面，找到最新版本sentencepiece-0.1.96-cp39-cp39-macosx_10_6_x86_64.whl，下载，然后执行命令安装： 1234$ pip install sentencepiece-0.1.96-cp39-cp39-macosx_10_6_x86_64.whlDefaulting to user installation because normal site-packages is not writeableLooking in indexes: https://pypi.tuna.tsinghua.edu.cn/simpleERROR: sentencepiece-0.1.96-cp39-cp39-macosx_10_6_x86_64.whl is not a supported wheel on this platform. 报错平台不支持，而且过程中会到仓库中查找 index。因为我用的是清华的源，第一反应是清华的源仓库里没有这个版本，遂到清华仓库找了一下，有这个版本，名称也一模一样。 查了一下 cp39 对应的 python 版本，3.9才能安装。 我电脑安装的是 3.8，所以重新下载sentencepiece-0.1.96-cp38-cp38-macosx_10_6_x86_64.whl 版本。 重新执行pip install sentencepiece-0.1.96-cp38-cp38-macosx_10_6_x86_64.whl，仍然报错平台不支持。 解决版本问题报错平台不支持，当前思路是查看当前电脑上 python 支持版本，查到一个方法，但是执行报错： 123456789# python 环境中执行import pip._internalprint(pip._internal.pep425tags.get_supported())# 报错信息，模块中没有这个属性Traceback (most recent call last): File &quot;/Users/gavin/Downloads/PycharmProjects/pythonProject/version.py&quot;, line 2, in &lt;module&gt; print(pip._internal.pep425tags.get_supported())AttributeError: module &#x27;pip._internal&#x27; has no attribute &#x27;pep425tags&#x27; 后来发现这个方法，查看当前 python 版本适配的标签： 12345678910111213141516171819202122232425262728$ pip debug --verbose# 输出······Compatible tags: 334 cp38-cp38-macosx_12_0_arm64 cp38-cp38-macosx_12_0_universal2 cp38-cp38-macosx_11_0_arm64 cp38-cp38-macosx_11_0_universal2 cp38-cp38-macosx_10_16_universal2 cp38-cp38-macosx_10_15_universal2 cp38-cp38-macosx_10_14_universal2 cp38-cp38-macosx_10_13_universal2 cp38-cp38-macosx_10_12_universal2 cp38-cp38-macosx_10_11_universal2 cp38-cp38-macosx_10_10_universal2 cp38-cp38-macosx_10_9_universal2 cp38-cp38-macosx_10_8_universal2 cp38-cp38-macosx_10_7_universal2 cp38-cp38-macosx_10_6_universal2 cp38-cp38-macosx_10_5_universal2 cp38-cp38-macosx_10_4_universal2 cp38-abi3-macosx_12_0_arm64 cp38-abi3-macosx_12_0_universal2 cp38-abi3-macosx_11_0_arm64 cp38-abi3-macosx_11_0_universal2 cp38-abi3-macosx_10_16_universal2······ 从中发现cp38-cp38-macosx_10_6_universal2标签，尝试将下载的包名修改为该标签： 123$ cp sentencepiece-0.1.96-cp38-cp38-macosx_10_6_x86_64.whl sentencepiece-0.1.96-cp38-cp38-macosx_10_6_universal2.whl$ pip install sentencepiece-0.1.96-cp38-cp38-macosx_10_6_universal2.whl 安装成功。","categories":[{"name":"Python","slug":"Python","permalink":"https://wonius.github.io/categories/Python/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"https://wonius.github.io/tags/MacOS/"},{"name":"Python","slug":"Python","permalink":"https://wonius.github.io/tags/Python/"}]},{"title":"Mac初始化EasyNLP开发环境","slug":"Mac初始化EasyNLP开发环境","date":"2022-05-02T09:20:17.000Z","updated":"2022-05-02T10:35:28.839Z","comments":true,"path":"2022/05/02/Mac初始化EasyNLP开发环境/","link":"","permalink":"https://wonius.github.io/2022/05/02/Mac%E5%88%9D%E5%A7%8B%E5%8C%96EasyNLP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"环境1234567macOS Monterey 12.2.1，Apple M1 Pro版本$ python --versionPython 3.8.9$ pip --versionpip 22.0.4 from /Users/gavin/Library/Python/3.8/lib/python/site-packages/pip (python 3.8) 过程下载项目打开官方文档，创建目录，在目录中 clone 项目。 git clone https://github.com/alibaba/EasyNLP 安装依赖执行pip install -r requirements.txt，不出预料，有报错。 setuptools版本过低错误信息如下： 12 raise VersionConflict(dist, req).with_context(dependent_req)pkg_resources.VersionConflict: (setuptools 49.2.1 (/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/site-packages), Requirement.parse(&#x27;setuptools&gt;=58.0&#x27;)) 信息比较清晰，进行升级： 1234567$ pip install --upgrade setuptoolsDefaulting to user installation because normal site-packages is not writeableRequirement already satisfied: setuptools in /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/site-packages (49.2.1)Collecting setuptools Using cached setuptools-62.1.0-py3-none-any.whl (1.1 MB)Installing collected packages: setuptoolsSuccessfully installed setuptools-62.1.0 升级成功。重新执行pip install -r requirements.txt，不料还是报相同的错，仔细看了一下，报错路径与我安装的 setuptools 不一致，最终通过修改 site.py 解决，详细过程可参考这篇文章 tokenizers模块报错部分报错信息如下： 123456789 note: This error originates from a subprocess, and is likely not a problem with pip. ERROR: Failed building wheel for sentencepiece Running setup.py clean for sentencepiece Building wheel for grpcio (setup.py) ... done Created wheel for grpcio: filename=grpcio-1.45.0-cp38-cp38-macosx_10_14_arm64.whl size=7451816 sha256=5909c0fc7f0fc6fe959b5205d8fb6293404e377b651fb97aeaaf3574a8c528a0 Stored in directory: /Users/gavin/Library/Caches/pip/wheels/bb/fe/aa/509208bd9420844c88b4a73ced4bc58f069a3db3b3a4b23336Successfully built grpcioFailed to build tokenizers sentencepieceERROR: Could not build wheels for tokenizers, which is required to install pyproject.toml-based projects 解决方案，安装 rust： curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh sentencepiece模块报错重新执行pip install -r requirements.txt，又有新的报错： 1234567891011121314151617181920212223242526272829303132333435Running setup.py install for sentencepiece ... error error: subprocess-exited-with-error × Running setup.py install for sentencepiece did not run successfully. │ exit code: 1 ╰─&gt; [25 lines of output] /Users/gavin/Library/Python/3.8/lib/python/site-packages/setuptools/dist.py:757: UserWarning: Usage of dash-separated &#x27;description-file&#x27; will not be supported in future versions. Please use the underscore name &#x27;description_file&#x27; instead warnings.warn( running install /Users/gavin/Library/Python/3.8/lib/python/site-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools. warnings.warn( running build running build_py creating build creating build/lib.macosx-10.14-arm64-cpython-38 creating build/lib.macosx-10.14-arm64-cpython-38/sentencepiece copying src/sentencepiece/__init__.py -&gt; build/lib.macosx-10.14-arm64-cpython-38/sentencepiece copying src/sentencepiece/sentencepiece_model_pb2.py -&gt; build/lib.macosx-10.14-arm64-cpython-38/sentencepiece copying src/sentencepiece/sentencepiece_pb2.py -&gt; build/lib.macosx-10.14-arm64-cpython-38/sentencepiece running build_ext /bin/sh: pkg-config: command not found mkdir: bundled: File exists fatal: destination path &#x27;sentencepiece&#x27; already exists and is not an empty directory. fatal: destination path &#x27;sentencepiece&#x27; already exists and is not an empty directory. mkdir: build: File exists ./build_bundled.sh: line 15: cmake: command not found ./build_bundled.sh: line 16: nproc: command not found make: *** No targets specified and no makefile found. Stop. make: *** No rule to make target `install&#x27;. Stop. env: pkg-config: No such file or directory Failed to find sentencepiece pkg-config [end of output] note: This error originates from a subprocess, and is likely not a problem with pip.error: legacy-install-failure 看报错是安装 sentencepiece 有异常，尝试单独安装该模块pip install sentencepiece，报同样的错。 最终通过下载安装包、修改标签名，安装成功，详细过程可参考这篇文章。 重新执行pip install -r requirements.txt，终于成功安装完依赖。","categories":[{"name":"MacOS","slug":"MacOS","permalink":"https://wonius.github.io/categories/MacOS/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"https://wonius.github.io/tags/MacOS/"},{"name":"EasyNLP","slug":"EasyNLP","permalink":"https://wonius.github.io/tags/EasyNLP/"}]},{"title":"MacOS修改Python默认配置","slug":"Mac修改默认Python","date":"2022-04-29T03:52:54.000Z","updated":"2022-05-02T09:46:16.737Z","comments":true,"path":"2022/04/29/Mac修改默认Python/","link":"","permalink":"https://wonius.github.io/2022/04/29/Mac%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4Python/","excerpt":"","text":"环境信息1234567macOS Monterey 12.2.1，Apple M1 Pro版本$ python --versionPython 3.8.9$ pip --versionpip 22.0.4 from /Users/gavin/Library/Python/3.8/lib/python/site-packages/pip (python 3.8) 问题最近在安装 EasyNLP 依赖的时候，报错 如下： 12 raise VersionConflict(dist, req).with_context(dependent_req)pkg_resources.VersionConflict: (setuptools 49.2.1 (/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/site-packages), Requirement.parse(&#x27;setuptools&gt;=58.0&#x27;)) OK，setuptools 版本太低，升级： 1234567$ pip install --upgrade setuptoolsDefaulting to user installation because normal site-packages is not writeableRequirement already satisfied: setuptools in /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/site-packages (49.2.1)Collecting setuptools Using cached setuptools-62.1.0-py3-none-any.whl (1.1 MB)Installing collected packages: setuptoolsSuccessfully installed setuptools-62.1.0 升级成功，But，重新安装依赖，还是报同样的错。就离谱。 仔细看了下 setuptools 信息： 1234567891011$ pip show setuptoolsName: setuptoolsVersion: 62.1.0Summary: Easily download, build, install, upgrade, and uninstall Python packagesHome-page: https://github.com/pypa/setuptoolsAuthor: Python Packaging AuthorityAuthor-email: distutils-sig@python.orgLicense: UNKNOWNLocation: /Users/gavin/Library/Python/3.8/lib/python/site-packagesRequires:Required-by: 找到原因了： pip 升级 setuptools 后的路径：/Users/gavin/Library/Python/3.8/lib/python/site-packages 报错的路径：Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/site-packages 也就是说，安装依赖时查找的 site-package，并非默认的路径（site-package 是下载第三方库时在电脑中的存放路径，也就是仓库）。 排查先查看下 Python 对应的 site 信息： 123456789101112$ python -m sitesys.path = [ &#x27;/usr/bin&#x27;, &#x27;/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python38.zip&#x27;, &#x27;/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8&#x27;, &#x27;/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/lib-dynload&#x27;, &#x27;/Users/gavin/Library/Python/3.8/lib/python/site-packages&#x27;, &#x27;/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/site-packages&#x27;,]USER_BASE: &#x27;/Users/gavin/Library/Python/3.8&#x27; (exists)USER_SITE: &#x27;/Users/gavin/Library/Python/3.8/lib/python/site-packages&#x27; (exists)ENABLE_USER_SITE: True 可以看到 sys.path 中两个路径都有，而且两个 site-package 中都有 setuptools，安装依赖时没有读取我们期望的 site-packages。 到这我们有 2 个解决方案，要么把系统自带的 setuptools 也升级，要么在 sys.path 中把系统的 site-packages删掉。 方案一不是长久之计，采用方案二。接下来就是看怎么修改 sys.path 了。 解决​ 网上查了半天，如果对 sys.path 进行修改，最好是能把系统默认的 site-packages 去掉，只保留我们自己的 site-packages。如果去不掉的话，至少保证我们自己的 site-packages 优先级高于系统默认。 修改 sys.path 的方案一般有这些： 调用 sys 自带函数，比如 sys.remove() 函数，可以直接删。（该方案一般适用于代码中，临时有效，不适合我们的场景）； python 在生成 sys.path 时，是通过检测.pth 文件所在的目录，以及其中的内容。所以如果想在某个路径加入到 sys.path，可以通过加.pth，或者修改.pth（该方案适合添加内容，也不适合）； 定义 PYTHONPATH = /xxx/xxx，不定义这个变量也可以，直接在 PATH 中添加。这个方案大家应该都知道。根据 bash 类型编辑.bash_profile，或者.zshrc（该方案也只能添加，也不适合）； 通过调整 python 的 site.py，自定义 USER_BASE、USER_SITE； 最终用第四种方案解决了我们的问题，具体方法如下（奇怪的是，我明明没配置，但是 python -m site 命令返回的结果里却显示有）： 1234567891011121314151617181920212223242526272829303132# 1. 查看 site.py所在位置python -m site -help# 得到输出/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/site.py [--user-base] [--user-site]Without arguments print some useful informationWith arguments print the value of USER_BASE and/or USER_SITE separatedby &#x27;:&#x27;.Exit codes with --user-base or --user-site: 0 - user site directory is enabled 1 - user site directory is disabled by user 2 - uses site directory is disabled by super user or for security reasons &gt;2 - unknown error # 2. 进入路径，备份文件、编辑文件 cd /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8 cp site.py site_bak.py sudo vim site.py # 3. 修改配置，如下，然后保存退出 # Enable per user site-packages directory# set it to False to disable the feature or True to force the featureENABLE_USER_SITE = True# for distutils.commands.install# These values are initialized by the getuserbase() and getusersitepackages()# functions, through the main() function when Python starts.USER_SITE = &quot;/Users/gavin/Library/Python/3.8/lib/python/site-packages&quot;USER_BASE = &quot;/Users/gavin/Library/Python/3.8&quot; 然后执行安装依赖命令，可正常执行。","categories":[{"name":"MacOS","slug":"MacOS","permalink":"https://wonius.github.io/categories/MacOS/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"https://wonius.github.io/tags/MacOS/"},{"name":"Python","slug":"Python","permalink":"https://wonius.github.io/tags/Python/"}]},{"title":"因为软连接导致mybatis无法正常启动","slug":"因为软连接导致mybatis无法正常启动","date":"2021-11-16T06:53:27.000Z","updated":"2022-05-08T07:13:12.555Z","comments":true,"path":"2021/11/16/因为软连接导致mybatis无法正常启动/","link":"","permalink":"https://wonius.github.io/2021/11/16/%E5%9B%A0%E4%B8%BA%E8%BD%AF%E8%BF%9E%E6%8E%A5%E5%AF%BC%E8%87%B4mybatis%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8/","excerpt":"","text":"​ 最近接手的一个项目，投产上线，遇到很多问题，其中一个问题比较有意思，记录一下。 背景​ 简单说下背景，我们的应用是SpringBoot+Mybatis，通过内部CI工具部署不同环境，在dev、stg、uat环境都没问题，投产时启动报错，错误日志如下： 12345678910Caused by: java.lang.IllegalArgumentException: Mapped Statements collection already contains value for com.yicallv1.dao.AgentSkillMapper.create. please check URL [jar:file:/export/package/iim-thirdparty-prod-20211112T123635026/lib/iim-thirdparty-1.0.1.jar!/BOOT-INF/classes!/sqlmap/AgentSkillMapper.xml] and URL [jar:file:/export/server/iim-thirdparty/lib/iim-thirdparty-1.0.1.jar!/BOOT-INF/classes/sqlmap/AgentSkillMapper.xml] at org.apache.ibatis.session.Configuration$StrictMap.put(Configuration.java:1014) ~[mybatis-3.5.6.jar!/:3.5.6] at org.apache.ibatis.session.Configuration$StrictMap.put(Configuration.java:970) ~[mybatis-3.5.6.jar!/:3.5.6] at org.apache.ibatis.session.Configuration.addMappedStatement(Configuration.java:768) ~[mybatis-3.5.6.jar!/:3.5.6] at org.apache.ibatis.builder.MapperBuilderAssistant.addMappedStatement(MapperBuilderAssistant.java:297) ~[mybatis-3.5.6.jar!/:3.5.6] at org.apache.ibatis.builder.xml.XMLStatementBuilder.parseStatementNode(XMLStatementBuilder.java:113) ~[mybatis-3.5.6.jar!/:3.5.6] at org.apache.ibatis.builder.xml.XMLMapperBuilder.buildStatementFromContext(XMLMapperBuilder.java:138) ~[mybatis-3.5.6.jar!/:3.5.6] at org.apache.ibatis.builder.xml.XMLMapperBuilder.buildStatementFromContext(XMLMapperBuilder.java:131) ~[mybatis-3.5.6.jar!/:3.5.6] at org.apache.ibatis.builder.xml.XMLMapperBuilder.configurationElement(XMLMapperBuilder.java:121) ~[mybatis-3.5.6.jar!/:3.5.6] ... 94 common frames omitted 排查​ 刚开始看这个问题有点懵，先后检查mapper文件名、生产jar包反编译、生产主机操作系统版本、环境等，都没有问题。后来仔细看了下报错，提示/export/package/iim-thirdparty-prod-20211112T123635026/lib/iim-thirdparty-1.0.1.jar!/BOOT-INF/classes!/sqlmap/AgentSkillMapper.xml 与 /export/server/iim-thirdparty/lib/iim-thirdparty-1.0.1.jar!/BOOT-INF/classes/sqlmap/AgentSkillMapper.xml 文件重名。跟运维沟通，发现生产环境与其他环境不一致，会对jar包所在目录简历一个软连接。包实际路径为上面的路径，软连接路径为下面的路径，为了统一生产启动脚本，脚本中启动jar包的命令，都是使用软连接路径。 ​ 到这里，可以分析出来，mybatis在服务启动扫描mapper文件时，应该是将真实路径、软连接路径都扫了一遍，所以所有的mapper文件才会提示有重名。 ​ 再进一步分析代码，加载mapper文件的配置，代码如下： bean.setMapperLocations(resolver.getResources(&quot;classpath*:**/sqlmap/*.xml&quot;)); 问题应该出在classpath*上，mybatis会遍历所有的classpath，其中包括了真实路径、软连接路径。至此，找到原因，并最终修改为如下： bean.setMapperLocations(resolver.getResources(&quot;classpath:sqlmap/*.xml&quot;));","categories":[{"name":"Backend","slug":"Backend","permalink":"https://wonius.github.io/categories/Backend/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://wonius.github.io/tags/Mybatis/"}]},{"title":"LeetCode-516.最长回文子序列","slug":"LeetCode-516-最长回文子序列","date":"2020-12-21T09:09:58.000Z","updated":"2020-12-21T09:23:54.000Z","comments":true,"path":"2020/12/21/LeetCode-516-最长回文子序列/","link":"","permalink":"https://wonius.github.io/2020/12/21/LeetCode-516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"题目给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。 示例 1:输入: 1&quot;bbbab&quot; 输出: 14 一个可能的最长回文子序列为 “bbbb”。 示例 2:输入: 1&quot;cbbd&quot; 输出: 12 一个可能的最长回文子序列为 “bb”。 提示： 1 &lt;= s.length &lt;= 1000 s 只包含小写英文字母 题解Round 1（失败）思路： Round 2（递归）复用最长回文子串的思路。区别在于回文函数。 时间复杂度O(N^N)，效率并不高。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * @lc app=leetcode.cn id=516 lang=java * * [516] 最长回文子序列 */// @lc code=startclass Solution &#123; public int longestPalindromeSubseq(String s) &#123; /** * 2. 复用最长回文子串的思路 * */ char[] arr = s.toCharArray(); int res = 0; int leftRes = 0; int rightRes = 0; for (int i = 0; i &lt; arr.length; i++) &#123; leftRes = plalindrome(arr, i, i); rightRes = plalindrome(arr, i, i+1); if(leftRes&gt;res) res = leftRes; if(rightRes&gt;res) res = rightRes; &#125; return res; &#125; public int plalindrome(char[] arr, int left, int right)&#123; // 判断越界 if(left&lt;0 || right&gt;arr.length-1) return 0; // 字符相同时，判断是否为同一字符 if(arr[left] == arr[right])&#123; if(left==right) return plalindrome(arr, left-1, right+1) +1; else return plalindrome(arr, left-1, right+1) +2; &#125; else &#123; // 不同时，取最大 return Math.max(plalindrome(arr, left-1, right), plalindrome(arr, left, right+1)); &#125; &#125;&#125;// @lc code=end Round 3（）","categories":[{"name":"算法","slug":"算法","permalink":"https://wonius.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://wonius.github.io/tags/LeetCode/"}]},{"title":"LeetCode-5.最长回文子串","slug":"LeetCode-5-最长回文子串","date":"2020-12-17T07:11:57.000Z","updated":"2020-12-18T02:46:47.000Z","comments":true,"path":"2020/12/17/LeetCode-5-最长回文子串/","link":"","permalink":"https://wonius.github.io/2020/12/17/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 题解Round 1（常规）常规解法，基本没用到算法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * @lc app=leetcode.cn id=5 lang=java * * [5] 最长回文子串 */// @lc code=startclass Solution &#123; public String longestPalindrome(String s) &#123; if(s.length()&lt;=1) return s; char[] arr = s.toCharArray(); String resString = &quot;&quot;; // 遍历每个字符 for(int i=1; i&lt;arr.length; i++) &#123; String currString = &quot;&quot;; String currString2 = &quot;&quot;; // 假设当前字符左右两两回文，如abcba // 保存当前字符 currString+=arr[i]; for (int j=0; j &lt; i; j++) &#123; // 判断左右两边字符 if(i+1+j&lt;arr.length &amp;&amp; i-1-j&gt;=0 &amp;&amp; arr[i+1+j]==arr[i-1-j])&#123; // 不要使用StringBuilder的append，不然你会哭的 // 拼接左、中、右字符 currString=arr[i+1+j]+currString+arr[i-1-j]; &#125; else &#123; // 如果不连续，跳出 break; &#125; &#125; // 假设当前字符与前面一个字符两两回文，如 abba for (int j=0; j &lt; i; j++) &#123; // if(i+j&lt;arr.length &amp;&amp; i-1-j&gt;=0 &amp;&amp; arr[i+j]==arr[i-1-j])&#123; // 拼接左、中、右字符 currString2=arr[i+j]+currString2+arr[i-1-j]; &#125; else &#123; // 如果不连续，跳出 break; &#125; &#125; // 找极大值 if(currString.length()&gt;resString.length()) &#123; resString = currString; &#125; if(currString2.length()&gt;resString.length()) &#123; resString = currString2; &#125; &#125; return resString; &#125;&#125;// @lc code=end 中间遇到2个坑： 刚开始，currString使用StringBuilder，会发现很多重复元素。原因是append()都是在原对象上操作的； 刚开始打算把2种情况合并到一个for循环中，调了好久发现不行，二者对的结果会相互影响。比如不连续时要跳出循环； Round 2（双指针）上面解法的着力点在单个字符，循环时以某一个字符为主，每次只移动1个字符。 还有一种解法是双指针，每次同时移动2个字符。这也是回文题的特点。 重点关注回文函数中的边界，以及最终如何截取子串。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* * @lc app=leetcode.cn id=5 lang=java * * [5] 最长回文子串 */// @lc code=startclass Solution &#123; public String longestPalindrome(String s) &#123; /** * 双指针，left、right2个指针同时移动 */ String resString = &quot;&quot;; for (int i = 0; i &lt; s.length(); i++) &#123; // 左右指针在同一位置 String leftRes = plalindrome(s, i, i); // right指针在left指针后 String rightRes = plalindrome(s, i, i+1); if(leftRes.length()&gt;resString.length()) &#123; resString = leftRes; &#125; if(rightRes.length()&gt;resString.length()) &#123; resString = rightRes; &#125; &#125; return resString; &#125; /** * 回文函数 * @param s * @param left * @param right * @return */ public static String plalindrome(String s, int left, int right)&#123; char[] arr = s.toCharArray(); // 判断2个指针对应字符是否相等 // 主要left、right的边界 while(left&gt;=0 &amp;&amp; right&lt;arr.length &amp;&amp; arr[left] == arr[right])&#123; left--; right++; &#125; // substring(headIndex, tailIndex)，注意2个入参，第二个入参只能是尾节点的下标，不是长度，而且是下一个位置的下标。比如s=&quot;abc&quot;，获取完整字符时s.substring(0, 3)，实际字符c的下标是2 // 由于while先执行再判断，所以当跳出while循环时，left、right都已经越界了 // 所以left需要加1，right不用减1，原因见上 if(left+1 &lt; right) return s.substring(left+1, right); return &quot;&quot;; &#125;&#125;// @lc code=end","categories":[{"name":"算法","slug":"算法","permalink":"https://wonius.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://wonius.github.io/tags/LeetCode/"}]},{"title":"LeetCode-34.在排序数组中查找元素的第一个和最后一个位置","slug":"LeetCode-34-在排序数组中查找元素的第一个和最后一个位置","date":"2020-12-16T08:54:11.000Z","updated":"2020-12-16T09:38:57.000Z","comments":true,"path":"2020/12/16/LeetCode-34-在排序数组中查找元素的第一个和最后一个位置/","link":"","permalink":"https://wonius.github.io/2020/12/16/LeetCode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"题目给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶： 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1： 12输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4] 示例 2： 12输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1] 示例 3： 12输入：nums = [], target = 0输出：[-1,-1] 提示： 0 &lt;= nums.length &lt;= 105 -109 &lt;= nums[i] &lt;= 109 nums 是一个非递减数组 -109 &lt;= target &lt;= 109 题解Round 1在最后把常规二分查找函数也写出来了。 便于对比左边界二分查找、右边界二分查找与常规二分查找的差异。 左边界二分查找与常规二分查找差异： 当nums[mid]=target时，左边界继续循环； 循环结束时，左边界判断是否越界； 右边界二分查找与常规二分查找差异： mid计算时多加1，mid = left+(right-left+1)/2，这样不管nums数组是奇数还是偶数个，都会向上取整； 当nums[mid]=target时，右边界继续循环； 循环结束时，右边界判断是否越界； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/* * @lc app=leetcode.cn id=34 lang=java * * [34] 在排序数组中查找元素的第一个和最后一个位置 */// @lc code=startclass Solution &#123; public int[] searchRange(int[] nums, int target) &#123; if(nums.length&lt;=0) return new int[]&#123;-1,-1&#125;; int leftRes = leftBoundaryBinarySearch(nums, target); int rightRes = rightBoundaryBinarySearch(nums, target); return new int[]&#123;leftRes, rightRes&#125;; &#125; /** * 左侧边界元素，即找到第一个匹配的元素 * @param nums * @param target * @return */ public int leftBoundaryBinarySearch(int[] nums, int target) &#123; int mid = 0, left = 0, right = nums.length-1; while(left&lt;right) &#123; mid = left + (right-left)/2; if(target&gt;nums[mid]) &#123; left = mid+1; &#125; else if(target&lt;nums[mid]) &#123; right = mid-1; &#125; else if(target == nums[mid]) &#123; // 左侧有可能还有相等元素，设置为右闭，继续查找 right = mid; &#125; &#125; // 检测越界、没找到值 if(right&lt;0 || left&gt;=nums.length || target!=nums[left]) return -1; return left; &#125; /** * 右侧边界元素，即找到最后一个匹配的元素 * @param nums * @param target * @return */ public int rightBoundaryBinarySearch(int[] nums, int target) &#123; int mid=0, left=0, right=nums.length-1; while(left&lt;right) &#123; // 加1，使mid偏右，避免陷入死循环。如下标4、5的值相同时，mid一直为4 mid = left+(right-left+1)/2; if(target&gt;nums[mid])&#123; left = mid+1; &#125; else if(target&lt;nums[mid])&#123; right = mid-1; &#125; else if(target==nums[mid])&#123; // 右侧有可能还有相等元素，设置为左闭，继续查找 left=mid; &#125; &#125; // 检测越界、没找到值 if(right&lt;0 || left&gt;=nums.length || target!=nums[left]) return -1; return left; &#125; /** * 常规二分查找，找到即返回 * @param nums * @param target * @return */ public static int binarySearch(int[] nums, int target) &#123; int mid = 0, left = 0, right = nums.length-1; while(left&lt;right) &#123; mid = left + (right-left)/2; if(target &lt; nums[mid]) &#123; // 闭区间，所以right要减1 right = mid-1; &#125; else if(target &gt; nums[mid]) &#123; // 闭区间，所以left要加1 left = mid+1; &#125; else if(target == nums[mid]) &#123; // 匹配到，直接return return mid; &#125; &#125; // 只有一个元素，没有进入循环时 if(nums[left] != target) return -1; return left; &#125;&#125;// @lc code=end","categories":[{"name":"算法","slug":"算法","permalink":"https://wonius.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://wonius.github.io/tags/LeetCode/"}]},{"title":"LeetCode-704.二分查找","slug":"LeetCode-704-二分查找","date":"2020-12-15T07:14:29.000Z","updated":"2020-12-16T06:43:04.000Z","comments":true,"path":"2020/12/15/LeetCode-704-二分查找/","link":"","permalink":"https://wonius.github.io/2020/12/15/LeetCode-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"题目给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 123输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2: 123输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 题解Round 1（常规）需要注意的几个点： mid = left + (right-left)/2，等价于mid=(left+right)/2； 每个if条件中对比的值，及大于、小于符号； mid加1、减一； 123456789101112131415161718192021public int search(int[] nums, int target) &#123; int left = 0, right = nums.length-1; int mid = 0; while (left &lt; right) &#123; mid = left + (right-left)/2; // mid加减1，因为当前元素已经对比过了。否则while条件可能会出现死循环 // 比如nums = [-1,0,3,5,9,12], target = 2时 if (target &gt; nums[mid]) &#123; left = mid+1; &#125; else if (target &lt; nums[mid]) &#123; right = mid-1; &#125; else if (target == nums[mid])&#123; return mid; &#125; &#125; if(nums[left] != target) return -1; return left; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://wonius.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://wonius.github.io/tags/LeetCode/"}]},{"title":"LeetCode-300.最长上升子序列","slug":"LeetCode-300-最长上升子序列","date":"2020-12-14T07:51:39.000Z","updated":"2020-12-15T03:36:34.000Z","comments":true,"path":"2020/12/14/LeetCode-300-最长上升子序列/","link":"","permalink":"https://wonius.github.io/2020/12/14/LeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"题目给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 题解Round 1（失败）思路： 解子序列问题要用动态规划，解动态规划先写出来递归解法，然后再转换成dp数组存储中间变量。 递归函数如下，可惜不对。dp(nums, i)的值，并不等于dp(nums, i-1)+1 123456789public int dp(int[] nums, int i) &#123; if(i &lt; 1) return 1; if(i == 1 &amp;&amp; nums[i]&gt;nums[i-1]) return 1; if(nums[i]&gt;nums[i-1]) &#123; return dp(nums, i-1)+1; &#125; else&#123; return dp(nums, i-1); &#125;&#125; 发现不对后，然后换了种思路，尝试将数组转换成矩阵的方式，即横轴、纵轴皆为这个数组，然后对比大小。但是这种也不对，比出来的大小值彼此间没有任何关联。 归根结底，是没有找到不同元素对应值之间的关系，即假设：y(x)=f(x)，y(x+1)=f(x+1)时，有y(x+1)=F[y(x)]，要找到F()这个函数做的事情。（f()、F()都是函数，初中数学没忘吧） Round 2解：当前元素对应的值，等于前面比当前元素小对应的值中最大的值，加1 即，F[y(x)]=Max{y(0),y(1)…y(x-1)}+1，所以 F[y(x)]=Max{f(0),f(1)…f(x-1)}+1 也就是， F[x]=Max{f(0),f(1)…f(x-1)}+1 x是任意值，所以f()和F()等价，得：f(x)=Max{f(0),f(1)…f(x-1)}+1 1234567891011121314151617181920212223242526272829303132333435363738394041/* * @lc app=leetcode.cn id=300 lang=java * * [300] 最长上升子序列 */// @lc code=startclass Solution &#123; public int lengthOfLIS(int[] nums) &#123; /** * 用dp数组存储每个元素的值 * 最终取最大的值 * * 其中关键是找到当前元素对应的值，与前一个元素对应的值之间的关系 */ int res = 0; int length = nums.length; int[] dp = new int[length+1]; Arrays.fill(dp, 1); // 计算每个元素对应的值 for (int i = 0; i &lt; length; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; // 当前元素的值，是在前面比他小的最大值+1 if (nums[i] &gt; nums[j]) &#123; dp[i] = Math.max(dp[i], dp[j]+1); &#125; &#125; &#125; // 取最大值 for (int i = 0; i &lt; dp.length; i++) &#123; res = Math.max(res, dp[i]); &#125; return res; &#125;&#125;// @lc code=end","categories":[{"name":"算法","slug":"算法","permalink":"https://wonius.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://wonius.github.io/tags/LeetCode/"}]},{"title":"LeetCode-1143.最长公共子序列","slug":"LeetCode-1143-最长公共子序列","date":"2020-12-09T09:48:41.000Z","updated":"2020-12-14T08:03:14.000Z","comments":true,"path":"2020/12/09/LeetCode-1143-最长公共子序列/","link":"","permalink":"https://wonius.github.io/2020/12/09/LeetCode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"​ 做这道题花了点时间，记录下。 注：子序列可以不连续。子串一定是连续的。 题目给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0。 示例 1: 123输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3 解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。 示例 2: 123输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。 示例 3: 123输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：两个字符串没有公共子序列，返回 0。 题解Round 1（失败）思路： 既然获取公共子序列，那以短的句子为基础，遍历每个字符，判断在长句子中是否存在，如果存在则保存当前字符。最终得到公共子序列中。任意一个字符串结束都算结束。 乍一看这个思路没问题，实际不然。缺陷在下方也有说明。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * @lc app=leetcode.cn id=1143 lang=java * * [1143] 最长公共子序列 */// @lc code=startclass Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; if(text1 == null || text2 == null || text1.isEmpty() || text2.isEmpty()) return 0; /** * 判断2个句子长短，以短句为基准，挨个判断每个字符是否存在长句中，如果存在，则为相同字符，保存。最后得出最长的字符组合； * 这个算法有个致命缺陷，如果短句中间某个字符恰好等于长句的最后1个字符，那对比就会提前结束，得到错误结果 * 比如有2个字符串： * mhunuzqrkzsnidwbun * szulspmhwpazoxijwbq * 按照该算法，得到的结果是mhzq，但是最长的是mhziwb */ String longString = null; char[] array = null; int res = 0; // 保存最终结果 int tempResInt =0; //中间过程长度 // 将短句拆分为数组，长句保存到longString，用于下面比对 if(text1.length()&lt;text2.length()) &#123; array = text1.toCharArray(); longString = text2; &#125;else &#123; array = text2.toCharArray(); longString = text1; &#125; // 挨个遍历短句数组中的元素 for(int i = 0; i&lt;array.length; i++)&#123; tempResInt = 0; StringBuilder tempResString = new StringBuilder() ; String tempString = longString; // 从当前字符开始 for(int j = i; j&lt;array.length; j++ ) &#123; char cur = array[j]; // 判断长句剩下的子串中是否存在当前字符，有的话计数 if (tempString.indexOf(cur) != -1) &#123; tempResInt++; tempResString.append(cur); tempString = tempString.substring(tempString.indexOf(cur)+1); &#125; &#125; System.out.println(&quot;tempResInt: &quot;+ tempResInt + &quot;, tempResString: &quot;+tempResString.toString()); // 保存最长的结果 res = Math.max(tempResInt, res); &#125; System.out.println(&quot;length: &quot;+ res + &quot;, tempResInt: &quot;); return res; &#125;&#125; Round 2（递归）思路： 动态规划的思路解题。推荐看下labuladong的算法小抄。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * @lc app=leetcode.cn id=1143 lang=java * * [1143] 最长公共子序列 */// @lc code=startclass Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; if(text1 == null || text2 == null || text1.isEmpty() || text2.isEmpty()) return 0; /** * 2. 递归法 * 关键是梳理出来递归方法，哪些状态要在递归里处理 * 递归法耗时太长 */ char[] arr1 = text1.toCharArray(); char[] arr2 = text2.toCharArray(); // 从尾部往前逐个字符对比。数组从0开始，所以长度减1 return recursion(arr1, arr2, arr1.length-1, arr2.length-1); &#125; /** * 递归数组，状态变化体现在参数中 */ public int recursion(char[] text1, char[] text2, int i, int j)&#123; // 任意字符数组遍历完，结束 if (i &lt; 0 || j &lt; 0) &#123; return 0; &#125; // 如果字符相等，同时进1。结果加1 if (text1[i] == text2[j]) &#123; return recursion(text1, text2, i-1, j-1)+1; &#125; else &#123; // 不相等，一个句子往前进1，另外一个不变。2种情况取最长 return Math.max(recursion(text1, text2, i-1, j), recursion(text1, text2, i, j-1)); &#125; &#125;&#125; Round 3（数组存储结果）思路： 与递归法类似，区别在于，将每种情况的结果存放到数组中。 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * @lc app=leetcode.cn id=1143 lang=java * * [1143] 最长公共子序列 */// @lc code=startclass Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; if(text1 == null || text2 == null || text1.isEmpty() || text2.isEmpty()) return 0; /** * 3. dp数组法 * 参照递归法，将每个步骤的使用数组存储起来 * 算法过程与递归相同 */ char[] arr1 = text1.toCharArray(); char[] arr2 = text2.toCharArray(); int length1 = text1.length(); int length2 = text2.length(); // 创建dp数组，保存结果。长度多加1位，因为存在dp[0][j]、dp[i][0]的情况，这种情况值都为0 int[][] dp = new int[length1+1][length2+1]; // 从1开始，是因为当i、j从0开始时，i-1会小于0 for (int i = 1; i &lt; length1+1; i++) &#123; for (int j = 1; j &lt; length2+1; j++) &#123; if (arr1[i-1] == arr2[j-1]) &#123; dp[i][j] = dp[i-1][j-1]+1; &#125; else &#123; dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j]); &#125; &#125; &#125; // 返回2个最长字符串的结果 return dp[length1][length2]; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://wonius.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://wonius.github.io/tags/LeetCode/"}]},{"title":"MacOS使用VS Code配置go环境","slug":"MacOS使用VS-Code配置go环境","date":"2020-11-26T08:51:07.000Z","updated":"2020-11-26T10:26:52.000Z","comments":true,"path":"2020/11/26/MacOS使用VS-Code配置go环境/","link":"","permalink":"https://wonius.github.io/2020/11/26/MacOS%E4%BD%BF%E7%94%A8VS-Code%E9%85%8D%E7%BD%AEgo%E7%8E%AF%E5%A2%83/","excerpt":"","text":"安装Go下载安装访问官网，根据需求下载。 我下载的是1.15.5，直接点击执行pkg文件安装就可以了。 默认是安装到/usr/local/go目录。 PS: 也可以使用brew安装的方式 设置环境变量主要有2个环境变量：GOROOT、GOPATH。 GOROOT：go的安装路径 GOPATH：项目路径 根据情况修改配置文件。我用的是zsh，座椅在.zshrc最后追加如下 1234export GOROOT=/usr/local/goexport PATH=$PATH:$GOROOT/binexport GOPATH=/Users/xxxx/goexport PATH=$PATH:$GOPATH/bin 改为别忘了source刷新下，然后go version验证下。 VS Code配置安装插件在扩展商店里搜索go，安装就可以了。 修改配置安装完成后，同时按住command+shift+p，输入open settings，打开setting.json，加入 &quot;go.gopath&quot;: &quot;/Users/woniu/go&quot; 安装go组件按住command+shift+p，输入go: install/update tools，然后勾选全部组件，确定，即可开始安装。 如果提示连接失败，可以改下代理 123# shell中执行go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.io,direct","categories":[{"name":"Go","slug":"Go","permalink":"https://wonius.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://wonius.github.io/tags/Go/"},{"name":"VS Code","slug":"VS-Code","permalink":"https://wonius.github.io/tags/VS-Code/"}]},{"title":"床了个垫","slug":"床了个垫","date":"2020-11-12T03:42:56.000Z","updated":"2020-12-07T15:30:52.000Z","comments":true,"path":"2020/11/12/床了个垫/","link":"","permalink":"https://wonius.github.io/2020/11/12/%E5%BA%8A%E4%BA%86%E4%B8%AA%E5%9E%AB/","excerpt":"","text":"​ 年轻不知腰金贵，老来只能默流泪。 ​ 最近体检有点腰突，然后就想换个床垫。之前一直睡得棕垫，老爸不知在什么地方买的，几百块钱，硬的跟平板似的。一度怀疑腰突就是睡它睡得。而且上海梅雨季节比较潮，劣质的棕垫会发霉，好巧不巧我今年前阵子突然感觉有点鼻炎，当时找了好久原因都没找到，现在想来估计也是因为这个床垫。 ​ 有人可能会问，腰突不就是应该睡硬床垫吗？这里面其实一直有个误解，硬是有一个前提的，是贴合人体曲线的“硬”。人体的腰部是反S曲线，如果睡在硬板床上，腰部是悬空的，反而会使腰突加剧。软也不行，太软了腰部托不住，睡眠时腰部还是无法放松。 ​ 现在的人多多少少都会有点腰椎、颈椎、腰肌的问题，所以选个好床垫也是很有必要的。这段时间陆陆续续也翻了很多资料，做个笔记留个脚印。 分类乳胶床垫​ 这里说的是全软胶床垫，一般弹簧床垫填充层也会放一层乳胶炒个概念，不过扔然划分在弹簧床垫里。乳胶的优缺点都很明显，优点是透气性好、贴合性高，缺点是支撑性较差，而且随着时间变成会氧化成黄色。做工差的乳胶最终还会氧化成粉末。 ​ 需要说明的一点，但凡是做成床垫的乳胶，其实都是工业乳胶。真正天然的乳胶是液态的，🇹🇭的橡胶树再牛逼，也不可能长出来一张床垫子。区别在于乳胶发泡方式、乳胶含量。乳胶床垫水也是挺深的，很多都在炒泰国的概念。其实很多都是国内厂造的，外面走了一圈，出口转内销，身价骤升。就算真的是🇹🇭产的，也未必好多少，他们那边是原材料好，但是工艺差。 ​ 专业做乳胶床垫的首推邓禄普，不过我没去睡过。斯林百兰的卖点也是软胶，他们家的弹簧床垫乳胶层都很厚，最厚的有10公分。睡感偏软，女孩子可能会喜欢。 棕垫​ 分山棕和椰棕，也是国内比较容易炒的一个概念，深受中老年群体喜爱，销售基本都会说老年人适合睡硬的床垫。实际上睡感跟硬板差不多，腰部没有支撑，贴合性也差，真的是不建议中老年人睡。另外南方梅雨季节容易潮湿，也不推荐睡棕垫。 ​ 棕垫我基本没体验，穗宝家貌似挺多的。 记忆棉床垫​ 记忆棉的贴合性也很好，做的好的支撑性也高，不过透气性差，睡感偏热。 ​ 这个也没试睡过，听说泰普尔的很好，20多公分全是记忆棉，有睡在云端的感觉。不过一个垫子也在2w左右了，价格也是不低。 弹簧床垫组成​ 终于到了最复杂、最常见的弹簧床垫了。弹簧床垫总共3部分组成，弹簧、填充、面料。 ​ 弹簧是整个床垫的核心，支撑性如何、有没有异响、可以承受多少次的压缩等，都对弹簧床垫的寿命有影响。弹簧也是五花八门，根据材料、形状、高度、丝径粗细、排列方式、黏合方式等不同又可以有各种高大上的名称。 ​ 填充层决定的是床垫软不软，这层一般会有好几层，XX棉啊、XX乳胶啊、XX3D材料啊、XX棕啊，感觉什么材料都可以往放，然后可以蹭个概念。有些厂家可能放了1公分都不到的乳胶，就开始宣传是乳胶床垫。 ​ 面料层相对来说简单一点，一般主打防螨、银离子杀菌、亲肤之类。 ​ 我个人觉得选购弹簧床垫不用太把销售说的当回事。比如某家床垫填充层就炒了个概念火山棉、冰雪棉，还印在宣传页上。实际睡的时候是否能够隔着床单、面料感受到这些许差异，真的要打个问号。 ​ 另外呢，很多人以为弹簧床垫就叫席梦思，其实不是的。独立袋装弹簧的生产机器最早是席梦思研发出来的，然后其他床垫纷纷使用，为了营销也都说自己是席梦思。 弹簧类型​ 弹簧类型五花八门，总体上来说分3类，独立袋、美姿弹簧、妙而扣。这么分主要是根据弹簧结构分的，其他的种类基本上都是以这3种为基础延伸出来的，然后起个新奇的名字，就开始宣传了。 独立袋​ 最常见的弹簧种类，结构很简单，将筒状的弹簧装在纺织袋中，每个都是独立的个体，然后将筒子组装排列起来。根据弹簧大小不同，同样尺寸的床垫中筒子个数也不同。一般来说一张1.8*2m的床垫差不多800个弹簧左右。 ​ 独立袋最大的特点呢就是抗干扰性好，这也很好理解，筒子之间是相互独立的嘛。以前看到过一个床垫测评的视频，在一角放了一个🍷，然后有个人从旁边跳到床垫上空保持盘腿的姿势落到床垫上，酒杯里的红酒连个涟漪都没有。当时看了还觉得好神奇，哈哈哈。 ​ 另外环保方面可能差一点，因为筒子之间的纺织袋也要固定，有些厂家会用胶。了解一点家装知识的朋友都知道，胶里面基本都会有甲醛的，这个一定要注意一下。也有些厂家采用其他方式固定，比如缝起来，这种呢费时费力，比较少。 ​ 使用寿命方面基本都是10年质保，这个什么说的。 ​ 使用的材质基本上高锰钢、高猛碳钢，具体差别如何没做过深究，我觉得应该差别不大。 ​ 另外需要注意的一点是，弹簧的丝径和重量。有些厂商呢光吹嘘自己床垫的的数量最多，有可能在弹簧上缩水，丝径太细支撑性就差很多，而且也容易断。 美姿弹簧​ 丝涟的看家本领，也叫LFK开口弹簧，结构是相邻的弹簧之间被一组横着的弹簧捆绑在了一起，当有重压的时候弹簧向下压缩，同时最上面开口也会被拉大。如果脑补不出来呢可以上网搜一下动图。 ​ 美姿最大的特点是贴合性好，会随着重物的曲线变化。这点呢我觉得更适合腰不好的同学。 ​ 环保方面比独立袋好，因为弹簧之间是用钢丝连起来的，而不是胶。 ​ 寿命基本也是10年质保。 ​ 材质也差不多。弹簧嘛，最终的形状可能不同，原材料都是一样大的。 妙而扣​ 舒达的招牌，基本上只有他家有。它的结构稍微复杂一点。糖画大家都见过吧，把糖加热成液体，然后在板上画出各种形状。手艺人作画时基本上都是从头到尾一气呵成。妙而扣也是一样，从头到尾一个钢丝贯穿到底。 ​ 妙而扣最大的特点就是承重性好，随便你怎么压怎么造。舒达店里的销售当时跟我们说，之前公司专门找了辆大卡车从妙而扣上压过去，碾过去后啥事儿没有😂，想想也是牛逼。 ​ 环保方面跟美姿差不多，都是钢丝串联的。 ​ 寿命就厉害了，别家都是10年质保，舒达不一样，25年。由此也能看出来这种结构确实耐造。 ​ 材质不说了，大差不差。 ​ 妙而扣更适合几百斤的大胖子。美国人胖子多嘛，所以专门研发出来了这种结构。 品牌国外丝涟​ 上面也说了，主打是美姿感应弹簧。作为3S中的一员，价格也是不低的。上海红星美凯龙基本都9k以上。这家床垫我体验的少，当时不怎么了解丝涟，就在中途逛累了的时候，跑人家店里休息去了😂，别说躺了20min还挺舒服的。 舒达​ 3S之一。主打妙而扣，不过也有独立袋装弹簧的产品。因为舒达把席梦思收购了，所以现在这2S是同一家的2个产品品牌… ​ 他们家我试了亚特兰大、天籁、星辰。其中星辰是独立袋，另外两款是妙而扣。亚特兰大睡感最软，价格1w2出头；其次天籁硬一点，价格8.6k；最硬是星辰，价格7.6k。 ​ 这里有个小插曲，本来我跟女朋友试睡下来好不容易达成共识（她喜欢软的，我喜欢硬的），下单订了天籁。结果回去一查，沈阳的红星才6k多，立马心里不平衡了，然后给退了… 席梦思​ 3S之一。主打独立袋，他们家的独立袋装弹簧应该是所有同类产品中最好的吧，好多其他品牌也在用他们加的弹簧。产品线也很丰富，各种床垫由软到硬都有。 ​ 他们家我体验了银禧、瑞豪。银禧睡感软一点，7k出头；瑞豪睡感偏硬，8k出头。 金可儿​ 近几年金可儿也很出名，基本与3S齐名了。我跟女朋友想换床垫的想法，也源于在海南玩睡了威斯汀的天梦之床之后种了草。而天梦就是出自金可儿之手。不过天梦是酒店专供款，一般家用买不到。本来到红星也想试试繁星A来着，结果线下没有。 ​ 在他们家只试了一张，专家之选，2w+…嗯…也挺好的就是有点贵… 斯林百兰​ 英国牌子，主打是独立袋+天然乳胶。红星的销售告诉我们，他们家的软胶都是物理发泡、乳胶含量77%以上。然后还说透气性比海绵好巴拉巴拉，我纠正她说海绵透气性要比乳胶好的，她还不信… ​ 他们家试了温度智慧1200、护脊智慧2060、海洋奇缘（也不知道到底哪里智慧了…）。睡感都偏软，好像是海洋奇缘，乳胶层有10公分。不过我不喜欢太软的，就撤了。 泰普尔​ 好像也是英国牌子吧，专门做海绵床垫的。这家我没试睡过。当时也不太了解海绵床垫，总觉得睡上去就跟塌下去一样，所以看到门店就绕过去了。不过后来查了些资料，发现有些腰部有问题的人也在推荐这个床垫，睦风、微风系列，有睡在云上的感觉，腰部也有支撑。咱没试过也不知道到是真是假。 国内喜临门​ 国内知名品牌，名字好听，而且广告力度也很大。去他们店里逛了逛，人确实挺多。试了优眠6926、静眠S26、蜜月季钻石。后两款睡感跟席梦思的瑞豪差不多，结果价格比席梦思还贵…真不知道为啥… ​ 另外喜临门的销售你能感觉到他们的不专业。首先是对自己家产品就不了解，其次是对床垫也不怎么了解。问个问题支支吾吾的。而且服务意识很不好，我们在店里呆了也就10来分钟，前后换了3个销售…总之给我的印象极差，东西又贵又不专业的印象。 慕斯​ 也是国内知名品牌，广告也不少。相信很多人都看到过一个外国老头带着眼镜的宣传海报。他们家我就试了一款，233B，16k，3d材料的，也还行。不过试玩没什么特别的印象。另外不知道为什么，网上好多人都在喷慕斯，可能是因为水军请的太多了吧。 爱舒​ 上海老牌子，价格相对亲民一点。哪怕在上海，5k也能买到他们家比较好的床垫了。试睡了舒心E、爱之韵m。舒心E偏硬，2.8k；爱之韵m软一点，4.5k。个人感觉性价比较高。 龙凤​ 也是国内品牌。他们家试了几个床垫都很软，最后试了至欣还不错，刚躺上去软软的，时间久了也能感受到支撑，好像是他们家至尊系列中的一款。7.5k左右。 购买渠道​ 无非线上、线下两种。不过现在厂家都学聪明了，线上、线下2个产品线，相互隔离。也就是线上官方绝对买不到线下的款式，线下也不会摆线上的款。一般来讲，线下都会比线上贵。线上大多在6k左右。线下6k可能是最基础款。不过没办法，人家赚的就是你线下体验的钱。 ​ 不过近来倒是有些厂家，比如红星，也会开网店，所以能看到一些线下的款在卖。而且这种一般只买本市，不会跨市出售的。像我跟女朋友，看到沈阳的红星有卖天籁，但是也没法子买。不过如果你有朋友正好在那边，可以帮忙买一张，然后发物流。现在物流也便宜。 ​ 另外淘宝上也有一些代购，比官方价格会便宜个1-2k，基本都是剪标的。为什么剪标呢，因为标签上会有指定出售的城市（相同产品在不同城市官方售价不同，恶心吧），如果跨城市出售官方会追究责任的，所以代理商一般也不会跨城市出售。当然也有积压了很多库存，实在没办法想回笼资金的，也会出售到异地，这种情况就得剪标。 线下大V推荐腿毛​ 人是四川的，也是床垫行业的，也有自己的淘宝店。拆了很多床垫，比较专业。主要活跃在知乎。 家居破坏王​ 非床垫行业的素人，也是专门拆床垫的，相对来说专业性没那么强。不过也提供了普通人的视角。知乎、B站上都有。 最后​ 买床垫呢一定不能偷懒，毕竟不是经常换的物件，所以能到线下体验的一定要到线下体验。睡感这个东西，网上看再多攻略、视频也是体验不出来的。 ​ 另外试睡呢不要用屁股试。好多人都是往那一坐，试试软不软就买了。一定要多躺会，躺个10来分钟，感觉腰部有没有支持。然后侧身睡感受肩膀会不会有挤压。 ​ 最后呢不要怕花钱，床垫这个东西是真的对你的身体健康有影响的。花个几千块，买个每晚的舒适睡眠，以及将来健康的躯干，还是值得的。不过也不能盲目花钱。1w以内的床垫能满足大部分人的需求，2w以上都有点玄学的成分。","categories":[{"name":"生活","slug":"生活","permalink":"https://wonius.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"床垫","slug":"床垫","permalink":"https://wonius.github.io/tags/%E5%BA%8A%E5%9E%AB/"}]},{"title":"K8S部署Nacos节点列表为空","slug":"K8S部署nacos节点列表为空","date":"2020-11-02T02:49:44.000Z","updated":"2020-11-02T08:42:11.000Z","comments":true,"path":"2020/11/02/K8S部署nacos节点列表为空/","link":"","permalink":"https://wonius.github.io/2020/11/02/K8S%E9%83%A8%E7%BD%B2nacos%E8%8A%82%E7%82%B9%E5%88%97%E8%A1%A8%E4%B8%BA%E7%A9%BA/","excerpt":"","text":"背景​ 最新因为项目需要，需要搭建一个配置中心，nacos相对来说教简单，而且还赠送一个注册中心，买一送一，业界良心啊，就它了。过程就不赘述了，下载nacos-mysql、nacos-server镜像，编写好helm模板后直接部署。 问题发现​ 噼里啪啦一顿操作后，输入账号登录nacos-console，体验了一下，配置中心增删改查都正常，但是集群管理中的节点列表却是空的。 分析 第一反应是查看服务的状态与日志，kubectl log xx和kubectl describe po xx看到都是成功的状态。 ​ 2. 先验证下配置中心吧，修改代码，加载配置中心的配置，成功。所以验证只有注册中心有问题。 ​ 3. 进入到nacos-server pod，查看日志。/home/nacos/logs目录下主要分2类日志，config-*.log和naming-*.log，分别对应配置中心的日志和注册中心的日志。 先看naming-raft.log，这个是选举日志，发现果然有问题。 WARN [IS LEADER] no leader is available now! nacos在创建过程中，会将每个节点的地址存放在/home/nacos/config/cluster.conf，查看该文件，3个pod的内部域名也是正常。进到pod内部，telnet其余2台的域名、端口也是通的。 到这基本验证了pod创建是成功的，且相互之间也可以访问。问题应该出在3台pod在竞选时，没有使用cluster.conf中设置的内部域名，而是通过其他方式访问，导致相互之间访问失败。这时候目标转向service。 解决然后到网上搜了下，有的说将service设置为ClusterIP: none，改为headless service。尝试了下，果然好了。 后续​ 为什么改为headless service就好了呢？ ​ 因为默认的Service的type是ClusterIP，会在创建service的时候，为service创建ip，所有访问该service的请求，都会经过该ip然后做负载均衡。如果设置为none，就不会为该service分配ip，只能通过pod的域名访问每个pod。一般pod间需要相互访问的服务都采用这种模式，比如zk等。 ​ 通过kuectl get svc可以查看所有的service。也可以通过kubectl describe svc xxx，查看每个service的详情。 ​ ​","categories":[{"name":"K8S","slug":"K8S","permalink":"https://wonius.github.io/categories/K8S/"}],"tags":[{"name":"K8S","slug":"K8S","permalink":"https://wonius.github.io/tags/K8S/"}]},{"title":"华硕TUF-AX3000刷梅林固件","slug":"华硕TUF-AX3000配置梅林固件","date":"2020-10-27T13:07:23.000Z","updated":"2020-11-18T01:40:35.000Z","comments":true,"path":"2020/10/27/华硕TUF-AX3000配置梅林固件/","link":"","permalink":"https://wonius.github.io/2020/10/27/%E5%8D%8E%E7%A1%95TUF-AX3000%E9%85%8D%E7%BD%AE%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6/","excerpt":"","text":"背景​ 最近购入了新路由器，华硕TUF-AX3000，准备开始折腾。（以前用的是华为AX3 Pro，性价比也很高，算是300元内性价比之王了吧，颜值在线，wifi6标准，还能NFC连接WiFi。唯一不能满足我的就是，不能安装插件科学上网。） 选择目标价位是800左右，然后有几个备选都还不错，网件R8000P、华硕RT-AC86U、华硕TUF-AX3000。奈何其余两款不支持WiFi6，购入这个路由器短期内肯定不会更换了，所以一步到位，直接上WiFi6，最终选择了华硕TUF-AX3000。 如何挑路由器就只能在网上找资料了，比较权威的还是acwifi。 购入对比了狗东、拼夕夕，还是拼夕夕香啊，最后在拼夕夕下单。 拼夕夕有好多拆封帮忙刷入梅林固件的，我担心是返修的机器，直接买了全新版本。600多软妹币。 家里的台式网卡坏了好久，拖着一直没弄，这次顺便入了个Intel-AX3000T无线网卡，同样支持wifi6，终于重新焕发青春。这下子终于可以云顶下棋啦🥳 刷固件找固件机器到手后就开始了折腾，不折腾也不会买华硕了。 找固件常用的论坛有恩山、koolshare。 几经周折，找了好几个版本都比较旧，最终在koolshare上找到这篇帖子，是基于最新官方固件（384_9923）修改的。一起就绪，开整。 刷机刷机比较简单，连上wifi后，访问router.asus.com，登入后在系统设置里，上传固件，等待刷新，升级完重启就行了。 重新登录，看到里面有了软件中心。有一些内置的插件可以直接安装，不过没有我们想要的科学上网插件。好吧，继续找。 安装插件找插件又是几经周折，终于找到了ss插件，我这里下载的是1.8.8版本。 记住下面这些参数，找插件的时候用得到。 CPU：BCM6750，平台：axhnd.675x，架构：ARMV7，内核：4.1.52。 安装插件 下载完成后，登录路由器管理页面，点开软件中心，然后离线安装，上传安装包。 安装过程中会提示检测到非法关键词，安装失败。 这时候需要使用ssh远程登录到路由器上（路由器ip在管理页面上有），输入管理员账号、密码，然后执行下面的命令关闭校验。（如果登录失败，提示WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!，到.ssh目录下删掉known_hosts文件） 1sed -i &#x27;s/\\tdetect_package/\\t# detect_package/g&#x27; /koolshare/scripts/ks_tar_install.sh 重新上传安装包，然后安装，这时候提示安装成功。 刷新页面，可以看到软件中心下有科学上网的插件了，点进去，配置v2ray相关的配置或者ssr的配置，然后打开开关。 发现并没有开启科学上网！！！ 原因是路由器本身的内存太小，不足以支撑v2ray插件运行。 买一个好点的U盘，插到路由器上，安装虚拟内存的插件，创建1G的虚拟内存并挂载，然后就能科学上网啦！ 路由器相关的一些命令清空jffs，改命令会将软件中心下所有的插件删掉。 1234kill -9 $(pidof skipd)cd /jffsrm -r .[a-zA-Z_]* *reboot 删除软件中心 123kill -9 $(pidof skipd)rm -rf /jffs/.asusrouter /jffs/.koolshare /jffs/db /jffs/ksdb /jffs/config/* /jffs/etc/profilereboot one more thingv2ray运行的时候会占用系统资源，因为路由器天生的局限性，配置不会太高，所以最近又被软路由种草了…兴冲冲的跟女票说这个事儿，又被无情的diss了… 不过一般情况路由器就够用了。除非你家宽带和机场带宽都500M以上，不然看不出来差距。","categories":[{"name":"路由器","slug":"路由器","permalink":"https://wonius.github.io/categories/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"tags":[{"name":"路由器","slug":"路由器","permalink":"https://wonius.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"}]},{"title":"configMap的应用","slug":"configMap使用","date":"2020-10-21T08:12:36.000Z","updated":"2020-11-12T03:38:33.000Z","comments":true,"path":"2020/10/21/configMap使用/","link":"","permalink":"https://wonius.github.io/2020/10/21/configMap%E4%BD%BF%E7%94%A8/","excerpt":"","text":"背景​ 我们系统的微服务是通过K8S容器化部署的，由于某些原因，没有对接配置中心。所以为了将配置与应用分离，便于后续修改配置，决定使用configMap+deployment的方式，将配置文件外挂到应用上。 步骤思路​ 整体思路是，创建application.yml配置文件，应用打包时将该文件打到包内。然后将每个环境的 修改应用修改应用，指定配置文件为application.yml 创建configMap1kubectl create cm xxx-config --from-file=ci=xxxx.yml --from-file=stg=xxx.yml --from-file=prod=xxx.yml 修改deployment123456789101112# mountPath- name: cm mountPath: /xx/xx/application.yml subbPath: application.yml # volumes- name: cm configMap: name: xxx-config items: - key: ci path: application.yml 修改完成后部署验证","categories":[{"name":"K8S","slug":"K8S","permalink":"https://wonius.github.io/categories/K8S/"}],"tags":[{"name":"K8S","slug":"K8S","permalink":"https://wonius.github.io/tags/K8S/"},{"name":"configMap","slug":"configMap","permalink":"https://wonius.github.io/tags/configMap/"}]},{"title":"Hexo升级记录","slug":"Hexo升级记录","date":"2020-10-19T07:58:36.000Z","updated":"2020-11-03T14:19:39.000Z","comments":true,"path":"2020/10/19/Hexo升级记录/","link":"","permalink":"https://wonius.github.io/2020/10/19/Hexo%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/","excerpt":"","text":"背景​ 最近因为某些原因，升级了本机电脑上Node，然后引发了一连串的连锁反应，其中就包括Hexo。前后也花了点时间，mark下。 先升级Node123456789101112131415161718192021# 首先安装n组件npm install -g n# 使用n升级node版本。stable是最新的稳定版，latest是最新版。根据情况使用sudo n stablesudo n latest# 查看版本验证node -v# 升级npm，xx为版本号。也可以使用latest，更新最新版本sudo npm install npm@xx -g# 验证npm版本node -v 或者 node version# 常用的一些命令npm view node versions // 查看node所有版本npm view npm versions // 查看npm所有版本npm view npm version // 查看npm最新版本npm ls 或者 npm list // 查看npm所有插件，ls是list的简写npm ls -g --dept 0 // 查看本机安装的npm插件npm ls xx -g // 查看xx相关的插件，比如hexo 再升级Hexo1234567891011121314# 安装npm-check、npm-upgradenpm install -g npm-checknpm install -g npm-upgrade# 检查更新npm-check# 更新package.jsonnpm-upgrade# 升级。如果升级某个模块，在update后面加模块名xx，不加的话全部升级npm update -g# 保存package.jsonnpm update --save 如果是Mac OS，在升级过程中可能会遇到提示没有安装xcode组件的情况。 可以访问苹果开发者下载中心，搜索Command Line Tools，根据系统版本找到对应的安装包，下载安装就可以了。 再修改主题之前一直用的Next，时间久了有点审美疲劳，而且我当时的版本离最新版差别比较大，后续自己改过很多东西，升级也比较麻烦。所以干脆换了个主题。 发现Oranges挺清新脱俗的，就它了。 12345678# 进入到hexo目录，安装主题git clone https://github.com/zchengsite/hexo-theme-oranges.git themes/oranges# 然后修改hexo的_config.yml中的主题theme: oranges# 重新编译、部署hexo g &amp;&amp; hexo d 后话hexo升级后真不是一般的快哇，真香！","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://wonius.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://wonius.github.io/tags/Hexo/"}]},{"title":"NodeJs安装与升级","slug":"NodeJs安装与升级","date":"2020-10-14T09:25:24.000Z","updated":"2020-11-03T14:00:35.000Z","comments":true,"path":"2020/10/14/NodeJs安装与升级/","link":"","permalink":"https://wonius.github.io/2020/10/14/NodeJs%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%87%E7%BA%A7/","excerpt":"","text":"NodeJs安装首先安装homebrew 123456# 使用brew安装nodebrew install node# 然后查看版本node -vnpm -v NodeJs升级123456789101112131415# 清楚node的缓存sudo npm cache clean -f# 安装nsudo npm install -g n# 用n安装最新的稳定版本sudo n stable# 升级npmsudo npm install npm -g# 查看版本node -vnpm -v 其他命令 123456# node所有版本npm view node versions # npm所有版本npm view npm versions # 已安装插件npm list","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://wonius.github.io/categories/Frontend/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://wonius.github.io/tags/NodeJs/"}]},{"title":"Redis主备自动切换高可用方案","slug":"Redis主备自动切换高可用方案","date":"2020-10-14T01:45:03.000Z","updated":"2020-10-14T03:14:40.000Z","comments":true,"path":"2020/10/14/Redis主备自动切换高可用方案/","link":"","permalink":"https://wonius.github.io/2020/10/14/Redis%E4%B8%BB%E5%A4%87%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/","excerpt":"","text":"背景​ 某个客户购买了我们产品，需要到客户机房搭建高可用的redis，而且要求出现故障能够自动切换主备。考虑到节省机器，而且redis中数据也不会超过1G，决定用主从架构+keepalived实现。 搭建所需资源 2台主机 1个vip redis主从搭建 2台主机分别安装reids，并设置为开机自启动 修改redis.conf，设置主从 设置keepalived 2台主机分别安装keepalived，并设置为开机自启动 编写监听redis的脚本、修改master状态的脚本、修改slave状态的脚本 修改keepalived.conf，设置vip、各脚本 验证 先查看2台redis（A、B）的角色 手动将master（A）的redis关闭，然后查看slave（B）的角色是不是切换为master 在新的master（B）中设置一个值，比如hello 重新启动A，查看A的角色是否为slave，并验证A中是否将hello同步过来","categories":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://wonius.github.io/tags/Redis/"}]},{"title":"Solr高亮优化","slug":"solr高亮优化","date":"2020-10-14T01:41:23.000Z","updated":"2021-02-18T01:59:40.000Z","comments":true,"path":"2020/10/14/solr高亮优化/","link":"","permalink":"https://wonius.github.io/2020/10/14/solr%E9%AB%98%E4%BA%AE%E4%BC%98%E5%8C%96/","excerpt":"","text":"0729进展：删除了一些无用的过滤器，并打开httpcaching缓存。目前压测开20个线程（静态参数）1分钟，错误率约0.3%左右。20个线程（动态参数）1分钟，错误率约3.68%左右。后续优化方向： solr内存回收策略方面调整； solr查询优化参数调优； 查看高亮其他过滤器； PS：目前效率这么差，主要是因为高亮。因为使用高亮查询时，相当于在查询时重新索引，不会用之前构建的索引，所以比较消耗资源，也比较慢。 0730进展： 删除了查询逻辑中无用的字段 调整solr的jvm新生代内存分配，减少gc的次数 调整tomcat线程池这些调整都没什么较好的效果，目前效果：压测开20个线程（静态参数）1分钟，错误率0.1%左右。压测开20个线程（静态参数）1分钟，错误率25%左右。（昨天solr内部只有2w条数据，今天solr中有22w条数据） 明天的方向：再查些资料看看（这方面资料不多） 0731进展： 高亮组件改为FastVectorHighlighter 重新调整solr的jvm新生代内存分配 将solr中的collection改为2个分片效果：因为改了分片，目前在重建索引，solr中的数据5w左右压测开20个线程（动态参数）1分钟，错误率0.03%左右。压测开50个线程（动态参数）1分钟，错误率10%左右。（前50秒在0.02%，后10秒错误率突增，主要是因为由于压测的电脑线程跑满，无法创建新线程报的错） 优化成这样就差不多了吧 这几天做了如下优化： 调整全局搜索应用代码，删除不需要的查询字段和高亮字段； 将高亮字段类型改为持久化，可以持久化高亮字段的索引； 删除高亮字段所属的类型字段的过滤器（主要是同义词和停用词，我看了对应的文本文件，只有2条内容，应该是搭建solr时从别的地方拷贝过来的） 优化启动solr时jvm的内存分配 默认高亮组件效率较低，改为FastVectorHighter高亮组件 之前uat环境数据只有1个分片，现在改为了2个分片 调整了solr的配置，打开了httpcaching缓存","categories":[{"name":"中间件","slug":"中间件","permalink":"https://wonius.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"Solr","slug":"Solr","permalink":"https://wonius.github.io/tags/Solr/"}]},{"title":"Oracle高可用架构","slug":"Oracle高可用架构","date":"2020-05-12T03:05:42.000Z","updated":"2020-12-25T07:43:33.000Z","comments":true,"path":"2020/05/12/Oracle高可用架构/","link":"","permalink":"https://wonius.github.io/2020/05/12/Oracle%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/","excerpt":"","text":"最近了解了一些Oracle方面的高可用架构，记录一下。 有时间补上架构图。 DG架构该架构是传统的主备架构，也是最常用的架构，满足一般系统的要求。 首先，申请两台完全同构的主机，挂载相同的NAS，并安装Oracle，修改设置。一般primary机对外提供服务，其他standby机备份。 每台Oracle主机都是独立的主机与存储，通过同步归档日志和在线日志实现数据同步。 一般DG架构中每台主机都会挂载一块NAS，Oracle数据和日志存放在NAS上。 建tablespace时指定datafile到NAS上。 当异常情况时，切换备机，切换时间一般为几分钟。 1234567-- 常规模式，创建名为dbdata的表空间create tablespace dbdata logging datafile &#x27;/xxx/xxx/data.dbf&#x27; size 500m autoextend on extent management local autoallocate segment space management auto ; PS：这里讲下DG和OGG主要的区别。DG效率更高、更稳定、占用资源少，但是只支持Oracle间同步。OGG效率、稳定性、资源占用都要差一点，但是支持不同数据库间同步。 RAC架构DG只使用Oracle就可以完成。 RAC架构需要与Oracle的另外一种技术，ASM（Automatic Storage Management），结合使用。基本原理是，不同Oracle主机共享同一块存储，就不需要数据同步了，而ASM是Oracle开发的管理存储的工具。 该模式下需要先建立一个ASM实例，然后不同Oracle主机使用该ASM，创建表空间时指定该ASM。 RAC、ASM对于硬件的要求更高，且由于共享数据，基本可以实时切换。一般应用于核心系统，如支付系统等。 1234-- ASM模式，ASM实例名为+data_asm，创建名为dbdata的表空间create tablespace dbdata datafile &#x27;+data_asm&#x27; size 500m autoextend on; 多机房架构不论是DG架构，还是RAC架构，都在单一机房。 当企业对于数据有更高要求时，就要考虑多机房架构了。 根据是否同城又有同城备份，异城备份，以及两地三备份。 就说两地三备份吧，总共涉及3个机房，主机房A，同城机房B，异地机房C。 在主机房A中Oracle可以选择DG或者RAC架构。 同城机房B和异地机房C，视要求搭建。不同库间使用DG同步，同步链路为A-&gt;B，A-&gt;C。","categories":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://wonius.github.io/tags/Oracle/"},{"name":"高可用架构","slug":"高可用架构","permalink":"https://wonius.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/"}]},{"title":"Oracle编码问题","slug":"Oracle编码问题","date":"2020-05-11T07:45:01.000Z","updated":"2020-05-18T12:31:09.000Z","comments":true,"path":"2020/05/11/Oracle编码问题/","link":"","permalink":"https://wonius.github.io/2020/05/11/Oracle%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"最近被Oracle的编码问题折腾的头都大了，在这里总结一下。 在Oracle搭建，以及初始化脚本过程中，共有4处涉及到编码问题。 关于编码问题，实际上讲的是如何设置编码，保证中文不乱码。如果是仅是英文字符，不会有乱码问题的。 有一点需要区分，命令执行环境是在shell，还是在sqlplus。 操作系统字符集可通过locale和env | grep LANG命令查看。 该编码对于Oracle无影响，因为Oracle有自己的字符集，优先使用自己的字符集。 就算两台主机的字符集不同，只要Oracle的字符集相同，也可以正常使用。 只有在当前主机做调整时，才会依赖主机字符集。比如在shell中执行数据库的更新查改操作，其中涉及到主机编码与oracle编码互转的过程。如果两边编码不匹配，也会乱码。 需要强调的一点是，sqlplus如果本身没有设置字符集，会默认使用操作系统的字符集。所以在使用sqlplus执行脚本的时候，要注意NLS_LANG设置为AMERICAN_AMERICA.ZHS16GBK，保证中文不乱码。 Oracle字符集在建库(create database)时，可以设置该库的字符集，一般选择AL32UTF8。 当登入sqlplus之后，执行sql语句做插入或者更新操作时，存入的数据以该字符为准。 脚本字符集这点指的是sql脚本文件中的编码字符集。 一般来讲我们常用的只有两种，UTF8或者GB2312。 当脚本中全英文时，任何编码都可以。 当脚本中涉及到中文字符时，需要保存为GB2312格式。 文件格式常用编辑器，比如UE、Notepad++，在下方状态栏都会显示文件格式，总共有三种格式，UNIX、Dos\\Windows、MAC。 这个编码标明该文件是在什么操作系统下编辑生成的。 我们的脚本直接在sqlplus中执行，已测试过使用UNIX、Dos\\Windows都可以正常执行。 如果是在shell中执行，需要改成UNIX。之前我在win7上编写过一个Dockerfile，上传到主机执行报错，改为UNIX才正常执行。 在Linux主机上，可以再vim中查看、修改文件格式。输入:set ff查看，输入:set ff=unix修改。 ssh工具编码这点应该不用多说了，相信大家都有经验。不管是shell，或是sqlplus中执行命令，如果最终要展示的结果中包含中文，就算主机编码正确，如果工具编码不对，也会展示乱码。 同样，一般设置为UTF8。 为了避免工具对数据库中数据编码的影响，我一般的操作都是，将sql脚本上传到Oracle主机上，然后登陆sqlplus，使用@xxx/xxx/xxx.sql的方式，直接加载脚本文件执行。","categories":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://wonius.github.io/tags/Oracle/"}]},{"title":"Oracle彻底删除某database","slug":"Oracle彻底删除某database","date":"2020-05-11T07:19:20.000Z","updated":"2020-11-03T14:01:49.000Z","comments":true,"path":"2020/05/11/Oracle彻底删除某database/","link":"","permalink":"https://wonius.github.io/2020/05/11/Oracle%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E6%9F%90database/","excerpt":"","text":"环境：Oracle 12c 假设要删除的库名为hello，首先登陆上主机。 1234567891011121314151617181920-- 在shell中执行下面命令，登陆sysdba用户sqlplus / as sysdba;-- 依次执行（该操作会将所有库删除）shutdown immediate;startup restrict mount;drop database;-- 然后退出sqlplusquit;-- 删除dbs下面的引导文件cd $ORACLE_HOME/dbs-- 将名称中包含库名（hello）的都删掉rm -f hc_HELLO.dat···-- 查找并删除数据文件find $ORACLE_BASE/ -name $ORACLE_SID-- 将查找到文件都删除rm -rf xxxx","categories":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://wonius.github.io/tags/Oracle/"}]},{"title":"ZK那点事儿","slug":"ZK那点事儿","date":"2020-03-25T03:16:12.000Z","updated":"2020-03-25T03:26:39.000Z","comments":true,"path":"2020/03/25/ZK那点事儿/","link":"","permalink":"https://wonius.github.io/2020/03/25/ZK%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/","excerpt":"","text":"特性 应用场景：集群管理、注册发现中心、分布式锁； 集群为单数，是为了省资源； 最小集群实例数为3台。如果只有2台，一台都不能挂，跟单点效果是一样的。 加入新节点需要修改所有的zoo.cfg； 修改完后如果生效需要重启。有两种方案：1. 同时重启；2. 按特定顺序重启； 如果先重启leader，会造成脑裂； Port1：非选举通讯端口；port2：选举通讯端口； 选举规则：先看事务id，相同，在看server.id；选票（事务id，server.id）； 集群越大，节点越多，针对每个节点的通讯消耗越大，socket线程越多； 每台实例一个Znode，容量1M，数据存储在内存中； zk是cp架构，不适合做注册中心，注册中心更适合ap架构，nacos就是；","categories":[{"name":"中间件","slug":"中间件","permalink":"https://wonius.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://wonius.github.io/tags/ZooKeeper/"}]},{"title":"RDBMS那点事儿之Undo-log、Redo-log和binlog","slug":"RDBMS那点事儿之Undo-log、Redo-log和binlog","date":"2020-03-11T08:31:04.000Z","updated":"2020-04-09T16:39:13.000Z","comments":true,"path":"2020/03/11/RDBMS那点事儿之Undo-log、Redo-log和binlog/","link":"","permalink":"https://wonius.github.io/2020/03/11/RDBMS%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF%E4%B9%8BUndo-log%E3%80%81Redo-log%E5%92%8Cbinlog/","excerpt":"","text":"概述undo log当数据变更时，记录数据原始的状态。分两级策略，undo buffer和undo log。 undo buffer即在内存中，这种状态的数据是不稳定的，一般会立即持久化到磁盘中的file文件，即undo log。不同数据库undo log存放位置不同。对于Mysql来说，Mysql5.7后的版本最好单独创建undo表空间，避免一次更新大批量数据生成大量undo log却无法存储。 在事务开始之前生成。 redo log当数据变更时，记录数据要变更的状态。也分两级，redo buffer和redo log。 同undo log，redo buffer也存储在内存中，redo log持久化在磁盘上的file文件。 数据库收到更新请求，先查询原数据，写到内存（记为data buffer），然后生成redo buffer，持久化为redo log。之后更新data buffer，在持久化到data file。 在事务开始之后生成。如果事务比较大，在中间执行过程中都会生成，并不是事务提交时一次性生成。 同时会记录事务的状态，包括事务编号（事务开始时生成）、开始状态、结束状态。判断事务是否成功即根据该文件中事务的状态。 不同类型数据库存储格式不一样，有的undo log、redo log分开记录，格式如&lt;事务ID，变更项，变更前内容&gt;和&lt;事务ID，变更项，变更后内容&gt;。有些记录在同一个文件，格式如&lt;事务ID，变更项，变更前内容，变更后内容&gt;。 binlog用于mysql节点之间同步用的，基本可以做到实时同步。目前也有很多基于binlog实现的跨库同步，比如canal。 在事务提交时一次性写入。所以开启该功能时会一定程度上影响效率。 执行过程再完整的梳理一下完整的执行过程，当使用事务时： 1生成事务ID -&gt; 查询原值写到data buffer -&gt; undo log（包括buffer到file）-&gt; 事务开始 -&gt; redo log（包括buffer到file）-&gt; 执行操作（update或其他，操作过程中实时写redo log）-&gt; 事务完成 -&gt; binlog写入 中间任何环节出现问题，比如重启，以redo log中的事务状态为依据，判断是否需要回滚。 以上说的是单个事务的流程。但是我们知道最头疼的永远是并发的场景。 聊到这里了，顺便聊聊并发。 并发情况下产生的问题假设有两个事务T1、T2在同时进行。 脏读当T1执行过程中，对某条数据做了update，T2读取了该数据，但是最终T1回滚，T2再读数据，发现两次数据不一致。 关键点在于T1没有执行成功。 隔离级别为Read Uncommitted级别会出现该问题。 将隔离级别设置为Read Committed可解决该问题。Sql Server、Oracle模式是该级别。 不可重复读T1执行过程中，先读取了某条数据，然后T2对于该数据做了update，T1再读，发现两次数据不一致。 关键点在于，在T1执行过程的两次读之间，T2已经做完变更了。 将隔离级别设置为Repeatable Read可解决该问题。Mysql默认是该级别。 幻读T1执行过程中，查询符合某些条件的一批数据，然后T2做了insert操作，T1在重新执行查询语句，发现多了一条数据。 幻读与不可重复读有些类似，主要区别点在于所做的操作。不可重复读仅对记录做update，所以只要锁记录就可以解决。幻读是执行的insert操作，需要对表进行控制。 将隔离级别设置为Serializable可解决该问题。该级别下事务不能并发执行，只能顺序执行，所以性能也是最差的。","categories":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"}],"tags":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/tags/DB/"}]},{"title":"Jpa中使用@Scheduled报no transaction is in progress","slug":"Jpa中使用-Scheduled报no-transaction-is-in-progress","date":"2020-01-13T02:11:38.000Z","updated":"2020-03-25T03:24:26.000Z","comments":true,"path":"2020/01/13/Jpa中使用-Scheduled报no-transaction-is-in-progress/","link":"","permalink":"https://wonius.github.io/2020/01/13/Jpa%E4%B8%AD%E4%BD%BF%E7%94%A8-Scheduled%E6%8A%A5no-transaction-is-in-progress/","excerpt":"","text":"问题环境：springboot+jpa 某个接口使用@Scheduled定时调度，内部方法中使用了jpa的saveandflush方法，方法执行时报异常’no transaction in progress’。 分析 查看saveandflush实现，发现jpa内部实现都添加了事务@Trainsactional； 不用@Scheduled注解时，直接调用方法正常； 所以基本确认通过@Scheduled创建的线程，没有继承上下文中的事务管理器。 解决在@Scheduled注解的地方注入事务管理器。 https://stackoverflow.com/questions/33248846/spring4-scheduled-transaction-throws-no-transaction-is-in-progress-at-flush-fo","categories":[{"name":"Backend","slug":"Backend","permalink":"https://wonius.github.io/categories/Backend/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://wonius.github.io/tags/JPA/"}]},{"title":"容器内权限正常，无权限创建目录","slug":"Docker问题记录","date":"2019-12-30T02:15:55.000Z","updated":"2020-11-03T13:48:17.000Z","comments":true,"path":"2019/12/30/Docker问题记录/","link":"","permalink":"https://wonius.github.io/2019/12/30/Docker%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"容器内权限正常，无权限创建目录相关环境 Docker 18.09.07 kernel 4.4.185 问题容器内用户为某特定用户，比如woniu，容器内应用要在a目录下创建新目录，a目录属主为woniu，权限750。但是在创建时报错，权限不足。 排查过程 首先排查镜像是否正常。在其他主机run镜像，进入容器，可以成功创建目录； 对比两个环境的docker版本、配置等，通过调整docker配置等，还是无法解决问题，排除docker影响； 对比两个环境系统内核，发现内核版本不一致，分别为3.10.0 和4.4.185； 解决将内核版本有4.4.185降为3.10.0，运行容器，正常。 总结应该是docker在4.4.185上有bug，有待确认。 后来发现，貌似和tomcat版本有关，9.0版本普遍存在这个问题，跟镜像分层有关。 12345678910111213FROM centos:7.2.1511COPY apache-tomcat-9.0.30.tar.gz /opt/# 之前的dockerfile，解压与授权通过两条RUN执行，在不同层级，权限有问题RUN cd /opt \\&amp;&amp; tar xvf apache-tomcat-9.0.30.tar.gz \\RUN groupadd -g 5666 demo &amp;&amp; useradd -l -r demo -g demo -u 666 \\&amp;&amp; chown -R demo:demo /opt/apache-tomcat-9.0.30# 之后的dockerfile，解压与授权在一条RUN，同一层级，正常RUN cd /opt \\&amp;&amp; tar xvf apache-tomcat-9.0.30.tar.gz \\&amp;&amp; groupadd -g 5666 demo &amp;&amp; useradd -l -r demo -g demo -u 666 \\&amp;&amp; chown -R demo:demo /opt/apache-tomcat-9.0.30 https://github.com/docker-library/tomcat/issues/35","categories":[{"name":"Docker","slug":"Docker","permalink":"https://wonius.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://wonius.github.io/tags/Docker/"}]},{"title":"Nginx备忘录","slug":"Nginx备忘录","date":"2019-11-12T01:30:03.000Z","updated":"2020-11-03T14:00:23.000Z","comments":true,"path":"2019/11/12/Nginx备忘录/","link":"","permalink":"https://wonius.github.io/2019/11/12/Nginx%E5%A4%87%E5%BF%98%E5%BD%95/","excerpt":"","text":"安装12345678910# centosyum install nginx# ubuntusudo apt-get install nginx;# macbrew install nginx# 或者编译源码包，不推荐。# 先下载，解压./configure # 可以通过-prefix=PATH 指定安装目录make &amp; make install 相关命令123456789101112# mac中nginx默认安装在/usr/local/Cellar/nginx，同时也会加入到/usr/local/bin，进入# 启动。默认加载conf中的nginx.conf配置文件./nginx 或 ./nginx -s start# 热启动(不down机更新配置)./nginx -s reload# 关闭./nginx -s stop# 修改*.conf配置文件后，检查语法是否正常nginx -t# http默认端口80# https默认端口443 目录结构123456# nginx目录下confg/ # 配置文件目录logs/ # 日志目录html/ # 网站文件目录sbin/ # 命令目录conf.d/ # 有些安装完成之后会有这个目录，也是配置目录。nginx启动时会优先去加载config/nginx.conf，如果没有，加载该目录中的配置。 nginx.conf配置使用mac的brew安装，目录在/usr/local/etc/nginx 1234567891011121314151617181920212223mainevents &#123; ....&#125;http &#123; .... upstream myproject &#123; ..... &#125; server &#123; .... location &#123; .... &#125; &#125; server &#123; .... location &#123; .... &#125; &#125; ....&#125; nginx配置文件主要分为六个区域：main(全局设置)、events(nginx工作模式)、http(http设置)、sever(主机设置)、location(URL匹配)、upstream(负载均衡服务器设置)。 main模块main是全局配置： 12345678user nobody nobody;worker_processes auto;# 根据情况自己制定日志目录error_log /usr/local/var/nginx/error.log notice;pid /usr/local/var/nginx/nginx.pid;worker_rlimit_nofile 100000; user 来指定Nginx Worker进程运行用户以及用户组，默认由nobody账号运行。 worker_processes来指定了Nginx要开启的子进程数。每个Nginx进程平均耗费10M~12M内存。最优值取决于许多因素，包括（但不限于）CPU核的数量、存储数据的硬盘数量及负载模式。不能确定的时候，将其设置为可用的CPU内核数将是一个好的开始（设置为“auto”将尝试自动检测它）。该值设置的是子进程worker数量，同时还有一个主进程master，比如设置值为2时，总共有3个进程。 error_log用来定义全局错误日志文件。日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少。 pid用来指定进程id的存储文件位置。 worker_rlimit_nofile用于指定一个nginx进程可以打开的最多文件描述符数目，受限于操作系统的配置。如果你的nginx报错“too many open files”，就是操作系统的值比你设置的值小。可以通过ulimit -n查看操作系统的值。通过ulimit -n 65535修改，该命令将操作系统修改为65535。 events模块events模块来用指定nginx的工作模式和工作模式及连接数上限： 1234events &#123; use kqueue; #mac平台 worker_connections 1024;&#125; use用来指定Nginx的工作模式。Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在Linux平台上，而kqueue用在BSD系统中，因为Mac基于BSD,所以Mac也得用这个模式，对于Linux系统，epoll工作模式是首选。 worker_connections用于定义Nginx每个进程的最大连接数，即接收前端的最大请求数，默认是1024。最大客户端连接数由worker_processes和worker_connections决定,即Max_clients=worker_processes*worker_connections。在作为反向代理时，Max_clients变为：Max_clients = worker_processes * worker_connections/4。（关于max_clients值的计算，官方文档也没有给出明确公式，网上说法也不一。可以看下这个，我觉得还挺靠谱：Max_clients计算公式）进程的最大连接数受Linux系统进程的最大打开文件数限制（每个TCP连接都要创建一个socket句柄，每个socket句柄同时也是一个文件句柄），只有操作系统中的ulimit -n的值比worker_connections的值大，该设置才有效。 http模块http模块是最核心的模块，它负责HTTP服务器相关属性的配置，主要包含server和upstream子模块。 12345678910111213141516http&#123; include mime.types; default_type application/octet-stream; log_format myFormat &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /usr/local/var/nginx/access.log myFormat; server_tokens on; sendfile on; tcp_nopush on; tcp_nodelay on; ······&#125; include 可以用来加载其他配置文件，如include /etc/nginx/conf.d/*.conf。上例中用来引入设定文件的mime类型，类型在配置文件目录下的mime.type文件定义，来告诉nginx来识别文件类型。 default_type默认文件类型，当文件类型未定义时使用该值，值默认为text/plain。通常修改为application/octet-stream，使用二进制流的方式解析。 log_format设置日志的格式，myFormat相当于别名，配合access_log使用。 access_log 访问日志存放目录。nginx调优时可以关闭该功能，提高磁盘IO读写速度。 server_tokens 对于性能没有优化，当访问失败时，可以隐藏nginx版本信息。 sendfile 可以使用sendfile()，使文件传输更高效。传输文件涉及到将内容从磁盘读取，写到Tcp连接的过程。该项关闭时的流程是，Pre-sendfile是传送数据之前在用户空间申请数据缓冲区。之后用read()将数据从文件拷贝到内核读取缓冲区，再从内核读取缓冲区读到用户缓冲区，write()将用户缓冲区数据写到内核Socket缓冲区，再写入网络协议引擎，进行传输。sendfile()可以在任意两个文件描述符之间互相拷贝数据，而sendfile()是可以立即将数据从磁盘读，经OS缓存，写入TCP socket，不经过用户缓冲区。因为这种拷贝是在内核完成的（避免了内核缓冲区和用户缓冲区之间的数据拷贝），sendfile()要比组合read()和write()以及打开关闭丢弃缓冲更加有效。 tcp_nopush 告诉nginx在一个数据包里发送所有头文件，而不一个接一个的发送。 tcp_nodelay 告诉nginx不要缓存数据，而是一段一段的发送。当需要及时发送数据时，就应该给应用设置这个属性，这样发送一小块数据信息时就不能立即得到返回值。tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞。 12345678910111213141516http&#123; ······ keepalive_timeout 10; client_header_timeout 10; client_body_timeout 10; reset_timedout_connection on; send_timeout 10; limit_conn_zone $binary_remote_addr zone=addr:5m; limit_conn addr 100; ······&#125; keepalive_timeout设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接。 client_header_timeout 请求头超时时间。 client_body_timeout 请求体超时时间。 reset_timeout_connection 关闭不响应的客户端连接。这将会释放那个客户端所占有的内存空间。 send_timeout 指定客户端的响应超时时间。这个设置不会用于整个转发器，而是在两次客户端读取操作之间。如果在这段时间内，客户端没有读取任何数据，nginx就会关闭连接。 limit_conn_zone 设置addr连接的共享内存为5m。$binary_remote_addr的长度为 4 bytes，会话信息的长度为 32 bytes，5m大约可以记录5*1k*32 个会话信息（一个会话占用 32 bytes。如果一个会话占用64bytes，可保存5*1k*16个会话）。 limit_conn 设置addr的最大连接数为100，每个ip最多同时开100个连接。 12345678910111213141516http&#123; ······ # gzip配置，可根据情况关闭 gzip on; gzip_disable &quot;msie6&quot;; # gzip_static on; gzip_proxied any; gzip_min_length 1000; gzip_comp_level 4; gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript; ······&#125; gzip 采用gzip压缩的形式发送数据。可以减少发送的数据量。 gzip_disable为指定的客户端禁用gzip功能。我们设置成IE6或者更低版本以使我们的方案能够广泛兼容。 gzip_static告诉nginx在压缩资源之前，先查找是否有预先gzip处理过的资源。这要求你预先压缩你的文件（在这个例子中被注释掉了），从而允许你使用最高压缩比，这样nginx就不用再压缩这些文件了（想要更详尽的gzip_static的信息，请点击这里）。 gzip_proxied允许或者禁止压缩基于请求和响应的响应流。我们设置为any，意味着将会压缩所有的请求。 gzip_min_length设置对数据启用压缩的最少字节数。如果一个请求小于1000字节，我们最好不要压缩它，因为压缩这些小的数据会降低处理此请求的所有进程的速度。 gzip_comp_level设置数据的压缩等级。这个等级可以是1-9之间的任意数值，9是最慢但是压缩比最大的。我们设置为4，这是一个比较折中的设置。 gzip_types设置需要压缩的数据格式。 1234567891011http&#123; ······ # 文件配置，可根据情况配置，现在好多都不配置了，仅当了解吧 open_file_cache max=100000 inactive=20s; open_file_cache_valid 30s; open_file_cache_min_uses 2; open_file_cache_errors on; ······&#125; open_file_cache打开缓存的同时也指定了缓存最大数目，以及缓存的时间。我们可以设置一个相对高的最大时间，这样我们可以在它们不活动超过20秒后清除掉。 open_file_cache_valid 在open_file_cache中指定检测正确信息的间隔时间。 open_file_cache_min_uses 定义了open_file_cache中指令参数不活动时间期间里最小的文件数。 open_file_cache_errors指定了当搜索一个文件时是否缓存错误信息，也包括再次给配置中添加文件。我们也包括了服务器模块，这些是在不同文件中定义的。如果你的服务器模块不在这些位置，你就得修改这一行来指定正确的位置。 server模块server模块是http的子模块，用来定义虚拟主机的配置。一个http中可以有多个server。 1234567891011server &#123; listen 8080; server_name localhost 127.0.0.1 www.xxx.com; # 全局定义，如果都是这一个目录，这样定义最简单。 root /Users/xxx/www; index index.php index.html index.htm; charset utf-8; access_log usr/local/var/host.access.log main; aerror_log usr/local/var/host.error.log error; ....&#125; listen用于指定虚拟主机的服务端口。server_name用来指定IP地址或者域名，多个域名之间用空格分开。root 表示在这整个server虚拟主机内，全部的root web根目录。注意要和locate &#123;&#125;下面定义的区分开来。index 全局定义访问的默认首页地址。注意要和locate &#123;&#125;下面定义的区分开来。charset用于设置网页的默认编码格式。access_log用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式。 location模块nginx中最核心的模块，用来配置请求的路由，以及各种页面的处理情况。支持正则表达式、条件判断，同时可以设置负载均衡、反向代理、虚拟域名等。 匹配规则location的url匹配具有一定优先级，其优先级如下： 123456789location [ = | ~ | ~* | ^~ ] uri &#123; &#125;# =开头表示精确匹配# ^~ 开头表示uri以某个常规字符串开头，这个不是正则表达式# ~ 开头表示区分大小写的正则匹配;# ~* 开头表示不区分大小写的正则匹配# / 通用匹配, 如果没有其它匹配,任何请求都会匹配到# 优先级(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~* 正则顺序) &gt; (location 部分起始路径) &gt; (/) 语法语法方面，主要有： 123456location /static &#123; root /var/app/www; # alias /var/app/www; index index.php index.html index.htm; proxy_pass http://127.0.0.1:8080/;&#125; root 用于指定当访问/static目录时，所对应的主机对应的目录，为/var/app/www/static。 alias 与root类似，但是区别在于当访问/static时，对应的路径为/var/app/www。 index 默认首页，按先后顺序依次查找。 try files 至少两个参数，按照顺序进行访问尝试，最后一个参数最好配置为静态页面，防止死循环。 rewite 将一个url重写成另一个url。 proxy_pass 反向代理配置，代理请求。其具体用法： 123456789101112131415161718192021# 当访问http://127.0.0.1/proxy/1.png时# 代理到http://127.0.0.2/1.pnglocation /proxy/ &#123; proxy_pass http://127.0.0.2/;&#125;# 代理到http://127.0.0.2/proxy/1.pnglocation /proxy/ &#123; proxy_pass http://127.0.0.2;&#125;# 代理到http://127.0.0.2/img/1.pnglocation /proxy/ &#123; proxy_pass http://127.0.0.2/img/;&#125;# 代理到http://127.0.0.2/img1.pnglocation /proxy/ &#123; proxy_pass http://127.0.0.2/img;&#125; upstream模块upstream模块负责负载均衡。 1234567upstream baidu.com&#123; ip_hash; # 负载算法 server xx:xx:xx:1:8080; # server列表 server xx:xx:xx:1:8080 down; server xx:xx:xx:1:8080 max_fails=3 fail_timeout=20s; server xx:xx:xx:1:8080;&#125; 5种负载算法： 轮询(默认) 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，则自动剔除故障机器，使用户访问不受影响。 weight 指定轮询权重，weight值越大，分配到的几率就越高，主要用于后端每台服务器性能不均衡的情况。 ip_hash 每个请求按访问IP的哈希结果分配，这样每个访客固定访问一个后端服务器，可以有效的解决动态网页存在的session共享问题。 fair(第三方) 更智能的一个负载均衡算法，此算法可以根据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。如果想要使用此调度算法，需要Nginx的upstream_fair模块。 url_hash(第三方) 按访问URL的哈希结果来分配请求，使每个URL定向到同一台后端服务器，可以进一步提高后端缓存服务器的效率。如果想要使用此调度算法，需要Nginx的hash软件包。 另外，每台server还可以设置不同的负载状态： down 表示当前server暂时不参与负载均衡。 backup 预留的备份机，当其他所有非backup机器出现故障或者繁忙的时候，才会请求backup机器，这台机器的访问压力最轻。 max_fails 允许请求的失败次数，默认为1，配合fail_timeout一起使用。 fail_timeout 经历max_fails次失败后，暂停服务的时间，默认为10s（某个server连接失败了max_fails次，则nginx会认为该server不工作了。同时，在接下来的 fail_timeout时间内，nginx不再将请求分发给失效的server）。 当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184########### 每个指令必须有分号结束。##################配置用户或者组，默认为nobody nobody。#user administrator administrators; #允许生成的进程数，默认为1#worker_processes 2; #指定nginx进程运行文件存放地址#pid /nginx/pid/nginx.pid; #制定错误日志路径，级别。这个设置可以放入全局块，http块，server块，级别依次为：debug|info|notice|warn|error|crit|alert|emergerror_log log/error.log debug; #工作模式及连接数上限events &#123; #设置网路连接序列化，防止惊群现象发生，默认为on accept_mutex on; #设置一个进程是否同时接受多个网络连接，默认为off multi_accept on; #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport #use epoll; #单个work进程允许的最大连接数，默认为512 worker_connections 1024; &#125;#http服务器http &#123; #文件扩展名与文件类型映射表。设定mime类型(邮件支持类型),类型由mime.types文件定义 #include /usr/local/etc/nginx/conf/mime.types; include mime.types; #默认文件类型，默认为text/plain default_type application/octet-stream; #取消服务访问日志 #access_log off; #自定义日志格式 log_format myFormat &#x27;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#x27;; #设置访问日志路径和格式。&quot;log/&quot;该路径为nginx日志的相对路径，mac下是/usr/local/var/log/。combined为日志格式的默认值 access_log log/access.log myFormat; rewrite_log on; #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。（sendfile系统调用不需要将数据拷贝或者映射到应用程序地址空间中去） sendfile on; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。 sendfile_max_chunk 100k; #连接超时时间，默认为75s，可以在http，server，location块。 keepalive_timeout 65; #gzip压缩开关 #gzip on; tcp_nodelay on; #设定实际的服务器列表 upstream mysvr1 &#123; server 127.0.0.1:7878; server 192.168.10.121:3333 backup; #热备(其它所有的非backup机器down或者忙的时候，请求backup机器)) &#125; upstream mysvr2 &#123; #weigth参数表示权值，权值越高被分配到的几率越大 server 192.168.1.11:80 weight=5; server 192.168.1.12:80 weight=1; server 192.168.1.13:80 weight=6; &#125; upstream https-svr &#123; #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题 ip_hash; server 192.168.1.11:90; server 192.168.1.12:90; &#125; #error_page 404 https://www.baidu.com; #错误页 #HTTP服务器 #静态资源一般放在nginx所在主机 server &#123; listen 80; #监听HTTP端口 server_name 127.0.0.1; #监听地址 keepalive_requests 120; #单连接请求上限次数 set $doc_root_dir &quot;/Users/doing/IdeaProjects/edu-front-2.0&quot;; #设置server里全局变量 #index index.html; #定义首页索引文件的名称 location ~*^.+$ &#123; #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。 root $doc_root_dir; #静态资源根目录 proxy_pass http://mysvr1; #请求转向“mysvr1”定义的服务器列表 #deny 127.0.0.1; #拒绝的ip #allow 172.18.5.54; #允许的ip &#125; &#125; #http server &#123; listen 80; server_name www.helloworld.com; #监听基于域名的虚拟主机。可有多个，可以使用正则表达式和通配符 charset utf-8; #编码格式 set $static_root_dir &quot;/Users/doing/static&quot;; location /app1 &#123; #反向代理的路径（和upstream绑定），location后面设置映射的路径 proxy_pass http://zp_server1; &#125; location /app2 &#123; proxy_pass http://zp_server2; &#125; location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; #静态文件，nginx自己处理 root $static_root_dir; expires 30d; #静态资源过时间30天 &#125; location ~ /\\.ht &#123; #禁止访问 .htxxx 文件 deny all; &#125; location = /do_not_delete.html &#123; #直接简单粗暴的返回状态码及内容文本 return 200 &quot;hello.&quot;; &#125; #指定某些路径使用https访问(使用正则表达式匹配路径+重写uri路径) location ~* /http* &#123; #路径匹配规则：如localhost/http、localhost/httpsss等等 #rewrite只能对域名后边的除去传递的参数外的字符串起作用，例如www.c.com/proxy/html/api/msg?method=1&amp;para=2只能对/proxy/html/api/msg重写。 #rewrite 规则 定向路径 重写类型; #rewrite后面的参数是一个简单的正则。$1代表正则中的第一个()。 #$host是nginx内置全局变量，代表请求的主机名 #重写规则permanent表示返回301永久重定向 rewrite ^/(.*)$ https://$host/$1 permanent; &#125; #错误处理页面（可选择性配置） #error_page 404 /404.html; #error_page 500 502 503 504 /50x.html; #以下是一些反向代理的配置(可选择性配置) #proxy_redirect off; #proxy_set_header Host $host; #proxy_set_header用于设置发送到后端服务器的request的请求头 #proxy_set_header X-Real-IP $remote_addr; #proxy_set_header X-Forwarded-For $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP #proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) #proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) #proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) #proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 #proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置 #proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） #proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 #client_max_body_size 10m; #允许客户端请求的最大单文件字节数 #client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数 &#125; #https #(1)HTTPS的固定端口号是443，不同于HTTP的80端口； #(2)SSL标准需要引入安全证书，所以在 nginx.conf 中你需要指定证书和它对应的 key server &#123; listen 443; server_name www.hellohttps1.com www.hellohttps2.com; set $geek_web_root &quot;/Users/doing/IdeaProjects/backend-geek-web&quot;; ssl_certificate /usr/local/etc/nginx/ssl-key/ssl.crt; #ssl证书文件位置(常见证书文件格式为：crt/pem) ssl_certificate_key /usr/local/etc/nginx/ssl-key/ssl.key; #ssl证书key位置 location /passport &#123; send_timeout 90; proxy_connect_timeout 50; proxy_send_timeout 90; proxy_read_timeout 90; proxy_pass http://https-svr; &#125; location ~ ^/(res|lib)/ &#123; root $geek_web_root; expires 7d; #add_header用于为后端服务器返回的response添加请求头，这里通过add_header实现CROS跨域请求服务器 add_header Access-Control-Allow-Origin *; &#125; #ssl配置参数（选择性配置） ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; &#125; #配置访问控制：每个IP一秒钟只处理一个请求，超出的请求会被delayed #语法：limit_req_zone $session_variable zone=name:size rate=rate (为session会话状态分配一个大小为size的内存存储区，限制了每秒（分、小时）只接受rate个IP的频率) limit_req_zone $binary_remote_addr zone=req_one:10m rate=1r/s nodelay; location /pay &#123; proxy_set_header Host $http_host; proxy_set_header X-Real_IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #访问控制：limit_req zone=name [burst=number] [nodelay]; limit_req zone=req_one burst=5; #burst=5表示超出的请求(被delayed)如果超过5个，那些请求会被终止（默认返回503） proxy_pass http://mysvr1; &#125; #可以把子配置文件放到/usr/local/etc/nginx/servers/路径下，通过include引入 include /usr/local/etc/nginx/servers/*.conf;&#125; 内置全局变量123456789101112131415161718192021$args ：这个变量等于请求行中的参数，同$query_string$content_length ： 请求头中的Content-length字段。$content_type ： 请求头中的Content-Type字段。$document_root ： 当前请求在root指令中指定的值。$host ： 请求主机头字段，否则为服务器名称。$http_user_agent ： 客户端agent信息$http_cookie ： 客户端cookie信息$limit_rate ： 这个变量可以限制连接速率。$request_method ： 客户端请求的动作，通常为GET或POST。$remote_addr ： 客户端的IP地址。$remote_port ： 客户端的端口。$remote_user ： 已经经过Auth Basic Module验证的用户名。$request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成。$scheme ： HTTP方法（如http，https）。$server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。$server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。$server_name ： 服务器名称。$server_port ： 请求到达服务器的端口号。$request_uri ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。$uri ： 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。$document_uri ： 与$uri相同。","categories":[{"name":"中间件","slug":"中间件","permalink":"https://wonius.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://wonius.github.io/tags/nginx/"}]},{"title":"通过K8S传参创建Job","slug":"K8S","date":"2019-07-25T12:03:58.000Z","updated":"2019-07-25T12:21:46.000Z","comments":true,"path":"2019/07/25/K8S/","link":"","permalink":"https://wonius.github.io/2019/07/25/K8S/","excerpt":"","text":"打包镜像编写Dockerfile 1234...# 我的镜像是python项目，需要传参进去，设置环境变量PARAMSENTRYPOINT python main.py -p $PARAMS 然后打包镜像 编写yaml我要跑的job是一个TensorFlow训练服务，只想跑在GPU的机子上，同时避免为了其他服务跑到GPU上 所以在GPU机子上打了标签、污点 在Job里需要选择标签、容忍 123456789101112131415161718192021222324252627282930313233apiVersion: batch/v1kind: Jobmetadata: name: myJobspec: template: metadata: name: myJob spec: restartPolicy: OnFailure # 设置容忍 tolerations: - key: &quot;app&quot; operator: &quot;Equal&quot; value: &quot;GPU&quot; effect: &quot;NoSchedule&quot; containers: - name: myJob # 设置环境变量，传值 env: - name: PARAMS value: &quot;&quot; # 镜像地址 image: hub.xxxxx/ volumeMounts: - name: nas mountPath: /nas volumes: - name: nas hostPath: path: /nas nodeSelector: app: &quot;GPU&quot; 然后运行该yaml kubectl apply -f myJob.yaml","categories":[{"name":"K8S","slug":"K8S","permalink":"https://wonius.github.io/categories/K8S/"}],"tags":[{"name":"K8S","slug":"K8S","permalink":"https://wonius.github.io/tags/K8S/"}]},{"title":"GPU安装Docker环境","slug":"GPU安装Docker环境","date":"2019-06-27T12:41:56.000Z","updated":"2020-11-03T13:50:38.000Z","comments":true,"path":"2019/06/27/GPU安装Docker环境/","link":"","permalink":"https://wonius.github.io/2019/06/27/GPU%E5%AE%89%E8%A3%85Docker%E7%8E%AF%E5%A2%83/","excerpt":"","text":"nvidia驱动、cuda、cudnn、TensorFlow版本对应关系cuda、cudnn、docker、nvidia-docker版本一定看是否兼容。不同版本有兼容问题。 nvidia驱动、cuda对应关系 https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html cuda、cudnn对应关系 https://developer.nvidia.com/rdp/cudnn-archive TensorFlow、cuda、cudnn、python对应关系 https://tensorflow.google.cn/install/source#linux 升级驱动（非必须）如果已经安装低版本的驱动，需要升级，需要将所有使用nvidia的程序暂停（一般只有docker），再卸载。 123456789101112131415# 先暂停dockerservice docker stop# 查看有哪些nvidia模块，依次卸载lsmod | grep nvidiarmmod nvidia-*rmmod nvidia# 安装nvidia-docker时，安装了一些与nvidia相关的包，一起卸载rpm -qa | grep nvidiarpm -e --nodeps *-nvidia-*# 然后安装nvidia驱动、nvidia-docker# 查看驱动版本nvidia-smi 安装Python31234567891011mkdir -p /usr/local/python3tar -zxvf Python-3.6.6.tgzcd Python-3.6.6./configure --prefix=/usr/local/python3make &amp;&amp; make installln -s /usr/local/python3/bin/python3 /usr/bin/python3vim ~/.bash_profile# 加入export PATH=$PATH:$HOME/bin:/usr/local/python3/bin# 验证python3 -V 安装pip312345tar -zxvf pip-9.0.1.tgzcd pip-9.0.1python3 setup.py installln -s /usr/local/bin/pip /usr/bin/pip3pip3 -V 安装cuda12345678910111213141516# rpm安装wget http://mirrors.*******/cuda-repo-rhel7-9-0-local-9.0.176-1.x86_64.rpmrpm -ivh cuda-repo-*.rpmyum clean expire-cacheyum install -y cuda# 设置环境变量vim ~/.bashrcexport LD_LIBRARY_PATH=/usr/local/cuda/lib64:/usr/local/cuda/extras/CUPTI/lib64:$LD_LIBRARY_PATHexport CUDA_HOME=/usr/local/cudaexport PATH=/usr/local/cuda/bin:$PATHsource ~/.bashrc# 验证是否成功：cat /usr/local/cuda/version.txt 或 nvcc --version 安装cudnn直接将cudnn中相关文件，拷贝到cuda对应目录即可 123456789101112131415161718192021tar -xvf cudnn-8.0-linux-x64-v6.0.tgz# 进入cudacd /usr/local/cuda# 拷贝cudnn相关文件cp /xxx/cuda/include/cudnn.h include/cp /xxx/cuda/lib64/libcudnn* lib64/chmod a+r include/cudnn.hchmod a+r lib64/libcudnn*# 设置环境变量vim ~/.bashrcexport LD_LIBRARY_PATH=/usr/local/cuda/lib64:/usr/local/cuda/extras/CUPTI/lib64:$LD_LIBRARY_PATHexport CUDA_HOME=/usr/local/cudaexport PATH=/usr/local/cuda/bin:$PATHsource ~/.bashrc# 验证cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2# 查看so版本对不对ldconfig -v | grep cudnn / 升级docker到18123456789101112131415161718# 卸载原来docker# rpm安装，直接removeyum remove docker# 如果是二进制文件拷贝，需要手动删除cd /usr/local/binrm -rf docker*# 安装docker18rpm -ivh containerd.io-1.2.2-3.el7.x86_64.rpmrpm -ivh container-selinux-2.74-1.el7.noarch.rpmrpm -ivh docker-ce-cli-18.09.5-3.el7.x86_64.rpmrpm -ivh docker-ce-18.09.5-3.el7.x86_64.rpm# 默认是安装在/usr/bin目录下，根据个人需要看是否需要拷贝到/usr/local/bincd /usr/bincp docker* /usr/local/binsystemctl status docker.servicedocker --version 安装nvidia-docker12345678910111213141516171819202122232425rpm -ivh libnvidia-container1-1.0.2-1.x86_64.rpmrpm -ivh libnvidia-container-tools-1.0.2-1.x86_64.rpmrpm -ivh nvidia-container-runtime-hook-1.4.0-2.x86_64.rpmrpm -ivh nvidia-container-runtime-2.0.0-3.docker18.09.5.x86_64.rpmrpm -ivh nvidia-docker2-2.0.3-3.docker18.09.5.ce.noarch.rpm# 查看版本nvidia-docker --version# 另外修改daemon.json，使用docker run的时候默认使用nvidia-dockervim /etc/docker/daemon.json&#123; &quot;default-runtime&quot;: &quot;nvidia&quot;, &quot;runtimes&quot;: &#123; &quot;nvidia&quot;: &#123; &quot;path&quot;: &quot;/usr/bin/nvidia-container-runtime&quot;, &quot;runtimeArgs&quot;: [] &#125; &#125;&#125;# 安装完成之后，重启docker、nvidia-dockersystemctl daemon-reloadsystemctl enable dockersystemctl restart docker","categories":[{"name":"Docker","slug":"Docker","permalink":"https://wonius.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://wonius.github.io/tags/Docker/"}]},{"title":"Maven的那些事儿","slug":"Maven生命周期","date":"2018-10-22T08:06:33.000Z","updated":"2020-03-25T03:25:14.000Z","comments":true,"path":"2018/10/22/Maven生命周期/","link":"","permalink":"https://wonius.github.io/2018/10/22/Maven%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"lifecycle、phase、goal lifecycle由phase组成，phase由goal组成。phase可以看成小的生命周期，goal是最小的任务执行单元； lifecycle总共有三个阶段，clean、default、site；每个阶段对应不同phase； 一个phase中可以有多个goal； lifecycleclean phase function pre-clean execute processes needed prior to the actual project cleaning clean remove all files generated by the previous build Post-clean execute processes needed to finalize the project cleaning default phase function validate validate the project is correct and all necessary information is available. initialize initialize build state, e.g. set properties or create directories. generate-sources generate any source code for inclusion in compilation. process-sources process the source code, for example to filter any values. generate-resources generate resources for inclusion in the package. process-resources copy and process the resources into the destination directory, ready for packaging. compile compile the source code of the project. process-classes post-process the generated files from compilation, for example to do bytecode enhancement on Java classes. generate-test-sources generate any test source code for inclusion in compilation. process-test-sources process the test source code, for example to filter any values. generate-test-resources create resources for testing. process-test-resources copy and process the resources into the test destination directory. test-compile compile the test source code into the test destination directory process-test-classes post-process the generated files from test compilation, for example to do bytecode enhancement on Java classes. For Maven 2.0.5 and above. test run tests using a suitable unit testing framework. These tests should not require the code be packaged or deployed. prepare-package perform any operations necessary to prepare a package before the actual packaging. This often results in an unpacked, processed version of the package. (Maven 2.1 and above) package take the compiled code and package it in its distributable format, such as a JAR. pre-integration-test perform actions required before integration tests are executed. This may involve things such as setting up the required environment. integration-test process and deploy the package if necessary into an environment where integration tests can be run. post-integration-test perform actions required after integration tests have been executed. This may including cleaning up the environment. verify run any checks to verify the package is valid and meets quality criteria. install install the package into the local repository, for use as a dependency in other projects locally. deploy done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects. site phase function pre-site execute processes needed prior to the actual project site generation site generate the project’s site documentation post-site execute processes needed to finalize the site generation, and to prepare for site deployment site-deploy deploy the generated site documentation to the specified web server https://www.jianshu.com/p/fd43b3d0fdb0 插件执行顺序 同一pom，按照插件配置的顺序执行； 超级pom与自定义pom，同一phase，超级pom先执行；","categories":[{"name":"Backend","slug":"Backend","permalink":"https://wonius.github.io/categories/Backend/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://wonius.github.io/tags/Maven/"}]},{"title":"文件MD5批量生成","slug":"Linux文件MD5生成","date":"2018-10-18T08:46:14.000Z","updated":"2020-11-03T13:55:14.000Z","comments":true,"path":"2018/10/18/Linux文件MD5生成/","link":"","permalink":"https://wonius.github.io/2018/10/18/Linux%E6%96%87%E4%BB%B6MD5%E7%94%9F%E6%88%90/","excerpt":"","text":"1find ./ -type f | xargs md5sum &gt; a.md5","categories":[{"name":"Linux","slug":"Linux","permalink":"https://wonius.github.io/categories/Linux/"}],"tags":[{"name":"MD5","slug":"MD5","permalink":"https://wonius.github.io/tags/MD5/"}]},{"title":"Dockerfile与Maven参数间的那点事儿","slug":"Dockerfile与Maven参数间的那点事儿","date":"2018-09-28T03:07:34.000Z","updated":"2020-11-03T13:48:59.000Z","comments":true,"path":"2018/09/28/Dockerfile与Maven参数间的那点事儿/","link":"","permalink":"https://wonius.github.io/2018/09/28/Dockerfile%E4%B8%8EMaven%E5%8F%82%E6%95%B0%E9%97%B4%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/","excerpt":"","text":"Maven设置Dockerfile参数项目中需要根据不同环境，镜像里tomct中catalina.sh里某个参数值也要不同。 项目中用了docker-maven-plugin插件管理docker，所以想到通过maven参数进行设置。 pom配置123456789101112131415161718192021222324# 在docker-maven-plugin插件中增加配置&lt;plugin&gt; ... &lt;configuration&gt; ... &lt;buildArgs&gt; # 标签名为key，标签值为value &lt;APP_NAME&gt;$&#123;appName&#125;&lt;/APP_NAME&gt; &lt;/buildArgs&gt; ... &lt;/configuration&gt; ...&lt;/plugin&gt;# 环境配置&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;ci&lt;/id&gt; &lt;properties&gt; &lt;appName&gt;hello-ci&lt;/appName&gt; &lt;/properties&gt; &lt;/profile&gt; ...&lt;/profiles&gt; dockerfile配置12345...# 定义参数ARG APP_NAME# 增加CATALINA的环境变量ENV CATALINA_OPTS -DapplicationName=$APP_NAME one more thing除了用docker插件，还可以是用exec插件，运行shell脚本或java文件，这种方式更自由一点。","categories":[{"name":"Docker","slug":"Docker","permalink":"https://wonius.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://wonius.github.io/tags/Docker/"}]},{"title":"Dockerfile记录","slug":"Dockerfile记录","date":"2018-09-21T04:04:05.000Z","updated":"2020-11-03T13:48:36.000Z","comments":true,"path":"2018/09/21/Dockerfile记录/","link":"","permalink":"https://wonius.github.io/2018/09/21/Dockerfile%E8%AE%B0%E5%BD%95/","excerpt":"","text":"dockerfile1123456789101112131415161718FROM hub.yun.paic.com.cn/library/tomcat:8.5-jre8ENV USER_NAME woniuENV USER_UID 789ENV ADMIN_NAME adminENV USER_GROUP_ID 5682ENV ADMIN_GROUP_ID 603RUN groupadd -g $USER_GROUP_ID $USER_NAME &amp;&amp; groupadd -g $ADMIN_GROUP_ID -u $ADMIN_NAME \\&amp;&amp; useradd -l -r $USER_NAME -g $USER_NAME -u $USER_UID \\&amp;&amp; usermod -a -G $ADMIN_NAME $USER_NAME \\&amp;&amp; mkdir /usr/local/tomcat/hello &amp;&amp; chown -R $USER_NAME:$USER_NAME /usr/local/tomcatCOPY catalina.sh /usr/local/tomcat/bin/catalina.shRUN chown $USER_NAME:$USER_NAME /usr/local/tomcat/bin/catalina.shRUN chmod 750 /usr/local/tomcat/bin/catalina.shUSER $USER_NAME dockerfile2该dockerfile基于上一个，由于上一个dockerfile最后切换到用户woniu，没有mkdir权限，所以需要先切换到root用户。 123456789101112FROM hub.yun.paic.com.cn/library/tomcat:1.0USER rootRUN mkdir -p /wls/wls81/agentCOPY agent /wls/wls81/agentRUN chown -R $USER_NAME:$USER_NAME /wls/wls81COPY catalina.sh /usr/local/tomcat/bin/catalina.shRUN chown $USER_NAME:$USER_NAME /usr/local/tomcat/bin/catalina.shRUN chmod 750 /usr/local/tomcat/bin/catalina.shUSER $USER_NAME","categories":[{"name":"Docker","slug":"Docker","permalink":"https://wonius.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://wonius.github.io/tags/Docker/"}]},{"title":"iTerm主题配色","slug":"iTerm主题配色","date":"2018-09-19T12:21:23.000Z","updated":"2018-09-19T12:31:54.000Z","comments":true,"path":"2018/09/19/iTerm主题配色/","link":"","permalink":"https://wonius.github.io/2018/09/19/iTerm%E4%B8%BB%E9%A2%98%E9%85%8D%E8%89%B2/","excerpt":"","text":"效果图 配置链接:https://pan.baidu.com/s/1w64NLBLIyFnMRl4L5qaIJA 密码:c54h","categories":[{"name":"工具","slug":"工具","permalink":"https://wonius.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"iTerm","slug":"iTerm","permalink":"https://wonius.github.io/tags/iTerm/"}]},{"title":"GDD China 2018","slug":"GDD2018","date":"2018-09-19T12:10:14.000Z","updated":"2018-10-01T02:55:45.000Z","comments":true,"path":"2018/09/19/GDD2018/","link":"","permalink":"https://wonius.github.io/2018/09/19/GDD2018/","excerpt":"","text":"活动链接https://www.google.cn/intl/zh-CN/events/developerdays2018/ 后记​ 参加过GDD2017，这次感受不太一样。无论规模、人数较去年翻了几倍。光排队差不多花了30分钟。今年主推还是TensorFlow，Flutter宣传力度也比较大。2F设了体验区，因为去年参加过所以没怎么体验。","categories":[{"name":"活动","slug":"活动","permalink":"https://wonius.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[{"name":"GDD","slug":"GDD","permalink":"https://wonius.github.io/tags/GDD/"}]},{"title":"养犬有道の准备篇","slug":"柴犬回家前的准备","date":"2018-09-12T12:13:25.000Z","updated":"2018-09-14T07:25:19.000Z","comments":true,"path":"2018/09/12/柴犬回家前的准备/","link":"","permalink":"https://wonius.github.io/2018/09/12/%E6%9F%B4%E7%8A%AC%E5%9B%9E%E5%AE%B6%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87/","excerpt":"","text":"住的打扫卫生，消毒：家里的卫生要收拾下，消下毒。毕竟小狗抵抗力低 围栏、笼子：根据个人需要选择。如果家里一直有人，狗子经常放在外面，可以笼子也可以围栏。如果白天上班家里没人，必须把狗狗关着，推荐围栏，活动空间大些。有朋友围栏也不固定，狗子长大后带着围栏走，就是一座移动堡垒~ 狗窝、垫子：也看情况。夏天狗子更喜欢趴地板、睡地板，买回家他也不睡，只会在上面撒尿，所以不用那么着急。天气转凉的时候可以看情况买，其实我觉得买一个就够了。另外还有一种宠物用行军床，住在一楼，家里湿气重可以买，也比较透气。 吃的奶糕/幼犬粮：8个月之前尽量喂幼犬粮。 羊奶粉：3个月之前在狗粮里加羊奶粉。 营养品：营养膏、美毛膏、爆毛粉、钙片、卵磷脂、微量元素片等，这些都没必要买，只要是还可以的狗粮，各方面营养都是足够的。有异食癖再吃微量元素；卵磷脂完全可以自己煮鸡蛋给他吃蛋黄。幼犬肠胃不好，尽量不要吃乱七八糟的东西。 益生菌：可以备一点，肠胃消化不好弄一些放在狗粮里。 零食：主要用于训练用，幼犬阶段千万不要给太多零食，以免把胃口养刁了，挑食。 用的食盆、水盆： 必备。 尿片： 在没学会外出憋尿、大小便之前，必须的。 撸毛梳子：比较出名的有富美内特，不过梳毛效果太好，撸多了会秃的。 驱虫：必备。 沐浴露：家里洗澡必备。 消毒液：必备，打扫卫生时用。 洗耳液：有耳螨再用。建议问下宠物医生有什么信得过牌子。 洁牙凝胶：建议换牙后再用。或者刷牙，这个方便一点。 项圈、胸背、牵引绳：必备。 玩的球：狗子都很喜欢玩球，尤其是小的。 漏食球：星际漏食球，推荐。 磨牙棒：鹿角，性价比超高。 布偶：一定要耐艹。 辅助的监视器：不在家的时候，或者晚上，一定很好奇小家伙在干嘛。用过两款，一款海康威视c6c，一款大方。推荐大方. 小米大方：性价比高，配置简单，视角广，转动响应快，红外清晰，断电重启不用重新设置网络，语音可以实时通信。缺点是视频存放只能靠tf卡、u盘，没有云存储；电源线比较短，1.8米；只能连5Ghz的网络。 海康c6c：海康威视是摄像头行业龙头，所以也买来体验了一把，真的…无力吐槽。每次断电都要重新设置网络，转动特别慢，红外不清晰，质感差，录像功能不知道为什么晚上没有录，语音是对讲机那种，录完再发，不是实时的。本来我先买的这款，没办法，退了，才买的小米大方，发现小米果然是不错…","categories":[{"name":"养犬有道","slug":"养犬有道","permalink":"https://wonius.github.io/categories/%E5%85%BB%E7%8A%AC%E6%9C%89%E9%81%93/"}],"tags":[{"name":"狗狗","slug":"狗狗","permalink":"https://wonius.github.io/tags/%E7%8B%97%E7%8B%97/"}]},{"title":"Json处理时需要注意的那些事儿","slug":"json","date":"2018-09-12T08:11:12.000Z","updated":"2020-11-03T13:53:55.000Z","comments":true,"path":"2018/09/12/json/","link":"","permalink":"https://wonius.github.io/2018/09/12/json/","excerpt":"","text":"@JsonIgnore12345678910111213@Datapublic class Student &#123; private String name; private String age; private String gender; …… @JsonIgnore public boolean isName() &#123; …… &#125;&#125; （忽略命名规范）上述代码在序列化、反序列化时，都会导致name属性被忽略。 除非在属性上添加@JsonProperty。","categories":[{"name":"积累","slug":"积累","permalink":"https://wonius.github.io/categories/%E7%A7%AF%E7%B4%AF/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"https://wonius.github.io/tags/JSON/"}]},{"title":"养犬有道の驱虫篇","slug":"柴犬驱虫","date":"2018-09-09T08:36:38.000Z","updated":"2018-09-09T08:38:08.000Z","comments":true,"path":"2018/09/09/柴犬驱虫/","link":"","permalink":"https://wonius.github.io/2018/09/09/%E6%9F%B4%E7%8A%AC%E9%A9%B1%E8%99%AB/","excerpt":"","text":"常用驱虫药主要分为内驱和外驱，每月一次。不同品牌的驱虫药时效不同，有的一个季度一次，有的一个月一次，根据说明书使用。 我目前的组合是福来恩+犬心保。主要狗子经常去草地，所以可能有蜱虫，福来恩可以驱蜱虫。 如果不经常去草地，可以直接用大宠爱。 另外有朋友的组合是夏天犬心宝，冬天拜宠清，偶尔穿插吃驱球虫的。 不要只用一种驱虫药，因为有些覆盖不到，可以穿插使用。","categories":[{"name":"养犬有道","slug":"养犬有道","permalink":"https://wonius.github.io/categories/%E5%85%BB%E7%8A%AC%E6%9C%89%E9%81%93/"}],"tags":[{"name":"狗狗","slug":"狗狗","permalink":"https://wonius.github.io/tags/%E7%8B%97%E7%8B%97/"}]},{"title":"养犬有道の禁忌食物篇","slug":"柴犬不能吃的的那些好吃的","date":"2018-09-09T08:06:37.000Z","updated":"2018-09-09T12:31:39.000Z","comments":true,"path":"2018/09/09/柴犬不能吃的的那些好吃的/","link":"","permalink":"https://wonius.github.io/2018/09/09/%E6%9F%B4%E7%8A%AC%E4%B8%8D%E8%83%BD%E5%90%83%E7%9A%84%E7%9A%84%E9%82%A3%E4%BA%9B%E5%A5%BD%E5%90%83%E7%9A%84/","excerpt":"","text":"禁忌食物 巧克力。有些犬食用后振奋不安，且巧克力中富含许多的糖分，对犬的安康有害无宜。 葱、洋葱等类食物。有些犬食入此类食物可致使细胞溶血，呈现尿血的表象。 肝脏。长时间食用可形成维生素A过量乃至中毒。 海鲜等易过敏的食物。 高糖、高脂肪、高盐分的食物。高脂肪、高糖食物易使犬发胖而诱发一系列疾病；过量的盐分，必然加剧肾脏的分泌的担负，影响肾脏安康，打破体液平衡，形成各种肌肤疾病。 牛奶。许多狗狗有乳糖不适应症，若是狗喝了牛奶后呈现放屁、腹泄、脱水或肌肤发炎等。 生鸡蛋。生蛋白富含一种卵白素的蛋白质，它会耗尽狗狗体内的维生素H，会致使肌肤病及背毛疑问。 肥肉。致使胰腺炎。 含酒精的饮料、热可可、咖啡、茶。 葡萄、梅子、李子、樱桃、枇杷、菠萝（生物碱和菠萝蛋白简单形成过敏，PH值过酸）、桃子、芒果、未成熟的西红柿等生的水果。 芹菜、香菜、甘薯、大麦、小麦、玉米（含蛋白酶按捺物）、带皮与发芽的马铃薯、油菜等蔬菜。 碎骨头。尤其是鸡鸭一类尖利的骨头，可能对狗狗肠胃造成损害。 冷藏的牛奶、冰淇淋和其它乳制品。特别是对发育未彻底的幼犬影响最大，一般几口冷牛奶就会形成幼犬腹泄，长时间如此会形成习气性腹泄，致使犬体衰弱，犬的肠胃不适应此类食物。 猪肉。猪肉内的脂肪球比其它肉类大，能够堵塞狗狗的微血管。防止猪制品，尤其是含硝酸钠的火腿。","categories":[{"name":"养犬有道","slug":"养犬有道","permalink":"https://wonius.github.io/categories/%E5%85%BB%E7%8A%AC%E6%9C%89%E9%81%93/"}],"tags":[{"name":"狗狗","slug":"狗狗","permalink":"https://wonius.github.io/tags/%E7%8B%97%E7%8B%97/"}]},{"title":"Solr演练","slug":"Solr演练","date":"2018-09-09T05:20:58.000Z","updated":"2020-11-03T14:03:52.000Z","comments":true,"path":"2018/09/09/Solr演练/","link":"","permalink":"https://wonius.github.io/2018/09/09/Solr%E6%BC%94%E7%BB%83/","excerpt":"","text":"下载 访问官网进行下载； 解压即可； 启动 进到solr目录，执行bin/solr start -e cloud，多节点运行； 分别提示创建几个节点、第一个节点端口、第二个节点端口，按enter默认就可以； 输入集合名称，这里我们可以设置为techproducts； 然后提示创建几个分片、创建几个副本，这些默认2就可以； 然后选择使用哪组配置文件，总共有_default、sample_techproducts_configs两个选项，我们选后者； 创建完成，可以通过localhost:8983进入solr管理页面，在cloud中查看集合的结构； 如果第一步时报错： 使用普通用户： ERROR: Logs directory /etc/solr-7.4.0/example/cloud/node1/solr/../logs is not writable. Exiting 或者 使用root用户： ERROR: Failed to start Solr using command: &quot;bin/solr&quot; start -cloud -p 8983 -s &quot;example/cloud/node1/solr&quot; Exception : org.apache.commons.exec.ExecuteException: Process exited with an error: 1 (Exit value: 1) 是因为用户访问权限不对，修改下权限就可以。我这里直接开了所有权限 1sudo chmod -R 777 /etc/solr-7.4.0 索引数据Solr目录中的example提供了基础数据，我们可以把这些基础数据加载到刚才创建的techproducts集合，并建立索引： bin/post -c techproducts example/exampledocs/* 搜索在Solr Admin中可以自己定义查询条件进行查询。 先选中创建的techproducts集合，然后选择Query； 在q中输入自己的查询条件，默认*:*查询所有。比如id:123，就是查询id为123的内容； 多条件查询，中间用+连接，如：+(features:&quot;CAS latency&quot;)+(id:&quot;VDBDB1A16&quot;)；相反，如果希望结果中过滤掉某个属性的内容，用-连接，如：+(features:&quot;CAS latency&quot;)-(id:&quot;VDBDB1A16&quot;) fl对查询结果进行过滤，仅显示fl中的属性。多个属性,间隔； Solr其他命令删除集合1bin/solr delete -c techproducts 创建新集合1bin/solr create -c &lt;yourCollection&gt; -s 2 -rf 2 停止1bin/solr stop -all 重新启动12bin/solr start -c -p 8983 -s example/cloud/node1/solrbin/solr start -c -p 7574 -s example/cloud/node2/solr -z localhost:9983","categories":[{"name":"中间件","slug":"中间件","permalink":"https://wonius.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"Solr","slug":"Solr","permalink":"https://wonius.github.io/tags/Solr/"}]},{"title":"SpringRedisData中事务的坑","slug":"SpringRedisData中事务的坑","date":"2018-09-07T01:38:39.000Z","updated":"2020-03-26T06:50:43.000Z","comments":true,"path":"2018/09/07/SpringRedisData中事务的坑/","link":"","permalink":"https://wonius.github.io/2018/09/07/SpringRedisData%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9D%91/","excerpt":"","text":"背景​ 项目中使用redis存储会话，考虑到并发场景，在对session进行管理的时候需要加锁。我们项目中使用了StringRedisTemplate，故而打算用它实现一个分布式锁。 过程version 1​ 首先，使用setnx达到锁的效果，为了防止系统异常出现死锁，还需要为每个锁设置过期时间。由于这些都是非原子性操作，所以使用redis事务进行处理。 123456public void getLock(String key) &#123; stringRedisTemplate.multi(); stringRedisTemplate.opsForValue().set(&quot;SessionLock&quot;, &quot;true&quot;); stringRedisTemplate.exec();&#125; ​ 然而发现事务并没起作用，后来查看源码发现，如果没有是使用@Transactional注解，stringRedisTemplate的每个操作都会新建一个连接，不同连接没有实现multi的特性。 version 2​ 发现问题继而加上注解 https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html https://blog.csdn.net/weixin_38399962/article/details/82753763 https://juejin.im/post/5ce5638ef265da1b91636a56 https://www.jianshu.com/p/d72e8526bea1 https://www.cnblogs.com/toutou/p/redis_lock.html https://blog.csdn.net/liuhanfanshuang/article/details/52136438 https://blog.csdn.net/qq_34021712/article/details/79606551?depth_1-utm_source=distribute.pc_relevant_right.none-task&amp;utm_source=distribute.pc_relevant_right.none-task https://blog.csdn.net/congcong68/article/details/52734735","categories":[{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/tags/Spring/"}]},{"title":"lombok应用","slug":"Java-lombok应用","date":"2018-08-30T06:28:17.000Z","updated":"2020-11-03T13:53:37.000Z","comments":true,"path":"2018/08/30/Java-lombok应用/","link":"","permalink":"https://wonius.github.io/2018/08/30/Java-lombok%E5%BA%94%E7%94%A8/","excerpt":"","text":"lombok的方面之处就不多说了，这里列一下使用中遇到的一些问题。 @Builder继承@Builder无法继承。所以当我们同时有父类、子类，无法都使用@Builder。 解决方案：父类不用@Builder，子类构造函数上加@Builder 1234567891011121314151617@AllArgsConstructor@NoArgsConstructorpublic class Father &#123; private String fatherName;&#125;public class Children &#123; private String childName; @Builder public Children(String fatherName, String childName) &#123; super(fatherName); this.childName = childName; &#125;&#125; 缺点： 父类无法使用builder()； 子类的构造得是全参构造； @Data继承子类继承时，需加@EqualsAndHashCode(callSuper=true)","categories":[{"name":"Java","slug":"Java","permalink":"https://wonius.github.io/categories/Java/"}],"tags":[{"name":"lombok","slug":"lombok","permalink":"https://wonius.github.io/tags/lombok/"}]},{"title":"Redis常用命令","slug":"Redis常用命令","date":"2018-08-30T01:51:16.000Z","updated":"2020-11-03T14:02:49.000Z","comments":true,"path":"2018/08/30/Redis常用命令/","link":"","permalink":"https://wonius.github.io/2018/08/30/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"client list查看连接的客户端 monitor实时监控redis执行的命令 inforedis信息 配置密码找到对应的redis.conf文件，一般在/etc/目录下，然后找到requirepass，修改后面的值，并将前面的# 删掉 1# requirepass foobared pub/subpublish：发布； subscribe：监听某一频道； psubscribe：支持正则；","categories":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://wonius.github.io/tags/Redis/"}]},{"title":"Redisson遇到的坑","slug":"Redisson异常","date":"2018-08-30T01:13:11.000Z","updated":"2020-11-03T14:03:25.000Z","comments":true,"path":"2018/08/30/Redisson异常/","link":"","permalink":"https://wonius.github.io/2018/08/30/Redisson%E5%BC%82%E5%B8%B8/","excerpt":"","text":"WRONGTYPE Operation against a key holding the wrong kind of value 12RLock lc = redisson.getLock(&quot;LOCK&quot;); lc.lock(1000,TimeUnit.MILLISECONDS); 原因：redisson中的getLock为了保持原子性，使用Lua脚本一次提交。在设置锁时，使用hset。 当redis里面已经存在”LOCK”的变量，调用getLock（内部实现为hset(“LOCK”)），会报该异常。 处理：先确保redis中的”LOCK”参数删掉，在调用lock(); unlock方法中的publish12RLock lc = redisson.getLock(&quot;LOCK&quot;);lc.unlock(); 背景项目中使用psubscribe &quot;*&quot;订阅了所有频道，在onMessage()监听处理中用到了Redisson锁，并且在函数最后有unlock()释放锁操作。 现象代码运行时，发现会一直触发onMessage()，造成了死循环。 分析使用monitor实时监控redis执行的命令，发现在unlock时，会依次做下面的操作： 12345exists XXXXhexists XXXX ******hincrby XXXX ****** -1del XXXXpublish redisson_lock_channel:&#123;XXXX&#125; 0 可以看到在最后会向redisson_lock_channel:{XXXX} publish 一个0 处理在onMessage()中针对自己想订阅的频道处理，否则return;","categories":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://wonius.github.io/tags/Redis/"}]},{"title":"养犬有道の疫苗篇","slug":"柴犬疫苗那些事儿","date":"2018-08-26T11:12:30.000Z","updated":"2018-09-09T08:38:22.000Z","comments":true,"path":"2018/08/26/柴犬疫苗那些事儿/","link":"","permalink":"https://wonius.github.io/2018/08/26/%E6%9F%B4%E7%8A%AC%E7%96%AB%E8%8B%97%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/","excerpt":"","text":"疫苗没有注射完以前，不要带宠物出门、洗澡！ 疫苗没有注射完以前，不要带宠物出门、洗澡！ 疫苗没有注射完以前，不要带宠物出门、洗澡！ 疫苗品牌尽量选国外的吧，前段时间长生生物爆出的丑闻，连给人注射的疫苗都不靠谱，还指望宠物疫苗多安全吗？不是崇洋媚外，实在是国内让人不放心。 X联国外品牌主要有： 荷兰英特威公司，疫苗品牌名叫宠必威； 分2联（幼犬宝）、4联（优免康）、6联（乐必妥）。据说6联国内不让进口，所以市面上很少。 美国硕腾公司（辉瑞子公司），疫苗品牌名叫卫佳； 分5联、8联，一般叫卫佳伍、卫佳捌。宠物医院基本都是卫佳捌。 法国梅里亚公司，疫苗品牌名叫优乐康； 这个比较少，大多是宠必威、卫佳。 狂犬国外品牌主要有： 荷兰英特威公司，疫苗品牌名叫宠必威*锐必威； 美国硕腾公司（辉瑞子公司），疫苗品牌名叫瑞比克； 法国梅里亚公司，疫苗品牌名叫瑞贝康； 疫苗种类主要两类，犬瘟、细小等X联疫苗，和狂犬疫苗。 犬瘟、细小是幼犬最容易得的病，而且不容易治好，上面说的2联就是这两种的联合疫苗。其他的4联、6联、8联，都是以这个为基础增加了其他种类的疫苗。犬瘟、细小疫苗要注射3次，所以组合有多样，可以246，或者666，也可以888。 狂犬疫苗大家都知道，人畜都会得，为了避免传染，也是要注射的。 注射时间X联：一般6周左右注射第一针，每隔3~4周再注射。不过有些犬舍为了让客户尽早拿到狗狗，会提前注射，大概是4周左右就会注射第一针。英特威的2联在第4周的时候就可以注射了。之后每年一针加强。 狂犬：理论上来讲，注射最后一针X联时，过一会就可以注射狂犬了。但是狂犬会对幼犬脑部发育有影响，所以尽量等幼犬4月以上，再注射。之后每年一针。需要注意的是，狂犬只能在防疫站，或者防疫站指定的宠物医院注射。像北京、上海需要办理“狗狗户口”，必须有狂犬注射证明才能不办理。之后每年一针加强。 接种时要注意狗狗身体状况，一定要身体健康才能接种。接种后也要注意，不要换粮、换环境等，以免接种失败。 注射地点 防疫站 这个网上一查都知道。 宠物医院 百度地图、大众点评搜索就有。 注射之后3天内不要换粮、换环境、带出去溜等，狗狗情绪波动太会导致免疫失败。 最后一针注射1周之后，可以带出去溜了。 最后一针注射3周之后，可以带到医院里检查抗体。 one more thing一般来讲，X联三针最好使用同一个品牌。如果遇到一些突发状况，需要注射其他品牌的疫苗，虽然不建议，但是也可以。我们家就是前两针英特威2联、4联，由于英特威6联国内很少，没找到，只好注射了卫佳8，现在也活蹦乱跳。不过每个狗狗体质都不一样，尽量不要随便更换。","categories":[{"name":"养犬有道","slug":"养犬有道","permalink":"https://wonius.github.io/categories/%E5%85%BB%E7%8A%AC%E6%9C%89%E9%81%93/"}],"tags":[{"name":"狗狗","slug":"狗狗","permalink":"https://wonius.github.io/tags/%E7%8B%97%E7%8B%97/"}]},{"title":"家有小柴の柴犬身高体重参照表","slug":"柴犬养成","date":"2018-08-23T13:24:44.000Z","updated":"2018-09-09T08:37:52.000Z","comments":true,"path":"2018/08/23/柴犬养成/","link":"","permalink":"https://wonius.github.io/2018/08/23/%E6%9F%B4%E7%8A%AC%E5%85%BB%E6%88%90/","excerpt":"","text":"身高体重参照表每只柴犬体质都不一样，我也遇到过3个月才4斤多，狗狗健康就好，不用非得逼着他多吃。","categories":[{"name":"家有小柴","slug":"家有小柴","permalink":"https://wonius.github.io/categories/%E5%AE%B6%E6%9C%89%E5%B0%8F%E6%9F%B4/"}],"tags":[{"name":"柴犬","slug":"柴犬","permalink":"https://wonius.github.io/tags/%E6%9F%B4%E7%8A%AC/"}]},{"title":"腾讯云+Hexo支持https协议","slug":"Hexo-腾讯云开启https","date":"2018-08-23T01:20:58.000Z","updated":"2020-11-03T13:51:11.000Z","comments":true,"path":"2018/08/23/Hexo-腾讯云开启https/","link":"","permalink":"https://wonius.github.io/2018/08/23/Hexo-%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BC%80%E5%90%AFhttps/","excerpt":"","text":"申请证书 登录腾讯云管理平台； 打开云产品—域名与网站—SSL证书管理，点击申请证书（也可以自己制作证书。不过使用腾讯云的服务更简单一点，阿里云也有制作证书的功能）； 填好信息，下一步； 域名身份验证，支持两种方式，我用的是手动DNS验证，在域名解析添加一条解析记录就可以了； 等待审核，一般一个工作日就审核通过； 审核通过后，下载证书； .crt：自签名的证书.csr：证书的请求(用于向证书颁发机构申请crt证书时使用，nginx配置时不会用到).key：SSL Key (分为不带口令和带口令版本)。签名证书配置nginx需要的是.crt证书，和不带口令的SSL Key的.key文件。 配置nginx 将下载好的证书上传到服务器，指定目录保存； 编辑nginx解析规则，添加443端口解析（编辑前记得备份，养成良好习惯）： 12345678910111213141516server &#123; listen 443; server_name _; #填写绑定证书的域名 ssl on; ssl_certificate /****/1_wonius.top_bundle.crt; #证书路径 ssl_certificate_key /****/2_wonius.top.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置 ssl_prefer_server_ciphers on; location / &#123; root /data/www/hexo; #站点目录 index index.html index.htm; &#125; &#125; （可选）全站加密，http自动跳转https，修改80端口规则： 12345server &#123; listen 80; server_name _; rewrite ^(.*) https://$host$1 permanent; &#125; 重启nginxservice nginx restart； 然后访问，是不是就有小绿锁🔐了 one more thing开启https之后，如果内部有一些依赖服务不支持https，那这些服务将不可用。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://wonius.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://wonius.github.io/tags/Hexo/"}]},{"title":"家有小柴の柴犬挑选篇","slug":"柴犬挑选","date":"2018-08-07T13:18:58.000Z","updated":"2018-09-09T08:37:34.000Z","comments":true,"path":"2018/08/07/柴犬挑选/","link":"","permalink":"https://wonius.github.io/2018/08/07/%E6%9F%B4%E7%8A%AC%E6%8C%91%E9%80%89/","excerpt":"","text":"​ 大概在5月份，朋友的朋友，打算到别的城市发展，家里有一只雪纳瑞，打算送给别人领养。朋友知道我比较喜欢🐶，所以告诉了我，当时开心的睡不着，第二天请了半天假，开车过去接狗子，到小区门口被告知，有情况，不送了。当时别提多郁闷，但是也没办法┐(ﾟ～ﾟ)┌。经这事儿一撩，大学时就萌生的养狗的念头，再也憋不住，把这事提上了日程。 关于领养​ 写在最前面，也是鼓励大家领养代替购买，领养的渠道有很多，当地的流浪狗/流浪猫收容所，救助站等，或者自己小区，或者朋友家。我本身有一些强迫症，如果养狗就一定要从头开始，自己带，所以选择了买小狗。我朋友领养了一只被遗弃的德牧串串，长得也很可爱，现在也特别乖。狗狗只要你对他好，他一定会对你好的。少一些买卖，多一些关爱。 ​ 不管是领养，还是购买，在领回家之前，一定要考虑清楚。如果你不清楚是否做好准备，可以问自己下面几个问题：​ 家人是否同意接纳你的新成员？如果遇到了家庭阻力，你是否有能力对抗邪恶势力，保护他？ 是否准备好捡屎擦尿？狗狗在没学会定点之前，家里任何一个地方都是🚾； 是否有耐心陪他成长？在他懂事之前，他是个小淘气，会乱叫、咬东西，大型犬还会拆家； 是否可以为了他学习，了解之前未曾涉及的领域？比如狗粮成分、如何训练、疾病知识等； 是否有时间、有精力陪他玩耍，带他出去遛狗？好动是狗的天性，无处发泄的精力只能用在破坏家具上； 是否有经济基础？疫苗、看病、狗粮、零食、玩具、尿片、装备等，都是money； 考虑清楚，能满足条件的，可以打个勾。如果还不到一半的，可以放弃了。 ​ 一旦领回家，就要担负起照顾他一生的责任。 购买渠道​ 购买的话，无外乎下面几种渠道： 犬舍。价格通常较高，尤其是知名犬舍，稍微品相好一些的崽，上万是很正常的。这个渠道相对靠谱，而且有些还会带出生纸（注1）。适合不差钱、新手的同学。记得以前有一张图，国内12大柴犬犬舍合照，具体有哪些犬舍忘了，可以在当地打听打听。另外也有一些小犬舍，也有不错的狗子，尽量多看一些。我有朋友在柴多酱买的，也不错。犬舍价格至少5k起，上不封顶。 个人家养。一般是家养的狗配出来的，价格不会太高，毕竟不是专门做这个生意。通常在豆瓣、转转、闲鱼上发帖，不过比较少。豆瓣有个柴犬小组，还算靠谱。转转、闲鱼上大多是骗人的（注2），注意不要上当受骗。这个渠道风险较高，不适合新手。我是在研究、学习了1个多月之后，才专门找家养，并且现场挑狗买的。这就有点像逛古玩市场，好孬都有，眼力好才能捡漏。价格在3k~5k之间，太便宜的一定不要信！别人都卖3k以上，他卖几百、1k、2k，他傻嘛？ 正规宠物店。家养狗狗生的宝宝，因为没有渠道卖不出去，或者犬舍因为品相不好卖不出去，大多会送到宠物店，宠物店按批发价收。看到这你懂了吧，大多是别人挑剩下的才会在宠物店里。当然也不排除有些店做的比较好，有好的合作伙伴。所以这个渠道良莠不齐，也算考眼力，价格也比较贵。另外就是，有一些专门骗人的宠物店，专门卖病狗。之前在宠物医院碰到一个狗主人，以前在一家宠物店买过两只狗，都不到两个星期就死了。所以去宠物点的话也要注意点。接触比较少，价格也不太清楚，不过有朋友说也是上万起的。 贴吧。百度你懂的，几个大一点的柴犬吧，据说已经被各种狗商垄断，只有他们能发卖狗信息的帖子，一些小犬舍发帖直接被删。在贴吧看看别人家的狗子，学习些知识还是可以的，买狗就算了。不是说没有良心卖家，水太深，不适合新手。不过贴吧里还是有一些热心网友，会帮人鉴别真假。 买狗网站。这个了解不多，不过也不推荐。买狗注重实地挑选，最好在当地买。买狗网站上也充斥着大量无良卖家在卖假冒柴犬。 说这么多，还是那句话，做足功课，不贪小便宜，就不怕上当。 注1：血统证明，只要父母双方都有血统证书，生的宝宝可以申请出生纸。等到一定年龄可以到机构换血统证书，换证费貌似200。一些犬舍会给狗子贴标签，“双血统带纸”，就是这个意思。自己家养的话，用处不大，一般参赛需要。另外的用处就是长大后配种成功，如果另外一只也有证书，宝宝就可以申请出生纸，出售价格会稍微高一些。另外补一句，这个出生纸也不绝对就是真的，某宝上就可以买。 注2：闲鱼、转转上，大多是一些骗子，放一些偷来的照片、视频，吸引你跟他聊天，没几句就说加微信，然后约你看狗。重点来了，等到时间你到指定地方，他一定说有事没时间，让朋友带你去看。而他朋友如果带你去宠物店，一定不要买！不出意外，这些都是星期狗。什么是星期狗？就是病狗，你带回家，1、2天就会生病，不到一个星期就死掉。去找宠物店理论也没用，他们会说给你换狗，你挑完了还让你补差价。举报也没用，人家证件齐全，有关部门也没办法。 挑选注意事项​ 挑选的时候呢，也有一些注意事项： 最好在当地买，实地、现场挑选。之前给你发的视频是不是真的狗啊，犬舍环境怎么样啊，狗狗性格怎么样啊，身体有没有隐疾啊，具体长得怎么样啊，等等等等，都要现场看了才知道。而且现场挑选，一般会有一堆狗狗，你可以对比，哪个更合得来，选择也更多一点。如果实在无法现场挑，也一定要跟买家视频，确保狗真的在他那，而不是偷了别人的视频。另外也可以视频跟狗狗互动，进一步挑选。 跟卖家要父母的照片、交配视频等，确保这只狗子真的是柴犬的崽。另一方面，看父母的样子，对于崽以后长什么样心里也有个数，小的基本上还是随父母的。 北京、上海基本上都要4k起，上万很正常。南京等新一线城市也不便宜，二三线可能会便宜点。今年2018年是狗年，很多人养狗打算汪一下，而且柴犬黄色那种叫赤柴，又红又旺，寓意好，价格也就上来了。 买幼犬的话，一般选择2~4个月之间。2个月之前，太小，断奶没多久，不好照顾。4个月之后性格基本养成，调教会麻烦些。不过也不是说一定要在这个区间内，主要还是主人要有耐心照顾他，陪他一起成长。我家花生，在他40多天断奶没多久我就抱回家了。 柴犬小时候跟土狗特别相似，所以有很多“山寨”柴犬，尽量做好功课再去买，以免买到大黄，或者串串。 幼犬特征​ 这里讲的是2个月左右的狗狗特征： 头部。小狗的头部以大一点的为佳，后脑勺也要有适度地隆起较好。额头要适度地宽，幼犬时期带点圆弧，长大之后就会好了，但是若太突出就不大好了。小狗的鼻梁在幼犬时会比较深，考虑到这一点时就要注意选择幼犬时要选鼻梁不过深也不过浅者。（挑柴犬小狗，要以头大一点的好，额头要宽，后脑勺隆起的，鼻梁不深不浅的。） 嘴巴。要粗而短，这样长大嘴巴不会太尖，不会像狐型脸。小时候很多黑嘴管，这是正常的，长大就会褪了。 鼻子。鼻子要小而黑，稍微有些湿润，不是太湿，太湿可能生病了。 眼睛。圆眼，眼睛不能过大或者眼球突出，要呈杏仁形，配合头部，眼色要乌黑，两眼的距离不能过开。 耳朵。耳朵要小，耳位不能过低，两耳的距离不能太开。要挑耳朵呈三角形的，在小狗附近拍拍手，看看小狗的听力，耳朵的大小要和柴犬的头相匹配，耳朵要有适当的厚度，保持前倾的。 颈部粗壮，两颊毛发旺盛。 尾巴。大多是蜷缩型。 这些特征都是局部最优，满足所有条件的柴犬很少。所以不必太过强求，只是让大家心里有个标准，重要的是狗子健健康康，就够了。 成犬特征​ 有些朋友买的是成犬，相对来说，比较好区分一点，下面也有一些特征： 三角眼。眼睛要稍稍呈三角形，下眼帘要接近直线，上眼皮在离眼头三分之一处开始弧度较大，这种眼型才是正确的眼型。 立耳。折耳一定是假的。 毛发。柴犬有双层毛，外层刚毛直立，内层绒毛细软。","categories":[{"name":"家有小柴","slug":"家有小柴","permalink":"https://wonius.github.io/categories/%E5%AE%B6%E6%9C%89%E5%B0%8F%E6%9F%B4/"}],"tags":[{"name":"柴犬","slug":"柴犬","permalink":"https://wonius.github.io/tags/%E6%9F%B4%E7%8A%AC/"}]},{"title":"Spring注入static变量","slug":"Spring注入static变量","date":"2018-07-26T01:29:49.000Z","updated":"2020-11-03T14:04:32.000Z","comments":true,"path":"2018/07/26/Spring注入static变量/","link":"","permalink":"https://wonius.github.io/2018/07/26/Spring%E6%B3%A8%E5%85%A5static%E5%8F%98%E9%87%8F/","excerpt":"","text":"使用setter方法1234567891011@Service(&quot;userService&quot;)public class UserService implements IUserService &#123; public static String hello; @Value(&quot;$&#123;hello.value&#125;&quot;) public void setHello(String hello) &#123; hello = hello; &#125;&#125; 在spring容器中注入对象时赋值123456789101112131415@Service(&quot;userService&quot;)public class UserService implements IUserService &#123; public static String hello; @Value(&quot;$&#123;hello.value&#125;&quot;) private String pHello; @PostConstruct public void init() &#123; hello = pHello; &#125; &#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/tags/Spring/"}]},{"title":"kubectl常用命令","slug":"kubectl常用命令","date":"2018-07-21T12:08:00.000Z","updated":"2020-11-03T13:39:45.000Z","comments":true,"path":"2018/07/21/kubectl常用命令/","link":"","permalink":"https://wonius.github.io/2018/07/21/kubectl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Pod12345678910111213# 查看所有podkubectl get po -o wide# 查看pod启动日志kubectl logs xxx# 也可以写到文件中，查看方便kubectl logs xxx &gt; xxx.log# 查看pod的详细信息kubectl describe po xxx# 进入pod内部kubectl exec -it xxx bash Deployment12# 编辑deploymentkubectl edit deployments xxx -o yaml Service12345# 查看所有servicekubectl get svc# 查看某个servicekubectl describe svc xxx ConfigMap12345678# 从文件创建configMap# AA：configMap的名称# BB：configMap中key的名称# CC.yml：源文件kubectl create cm AA --from-file=BB=CC.yml# 将configMap导出为yaml文件kubectl get cm AA -o yaml &gt; BB.yaml Ingress","categories":[{"name":"K8S","slug":"K8S","permalink":"https://wonius.github.io/categories/K8S/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://wonius.github.io/tags/Kubernetes/"}]},{"title":"Redis-Session管理","slug":"Redis-Session管理","date":"2018-07-13T02:33:41.000Z","updated":"2020-11-03T14:02:39.000Z","comments":true,"path":"2018/07/13/Redis-Session管理/","link":"","permalink":"https://wonius.github.io/2018/07/13/Redis-Session%E7%AE%A1%E7%90%86/","excerpt":"","text":"背景​ 项目中使用redis存储session，写了个session切面用于维护session，当用户调用接口时，会先检验redis中是否有session（有效期为30min，调用接口刷新有效期），如果没有，创建session。在并发的场景下，需要用锁避免重复写。StringRedisTemplate中没有对锁的封装，所以自己简单封装了两个取锁的方法。 tryLock1234567891011121314151617/** * 尝试获取锁，如果获取到，并设置过期时间 * @param keyName * @param seconds * @return */public boolean tryLock(String keyName, Long seconds) &#123; RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); boolean lockReturn = connection.setNX(keyName.getBytes(), LOCK_TRUE.getBytes()); connection.close(); if (lockReturn) &#123; redisTemplate.expire(keyName, seconds, TimeUnit.SECONDS); &#125; return lockReturn;&#125; getLock123456789101112131415161718/** * 一定会获取到锁，并设置过期时间 * @param keyName * @param seconds * @return * @throws InterruptedException */public boolean getLock(String keyName, Long seconds) throws InterruptedException &#123; RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); boolean lockReturn = connection.setNX(keyName.getBytes(), LOCK_TRUE.getBytes()); while (!lockReturn) &#123; Thread.sleep(10); lockReturn = connection.setNX(keyName.getBytes(), LOCK_TRUE.getBytes()); &#125; connection.expire(keyName.getBytes(), seconds); connection.close(); return lockReturn;&#125; releaseLock12345678/** * 释放锁 * @param keyName * @return */public boolean releaseLock(String keyName) &#123; return redisTemplate.delete(keyName);&#125; 后记在投产后，发现效果并不好，实例经常会跑着跑着，突然卡死。分析原因应该是redis连接池资源耗尽，导致服务器所有线程阻塞，整台实例不可用（一般跑2、3天才会出现）。因为项目已经使用了StringRedisTemplate，本身它会管理自己的连接池。而我通过getConnection获取到的连接，相当于脱离于连接池，有可能导致与StringRedisTemplate不兼容。 如果有同学自己通过jedis实现了jedispool进行管理，应该没有这个问题，感兴趣的小伙伴可以试一下。jedis无法自动关闭连接，当使用完之后，别忘了手动关闭。 后来，发现了Redisson，专门用于解决分布式问题，也提供了锁的实现，小伙伴可以用一下。 顺便再吐槽下StringRedisTemplate，感觉就是对redis的命令做了简单的封装，而且开启事务时还有坑…","categories":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://wonius.github.io/tags/Redis/"}]},{"title":"Spring集成HanLP分词","slug":"Spring集成HanLP分词","date":"2018-06-15T07:46:20.000Z","updated":"2020-11-03T14:05:52.000Z","comments":true,"path":"2018/06/15/Spring集成HanLP分词/","link":"","permalink":"https://wonius.github.io/2018/06/15/Spring%E9%9B%86%E6%88%90HanLP%E5%88%86%E8%AF%8D/","excerpt":"","text":"配置pom文件12345&lt;dependency&gt; &lt;groupId&gt;com.hankcs&lt;/groupId&gt; &lt;artifactId&gt;hanlp&lt;/artifactId&gt; &lt;version&gt;portable-1.6.4&lt;/version&gt;&lt;/dependency&gt; 当前最新版本为1.6.4。可以在这里查看最新版本。 添加自定义字典文件在resources下面建立目录，存放自定义字典。 我的目录是resources/hanlp/custom/CustomDic.txt 编写Java类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class WordUtil &#123; public static final String CUSTOM_DICTIONARY_PATH = &quot;/hanlp/custom/CustomDic.txt&quot;; public static final String SYNONYM_WORD_PATH = &quot;/hanlp/synonym/SynonDic.txt&quot;; private static List&lt;Term&gt; list; private static Segment segment; private static Map synonymMap; public static void main(String[] args) &#123;// refreshDictionary(); segmentSentence(&quot;你是柴犬狗狗吧&quot;); &#125; /** * 刷新用户自定义词典 */ public static void refreshDictionary() &#123; HanLP.Config.CustomDictionaryPath = new String[] &#123; WordUtil.class.getResource(CUSTOM_DICTIONARY_PATH).getPath() &#125;; CustomDictionary.reload(); segment = HanLP.newSegment().enableCustomDictionary(true); &#125; /** * 分词 * @param text * @return */ public static String segmentSentence(String text) &#123; segment = HanLP.newSegment().enableCustomDictionary(true); list = segment.seg(text); String result = list.get(0).word; for(int i =1; i &lt; list.size(); i++) &#123; result+=&quot; &quot;+list.get(i).word; &#125; System.out.println(result); return result; &#125; /** * 刷新同义词字典 */ public static void refreshSynonym() &#123; String path = WordUtil.class.getResource(SYNONYM_WORD_PATH).getPath(); File file = new File(path); BufferedReader reader; synonymMap = new HashMap(); try &#123; reader = new BufferedReader(new FileReader(file)); String line; while ((line = reader.readLine()) != null) &#123; String[] words = line.split(&quot; &quot;); for (String word: words) &#123; synonymMap.put(word, words[0]); &#125; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取同义词 * @param word * @return */ public static String getSynonym(String word) &#123; return (String) synonymMap.get(word); &#125;&#125; 为了提高效率，HanLP会将字典文件转义成bin文件，每次从bin文件中读取单词。 所以当字典更新时，需要删除bin文件，重新生成，官方提供reload方法，但是需要指定自定义字典的位置。 当调用segment()方法时会先从对应的bin文件中读取，如果没有bin文件，先重新生成bin文件，再读取。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/tags/Spring/"},{"name":"分词","slug":"分词","permalink":"https://wonius.github.io/tags/%E5%88%86%E8%AF%8D/"}]},{"title":"iOS12_Beta升级","slug":"iOS12-Beta升级","date":"2018-06-06T09:48:43.000Z","updated":"2018-06-06T11:45:54.000Z","comments":true,"path":"2018/06/06/iOS12-Beta升级/","link":"","permalink":"https://wonius.github.io/2018/06/06/iOS12-Beta%E5%8D%87%E7%BA%A7/","excerpt":"","text":"​ iOS12体验版发布，大家快来体验咯 描述文件： 链接:https://pan.baidu.com/s/1G_lG1nqRf9Qunuq7cg8HLw 密码:eyih 升级方法： 备份（毕竟是体验版，给自己留条后路😬）； 手机Safari浏览器打开连接，下载描述文件，点击允许安装； 重启手机，在通用-软件更新，升级； 下载，安装就可以了；","categories":[{"name":"iOS","slug":"iOS","permalink":"https://wonius.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://wonius.github.io/tags/iOS/"}]},{"title":"SpringBoot多台实例监控redis-key失效事件","slug":"SpringBoot多实例监控redis-key失效事件","date":"2018-06-06T07:04:52.000Z","updated":"2020-11-03T14:06:04.000Z","comments":true,"path":"2018/06/06/SpringBoot多实例监控redis-key失效事件/","link":"","permalink":"https://wonius.github.io/2018/06/06/SpringBoot%E5%A4%9A%E5%AE%9E%E4%BE%8B%E7%9B%91%E6%8E%A7redis-key%E5%A4%B1%E6%95%88%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"背景​ 最近接到一个需求，redis中的变量失效时，需要记录到日志中。查了一下，可以通过订阅redis事件，java中进行处理。订阅事件会阻塞当前进程，所以需要开线程处理。后台服务是SpringBoot搭建，而且是多实例，为了确保每个事件仅消费一次，适用redis锁。 Redis设置​ redis中需要开启事件通知，默认是不开启的。 修改redis.conf文件，设置notify-keyspace-events 为 Ex； redis中执行config set notify-keyspace-events Ex（该方式重启redis失效）； 参数 作用 K 键空间通知，以__keyspace@&lt;db&gt;__为前缀 E 键事件通知，以__keysevent@&lt;db&gt;__为前缀 g del , expipre , rename 等类型无关的通用命令的通知 $ String命令 l List命令 s Set命令 h Hash命令 z 有序集合命令 x 过期时间（每次key过期时生成） e 去住时间（当key在内存存满了被清除时生成） A g$lshzxe的别名，因此“AKE”意味着所有事件 Java代码设置JedisPool增加jedis依赖pom文件增加： 1234&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt; yml中增加配置12345678910jedis: max: total: 100 idle: 10 waitmillis: 10000 timeout: 10000 testOnBorrow: true host: localhost port: 6379 password: 123456 实例化JedisPool1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.springboot.common;import org.springframework.beans.factory.annotation.Value;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * 请编写注释 * * @author yangfan * @Date 2018/6/4 */@Configuration@EnableCachingpublic class JedisConfig extends CachingConfigurerSupport&#123; @Value(&quot;$&#123;jedis.port&#125;&quot;) private int port; @Value(&quot;$&#123;jedis.host&#125;&quot;) private String host; @Value(&quot;$&#123;jedis.max.total&#125;&quot;) private Integer maxTotal; @Value(&quot;$&#123;jedis.max.idle&#125;&quot;) private Integer maxIdle; @Value(&quot;$&#123;jedis.max.waitmillis&#125;&quot;) private Long maxWaitMillis; @Value(&quot;$&#123;jedis.max.timeout&#125;&quot;) private int timeout; @Value(&quot;$&#123;jedis.password&#125;&quot;) private String password; @Bean public JedisPool redisPoolFactory() &#123; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxIdle(maxIdle); jedisPoolConfig.setMaxWaitMillis(maxWaitMillis); JedisPool jedisPool = new JedisPool(jedisPoolConfig, host, port, timeout, password); return jedisPool; &#125;&#125; 创建监听类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.springboot.common;import com.springboot.util.ApplicationContextUtil;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPubSub;import javax.annotation.PostConstruct;/** * 请编写注释 * * @author yangfan * @Date 2018/6/4 */@Componentpublic class RedisListener extends JedisPubSub&#123; private static final String INSTANCE_LOCK = &quot;INSTANCE_LOCK&quot;; @Autowired private JedisPool jedisPool; Jedis jedis = null; @Override public void onPMessage(String pattern, String channel, String message) &#123; // 线程中无法通过注解获取注入对象，在ApplicationContext中获取 jedisPool = ApplicationContextUtil.getBean(JedisPool.class); jedis = jedisPool.getResource(); // 加锁。setnx是原子性操作，设置成功返回1，否则返回0 Long lock = jedis.setnx(INSTANCE_LOCK, &quot;true&quot;); if (lock == 0) &#123; jedis.close(); return ; &#125; // 写处理逻辑，可以做其他操作，也可以入库 System.out.println(pattern + &quot;=&quot; + channel + &quot;=&quot; + message); jedis.del(INSTANCE_LOCK); jedis.close(); &#125; @PostConstruct void init() &#123; // 订阅事件，使用线程中操作，否则阻塞当前进程 SubThread subThread = new SubThread(jedisPool); Thread thread = new Thread(subThread); thread.start(); &#125;&#125; 一开始的方案，实例共用一个锁，实际发现可能会有实例A处理完，实例B才开始处理，导致处理多次的情况。 然后优化为将锁时间加长的方案。 而如果将锁时间加长，会导致多台实例处理是阻塞，进而优化为每个Key加锁、并延长锁时间的方案。 修改后如下： 123456789101112131415161718192021@Overridepublic void onPMessage(String pattern, String channel, String message) &#123; if (StringUtils.startsWith(message, KEYS_LOCK)) &#123; return; &#125; jedisPool = ApplicationContextUtil.getBean(JedisPool.class); jedis = jedisPool.getResource(); Long lock = jedis.setnx(KEYS_LOCK + message, &quot;true&quot;); jedis.expire(KEYS_LOCK + message, 5); if (lock == 0) &#123; jedis.close(); return ; &#125; System.out.println(pattern + &quot;=&quot; + channel + &quot;=&quot; + message); jedis.del(KEYS_LOCK); jedis.close();&#125; 创建线程类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.springboot.common;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;/** * 请编写注释 * * @author yangfan * @Date 2018/6/4 */public class SubThread implements Runnable &#123; private JedisPool jedisPool;// 经测试，仅能通过 * 正则匹配，如果加前缀，匹配不到 String pattern = &quot;*&quot;;// String pattern0 = &quot;keyspace@0:SessionID_*&quot;;// String pattern1 = &quot;__key*__:*&quot;;// 可以监听某一特定channel的事件// String pattern2 = &quot;__keyevent@0__:*&quot;;// 入参可以为String数组// String[] patterns = new String[]&#123;&quot;SessionID_*&quot;&#125;; public SubThread(JedisPool jedisPool) &#123; this.jedisPool = jedisPool; &#125; @Override public void run() &#123; //如果线程中出现问题，线程直接挂掉。 //使用while，重启线程 while(true) &#123; Jedis jedis = jedisPool.getResource(); try &#123; jedis.psubscribe(new RedisListener(), pattern); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; jedis.close(); &#125; &#125; &#125;&#125; 创建ApplicationContextUtil类1234567891011121314151617181920212223242526272829303132333435363738394041package com.springboot.util;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;/** * 请编写注释 * * @author yangfan * @Date 2018/6/6 */@Componentpublic class ApplicationContextUtil implements ApplicationContextAware &#123; private static ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; if (ApplicationContextUtil.applicationContext == null) &#123; ApplicationContextUtil.applicationContext = applicationContext; &#125; &#125; public static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; public static Object getBean(String name) &#123; return ApplicationContextUtil.getApplicationContext().getBean(name); &#125; public static &lt;T&gt;T getBean(Class&lt;T&gt; clazz) &#123; return ApplicationContextUtil.getApplicationContext().getBean(clazz); &#125; public static &lt;T&gt;T getBean(String name, Class&lt;T&gt; clazz) &#123; return ApplicationContextUtil.getApplicationContext().getBean(name, clazz); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/categories/Spring/"},{"name":"SpringBoot","slug":"Spring/SpringBoot","permalink":"https://wonius.github.io/categories/Spring/SpringBoot/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://wonius.github.io/tags/Redis/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wonius.github.io/tags/SpringBoot/"}]},{"title":"SpringCloud项目搭建","slug":"SpringCloud项目搭建","date":"2018-05-31T09:58:25.000Z","updated":"2020-11-03T14:08:01.000Z","comments":true,"path":"2018/05/31/SpringCloud项目搭建/","link":"","permalink":"https://wonius.github.io/2018/05/31/SpringCloud%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","excerpt":"","text":"为了便于管理，将所有项目放在一个工程中维护。 创建parent工程首先，new一个Project，选择maven，注意不要勾选create from archetype，填写GroupId、ArtifactId、Project name。创建完成后，将src目录删除。 配置pom文件，添加SpringCloud依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;packaging&gt;pom&lt;/packaging&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RC2&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;!--各个子项目共用的一些依赖--&gt; &lt;!--test--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--springboot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 创建Eureka注册中心创建一个新的Module，选择Spring Initializr，填写GroupId、ArtifactId、Name，选择Cloud Discovery - Eureka Server，命名Module Name，完成。 创建后会自动在parent的pom中添加模块，如果没有，手动添加，如下： 1234&lt;modules&gt; &lt;module&gt;eureka-server&lt;/module&gt; &lt;module&gt;service&lt;/module&gt;&lt;/modules&gt; 编辑该模块中的pom文件： 1234567891011121314151617181920&lt;parent&gt; &lt;groupId&gt;com.woniu&lt;/groupId&gt; &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;artifactId&gt;eureka-server&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt;&lt;name&gt;eureka-server&lt;/name&gt;&lt;description&gt;Eureka-Server&lt;/description&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 对应Application类添加注解： 12345678@SpringBootApplication@EnableEurekaServerpublic class EurekaServersApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServersApplication.class, args); &#125;&#125; 编辑application.yml配置文件： 1234567891011server: port: 8081eureka: instance: hostname: localhost# 该server默认同时也是client client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 创建服务创建一个新的Module，仍然选择Maven，勾选create from archetype，并选择quickstart，填写ArtifactId、Module Name，创建完成。 修改pom文件： 12345678910111213141516&lt;parent&gt; &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt; &lt;groupId&gt;com.woniu&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;artifactId&gt;service&lt;/artifactId&gt;&lt;name&gt;service&lt;/name&gt;&lt;packaging&gt;jar&lt;/packaging&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在main下面创建resources目录，该目录下创建application.yml文件： 123456789spring: application: name: serviceeureka: client: serviceUrl: defaultZone: http://localhost:8081/eureka/server: port: 8082 在对应Application类添加注解： 123456789101112131415@SpringBootApplication@EnableEurekaClient@RestControllerpublic class ServiceApplication &#123; @GetMapping(&quot;/hello&quot;) public String service()&#123; return &quot;world&quot;; &#125; public static void main( String[] args ) &#123; SpringApplication.run(ServiceApplication.class, args); &#125;&#125; 最后依次启动eureka-server、service服务，访问localhost:8081，访问成功。 @EnableDiscoveryClient、@EnableEurekaClient区别： @EnableDiscoveryClient基于spring-cloud-commons，其discovery service有多种实现，Eureka、Consul、Zookeeper等。而@EnableEurekaClient只针对spring-cloud-netflix服务； @EnableEurekaClient实现中包含@EnableDiscoveryClient；","categories":[{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/categories/Spring/"},{"name":"SpringCloud","slug":"Spring/SpringCloud","permalink":"https://wonius.github.io/categories/Spring/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://wonius.github.io/tags/SpringCloud/"}]},{"title":"vim键位介绍","slug":"vim键位介绍","date":"2018-05-29T13:31:56.000Z","updated":"2018-05-29T14:01:00.000Z","comments":true,"path":"2018/05/29/vim键位介绍/","link":"","permalink":"https://wonius.github.io/2018/05/29/vim%E9%94%AE%E4%BD%8D%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"键位图 常用键位 在普通模式下输入 :s/正则表达式/替换文本/g 可以在当前行范围内查找替换。（在正常的IDEA中需要选中当前行后在当前选区查找替换） 在普通模式下输入 小数点将在当前光标位置重复上一次修改操作。例如你在某一行进行了上述的查找替换，如果立即需要在另一行做同样操作，把光标移动到该行按小数点即可。 yyp复制当前行。 yy10p 复制当前行10次 u 撤销修改/ Ctrl+R 重做修改 q加任何单个数字或字母，录制后续操作，记录到名为该数字或字母的宏（Macro）中。在录制状态下按q结束录制。@加某个已录制的宏名（单个数字或字母），回放宏。录制的宏只要不被覆盖，会自动保存。重启IDEA后仍然有效。（在正常的IDEA中使用宏需要进行菜单操作，不甚方便） daw删除一个单词，d$删除至行尾，d0删除至行首（包括缩进），d^删除至行首（保留缩进），dd删除当前行。删除后按p可以复制删除内容。 J直接把下一行连接到本行末尾，去除缩进 %跳到匹配的括号 10ib 插入10个b。（数字）i/a/o/O（字符串）可插入n个重复字符串，i在光标前插入，a在光标后插入，o在下一行插入，O在上一行插入。注意在IDEA默认情况下输入“i字符”后会弹出自动补全菜单，需要多按一下ESC取消掉补全菜单。 在一个数字上按ctrl+a，可将该数字加1. 按ctrl+x可将数字减1. 按（数字）ctrl+a，可将光标数字加上输入的数字。 ~ - 将光标下的字母改变大小写。 g~aw - 改变当前单词的大小写。gU&lt;空格&gt; - 当前字母改大写。gu&lt;空格&gt; -当前字母改小写。 gUaw - 当前单词改大写。 guaw - 当前单词改小写。 在字符串前面的引号上 gUf” - 字符串改大写。 行号G -直接移动到某行。（使用IDEA的Ctrl+G会弹出对话框，且移动到的那行会自动居中，颇为眼花） H -光标移动到屏幕第一行。 L - 光标移动到屏幕最后一行。 M - 光标移动到屏幕中间。 zz - 光标所在行居中。","categories":[{"name":"工具","slug":"工具","permalink":"https://wonius.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://wonius.github.io/tags/vim/"}]},{"title":"技能图谱-后端","slug":"技能图谱-后端","date":"2018-05-29T13:26:29.000Z","updated":"2018-06-15T09:23:24.000Z","comments":true,"path":"2018/05/29/技能图谱-后端/","link":"","permalink":"https://wonius.github.io/2018/05/29/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1-%E5%90%8E%E7%AB%AF/","excerpt":"","text":"","categories":[{"name":"技能图谱","slug":"技能图谱","permalink":"https://wonius.github.io/categories/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/"}],"tags":[{"name":"技能图谱","slug":"技能图谱","permalink":"https://wonius.github.io/tags/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/"},{"name":"大数据","slug":"大数据","permalink":"https://wonius.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"SpringCloud概述","slug":"SpringCloud概述","date":"2018-05-29T03:12:03.000Z","updated":"2018-05-31T10:00:40.000Z","comments":true,"path":"2018/05/29/SpringCloud概述/","link":"","permalink":"https://wonius.github.io/2018/05/29/SpringCloud%E6%A6%82%E8%BF%B0/","excerpt":"","text":"组件 ZuulZuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。 ​ 服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 Eureka云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。 三部分：服务注册中心、服务提供者、服务消费者； 两功能：服务注册、服务发现； 运行流程： 两台Eureka服务注册中心组成主从注册中心集群（防止一台挂掉整个服务挂掉）； 服务提供者向Eureka服务注册中心进行注册、续约、下线服务等操作； 服务消费者从Eureka服务注册中心拉取服务列表，并维护在本地（这是客户端发现模式的机制体现）； 服务消费者根据服务列表找到对应服务提供者，进行消费； 注意： 服务续约任务调用时间间隔，默认30s； 服务缓存清单更新机制，次/30s； 服务时效时间，默认90s； 默认每60s将当前清单中超过90s（没有续约）的服务踢出去； 自我保护机制，工作机制是如果15min内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制。（Eureka自我保护机制，通过配置eureka.server.enable-self-preservation，默认为打开状态，建议生产环境打开此配置） Eureka Server不再从注册列表中移除因为长时间没收到心跳检测的过期服务； Eureka Server仍然能够接受新服务的注册、查询请求，但是不会同步到其他节点上，保证当前节点依然可用； 当网络稳定时，当前Eureka Server新的注册信息会被同步到其他节点上； Ribbon提供云端负载均衡，有多种负载均衡策略可供选择，可配合服务发现和断路器使用。 服务消费者根据服务列表中的服务提供者，找到实际的服务生产者，通过Spring Cloud Ribbon实现。 负载均衡策略： RandomRule：从实例列表随机选取。选择逻辑在一个while(server == null)循环内，正常情况下会返回一个服务实例。如果出现死循环，取不到服务实例，则有可能存在并发的bug； RoundRobinRule（默认）：按照线性轮询选择一个实例。随机次数超过10次，结束尝试； WeightedResponseTimeRule：基于RoundRobinRule，增加了根据实例的运行情况计算权重，然后根据权重挑选实例。主要有三个核心内容： 定时任务 每30s执行一次权重计算； 权重计算 记录每个实例的统计信息，累加所有实例的平均响应时间，得到总平均响应时间，totalResponseTime； 循环所有的实例，计算其权重，weightSoFar+=totalResponseTime - 实例平均响应时间，其中weightSoFar初始值为0。每个实例权重结果，保存到ArrayList currentWeights中； 实例选择 判断最后一个实例的权重，是否 &lt; 0.001d，若是，采用RoundRobbinRule策略； 生成一个[0, 最大权重值) 区间内的随机数； 遍历权重清单currentWeights，若权重 &gt;= 随机得到的数值，就选择这个实例； 其他策略还有BestAvailableRule、AvaliablityFilteringRule、ZoneAvoidanceRule、RetryRule FeignFeign是一种声明式、模板化的HTTP客户端。 ​ Spring Cloud Feign 是一个声明web服务客户端，这使得编写Web服务客户端更容易，使用Feign 创建一个接口并对它进行注解，它具有可插拔的注解支持包括Feign注解与JAX-RS注解，Feign还支持可插拔的编码器与解码器，Spring Cloud 增加了对 Spring MVC的注解，Spring Web 默认使用了HttpMessageConverters, Spring Cloud 集成 Ribbon 和 Eureka 提供的负载均衡的HTTP客户端 Feign。 Hystrix熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。 ​ 在分布式架构中，当某个服务单元发生故障（类似电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝）， 想调用方返回一个错误响应，而不是长时间等待，这样就不会使得线程因调用故障服务被长时间占用不放，避免了故障在分布式系统中的蔓延​ 针对这一机制，Spring Cloud Hystrix实现了断路器，线程隔离等一系列服务保护功能。它也是基于Netfix的开源框架Hystrix实现的，该框架的目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。 Hystrix具有： 服务降级 服务熔断 请求总数（默认20） 错误百分比（默认50） 线程和信号隔离 请求缓存 请求合并 服务监控 集群监控（Turbine） Config配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion。 ​ 分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。 在Spring Cloud中，有分布式配置中心组件Spring Cloud Config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在Cpring Cloud Config 组件中，分两个角色，一是Config Server，二是Config Client。 ​ Config Server用于配置属性的存储，存储的位置可以为Git仓库、SVN仓库、本地文件等，Config Client用于服务属性的读取。 Bus事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。 ​ 在Spring Cloud Config中，我们知道的配置文件可以通过Config Server存储到Git等地方，通过Config Client进行读取，但是我们的配置文件不可能是一直不变的，当我们的配置文件放生变化的时候如何进行更新哪？ ​ 一种最简单的方式重新一下Config Client进行重新获取，但Spring Cloud绝对不会让你这样做的，Spring Cloud Bus正是提供一种操作使得我们在不关闭服务的情况下更新我们的配置。 ​ Spring Cloud Bus官方意义：消息总线。 ​ 当然动态更新服务配置只是消息总线的一个用处，还有很多其他用处。 应用场景： 将消息路由到一个或多个目的地； 消息转换为其他的表现形式； 执行消息聚焦、消息分解，并将结果发送到其他的目的地，然后重新组合响应返回给消息用户； 调用web服务来检索数据； 响应错误时间； 使用发布-订阅模式来提供内容，或基于主题的消息路由 两个消息组件： kafka： 属性名 说明 默认值 spring.cloud.stream.kafka.binder.brokers Kafka的服务端列表 localhost spring.cloud.stream.kafka.binder.defaultBrokerPort Kafka服务端的端口。当brokers中没有配置端口时，默认使用这个端口 9092 spring.cloud.stream.kafka.binder.zkNodes Kafka服务端连接的Zookeeper节点列表 localhost spring.cloud.stream.kafka.binder.defaultZkPort Zookeeper节点的默认端口。当zkNodes中没有配置端口时，默认使用这个端口 2181 RabbitMQ： 属性名 说明 默认值 spring.rabbitmq.host RabbitMQ的服务地址 localhost spring.rabbitmq.port RabbitMQ的服务端口 5672 spring.rabbitmq.username spring.rabbitmq.password #总结 前面介绍了很多Spring Cloud的组件，本篇按照自己的角度来做一次归纳。 Spring Cloud技术应用从场景上可以分为两大类：润物无声类和独挑大梁类。 润物无声，融合在每个微服务中、依赖其它组件并为其提供服务。 Ribbon，客户端负载均衡，特性有区域亲和、重试机制。 Hystrix，客户端容错保护，特性有服务降级、服务熔断、请求缓存、请求合并、依赖隔离。 Feign，声明式服务调用，本质上就是Ribbon+Hystrix Stream，消息驱动，有Sink、Source、Processor三种通道，特性有订阅发布、消费组、消息分区。 Bus，消息总线，配合Config仓库修改的一种Stream实现， Sleuth，分布式服务追踪，需要搞清楚TraceID和SpanID以及抽样，如何与ELK整合。 独挑大梁，独自启动不需要依赖其它组件。 Eureka，服务注册中心，特性有失效剔除、服务保护。 Dashboard，Hystrix仪表盘，监控集群模式和单点模式，其中集群模式需要收集器Turbine配合。 Zuul，API服务网关，功能有路由分发和过滤。 Config，分布式配置中心，支持本地仓库、SVN、Git、Jar包内配置等模式， 每个组件都不是平白无故的产生的，是为了解决某一特定的问题而存在。 Eureka和Ribbon，是最基础的组件，一个注册服务，一个消费服务。 Hystrix为了优化Ribbon、防止整个微服务架构因为某个服务节点的问题导致崩溃，是个保险丝的作用。 Dashboard给Hystrix统计和展示用的，而且监控服务节点的整体压力和健康情况。 Turbine是集群收集器，服务于Dashboard的。 Feign是方便我们程序员些更优美的代码的。 Zuul是加在整个微服务最前沿的防火墙和代理器，隐藏微服务结点IP端口信息，加强安全保护的。 Config是为了解决所有微服务各自维护各自的配置，设置一个同意的配置中心，方便修改配置的。 Bus是因为config修改完配置后各个结点都要refresh才能生效实在太麻烦，所以交给bus来通知服务节点刷新配置的。 Stream是为了简化研发人员对MQ使用的复杂度，弱化MQ的差异性，达到程序和MQ松耦合。 Sleuth是因为单次请求在微服务节点中跳转无法追溯，解决任务链日志追踪问题的。 特殊成员Zipkin，之所以特殊是因为从jar包和包名来看它不属于Spring Cloud的一员，但是它与Spring Cloud Sleuth的抽样日志结合的天衣无缝。乍一看它与Hystrix的Dashboard作用有重叠的部分，但是他们的侧重点完全不同。Dashboard侧重的是单个服务的统计和是否可用，Zipkin侧重的监控环节时长。简言之，Dashboard侧重故障诊断，Zipkin侧重性能优化。 内容参考： https://blog.csdn.net/yejingtao703/article/details/78331442 https://blog.csdn.net/xlgen157387/article/details/77773908 https://blog.csdn.net/tudou201601/article/details/79123912","categories":[{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/categories/Spring/"},{"name":"SpringCloud","slug":"Spring/SpringCloud","permalink":"https://wonius.github.io/categories/Spring/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://wonius.github.io/tags/SpringCloud/"}]},{"title":"Python基础知识","slug":"Python规范","date":"2018-05-24T08:43:36.000Z","updated":"2018-05-24T08:45:19.000Z","comments":true,"path":"2018/05/24/Python规范/","link":"","permalink":"https://wonius.github.io/2018/05/24/Python%E8%A7%84%E8%8C%83/","excerpt":"","text":"Python规范规范","categories":[{"name":"Python","slug":"Python","permalink":"https://wonius.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wonius.github.io/tags/Python/"}]},{"title":"Python2与Python3差异","slug":"Python2与Python3差异","date":"2018-05-23T08:31:59.000Z","updated":"2018-05-23T08:39:53.000Z","comments":true,"path":"2018/05/23/Python2与Python3差异/","link":"","permalink":"https://wonius.github.io/2018/05/23/Python2%E4%B8%8EPython3%E5%B7%AE%E5%BC%82/","excerpt":"","text":"方法 方法 Python2 Python3 file.write() file.write(str) file.write(str.encode()) # 需转为byte self.cf.read() self.cf.read(file_path) self.cf.read(file_path, encoding=””) #需指定编码","categories":[{"name":"Python","slug":"Python","permalink":"https://wonius.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wonius.github.io/tags/Python/"}]},{"title":"pip2与pip3无法并存共用","slug":"pip2与pip3无法并存共用问题","date":"2018-05-23T02:23:24.000Z","updated":"2020-11-03T14:02:04.000Z","comments":true,"path":"2018/05/23/pip2与pip3无法并存共用问题/","link":"","permalink":"https://wonius.github.io/2018/05/23/pip2%E4%B8%8Epip3%E6%97%A0%E6%B3%95%E5%B9%B6%E5%AD%98%E5%85%B1%E7%94%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"环境OS： ​ MacOS 10.13.4 Python： ​ python2.7(系统自带)：/System/Library/Frameworks/Python.framework/Versions/2.7 ​ python3.6.5(后来安装)：/usr/local/Cellar/python/3.6.5/ pip： ​ pip2：/usr/local/bin/pip ​ pip3：/usr/local/bin/pip3 升级​ 当我安装python3.6.5之后，python3中自带pip3，且将原来装的pip覆盖，导致pip无法使用。虽然不用pip命令也可以使用pip功能（python -m pip install XXXX），可以通过重新安装pip方法，使pip生效。 12345678sudo python -m pip install --upgrade pip --force-reinstall# 查看pip信息pip -V# 如果pip3也有问题，重新安装一遍pip3sudo python3 -m pip install --upgrade pip --force-reinstall# 查看pip3信息pip3 -V ​","categories":[{"name":"Python","slug":"Python","permalink":"https://wonius.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wonius.github.io/tags/Python/"}]},{"title":"BlockChain入门","slug":"BlockChain入门","date":"2018-05-21T07:34:32.000Z","updated":"2018-06-15T10:10:16.000Z","comments":true,"path":"2018/05/21/BlockChain入门/","link":"","permalink":"https://wonius.github.io/2018/05/21/BlockChain%E5%85%A5%E9%97%A8/","excerpt":"","text":"智能合约首先要理解智能合约，下面这篇比较通俗易懂 http://www.figurefinance.com/news/shownews.php?lang=cn&amp;id=4827 这篇比较官方： http://www.8btc.com/what-are-smart-contracts-in-search-of-a-consensus 以太坊入门http://me.tryblockchain.org/getting-up-to-speed-on-ethereum.html","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"https://wonius.github.io/categories/BlockChain/"}],"tags":[{"name":"BlockChain","slug":"BlockChain","permalink":"https://wonius.github.io/tags/BlockChain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://wonius.github.io/tags/Ethereum/"}]},{"title":"MacOS安装Matlab","slug":"MacOS安装Matlab","date":"2018-05-20T15:45:43.000Z","updated":"2018-05-21T03:28:50.000Z","comments":true,"path":"2018/05/20/MacOS安装Matlab/","link":"","permalink":"https://wonius.github.io/2018/05/20/MacOS%E5%AE%89%E8%A3%85Matlab/","excerpt":"","text":"下载​ 百度网盘链接: ​ 安装包：https://pan.baidu.com/s/1Y1llTPxRa55ojXotTkg6eQ 密码: wchd ​ 破解补丁包：https://pan.baidu.com/s/1iTrHoTXmhut-nedNSf4RZg 密码:b7oz ​ 如果下载速度过慢，可参考本博客搭建Aria2，享受会员版的下载速度。 ##安装 ​ 下载后是一个iso文件，打开，断开网络连接，双击InstallForMacOSX.app，点下一步。 ​ 选择“使用文件安装秘钥”，点击“下一步“，同意条款，然后将5442240402238172080830933拷贝到许可证秘钥窗口，一直”下一步“，等待安装完成。 ​ 用破解补丁包中的libmwservices.dylib替换掉/Applications/MATLAB_R2015b/bin/maci64/libmwservices.dylib。 ​ 打开Matlab_R2015b，选择离线激活方式，加载破解补丁包中的/license.lib，成功。","categories":[{"name":"工具","slug":"工具","permalink":"https://wonius.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://wonius.github.io/tags/matlab/"}]},{"title":"ML中的Loss函数","slug":"ML中的Loss函数","date":"2018-05-12T14:09:12.000Z","updated":"2021-02-18T02:10:27.000Z","comments":true,"path":"2018/05/12/ML中的Loss函数/","link":"","permalink":"https://wonius.github.io/2018/05/12/ML%E4%B8%AD%E7%9A%84Loss%E5%87%BD%E6%95%B0/","excerpt":"","text":"原文","categories":[{"name":"ML","slug":"ML","permalink":"https://wonius.github.io/categories/ML/"}],"tags":[{"name":"ML","slug":"ML","permalink":"https://wonius.github.io/tags/ML/"}]},{"title":"TensorFlow四种Cross_Entropy算法实现与应用","slug":"TensorFlow四种Cross-Entropy算法实现与应用","date":"2018-05-12T14:07:24.000Z","updated":"2018-05-12T14:08:29.000Z","comments":true,"path":"2018/05/12/TensorFlow四种Cross-Entropy算法实现与应用/","link":"","permalink":"https://wonius.github.io/2018/05/12/TensorFlow%E5%9B%9B%E7%A7%8DCross-Entropy%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8/","excerpt":"","text":"原文","categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://wonius.github.io/categories/TensorFlow/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://wonius.github.io/tags/TensorFlow/"}]},{"title":"TensorFlow-API","slug":"TensorFlow-API","date":"2018-05-11T07:36:01.000Z","updated":"2020-11-03T14:12:45.000Z","comments":true,"path":"2018/05/11/TensorFlow-API/","link":"","permalink":"https://wonius.github.io/2018/05/11/TensorFlow-API/","excerpt":"","text":"tf.constant根据value的值，生成一个shape维度的张量常量 Define1constant(value, dtype=None, shape=None, name=&#x27;Const&#x27;, verify_shape=False) Parameter 参数名 必须 类型 说明 value Y 常量、list 张量的值 dtype N dtype 张量的元素类型 shape N 1维整型张量、array 张量的维度 name N string 张量的名称 verify_shape N boolean 检测shape是否和value的shape一致。若值为False，当不一致时，会用最后一个元素将shape补全 Demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import tensorflow as tfimport numpy as np&quot;&quot;&quot;@version: ??@author: Gavin@license: Apache Licence @contact: woniuyf@gmail.com@site: https://wonius.top/@software: PyCharm@file: constant.py@time: 2018/5/11 10:00&quot;&quot;&quot;a = tf.constant([1,2,3,4,5,6], shape=[2,3])b = tf.constant(-1, shape=[3,2])c = tf.matmul(a,b)e = tf.constant(np.arange(1,13,dtype=np.int32), shape=[2,2,3])f = tf.constant(np.arange(13,25, dtype=np.int32), shape=[2,3,2])g = tf.matmul(e,f)with tf.Session() as sess: print (&quot;-----------------&quot;) print (a.get_shape()) print (sess.run(a)) print (&quot;-----------------&quot;) print (b.get_shape()) print (sess.run(b)) print (&quot;-----------------&quot;) print (c.get_shape()) print (sess.run(c)) print (&quot;-----------------&quot;) print (e.get_shape()) print (sess.run(e)) print (&quot;-----------------&quot;) print (f.get_shape()) print (sess.run(f)) print (&quot;-----------------&quot;) print (g.get_shape()) print (sess.run(g)) # 执行结果# -----------------# (2, 3)# [[1 2 3]# [4 5 6]]# -----------------# (3, 2)# [[-1 -1]# [-1 -1]# [-1 -1]]# -----------------# (2, 2)# [[ -6 -6]# [-15 -15]]# -----------------# (2, 2, 3)# [[[ 1 2 3]# [ 4 5 6]]## [[ 7 8 9]# [10 11 12]]]# -----------------# (2, 3, 2)# [[[13 14]# [15 16]# [17 18]]## [[19 20]# [21 22]# [23 24]]]# -----------------# (2, 2, 2)# [[[ 94 100]# [229 244]]## [[508 532]# [697 730]]] tf.placeholder一种占位符，在执行时填入具体值 ###Define 1placeholder(dtype, shape=None, name=None) Parameter 参数名 必选 类型 说明 dtype Y dtype 占位符的数据类型 shape N 1维整型张量、array 占位符的维度 name N string 占位符的名称 Demo123456789101112131415161718192021222324import tensorflow as tfimport numpy as np&quot;&quot;&quot;@version: ??@author: Gavin@license: Apache Licence @contact: woniuyf@gmail.com@site: https://wonius.top/@software: PyCharm@file: placeholder.py@time: 2018/5/11 10:57&quot;&quot;&quot;x = tf.placeholder(tf.float32, [None, 3])y = tf.matmul(x, x)with tf.Session() as sess: rand_array = np.random.rand(3,3) print (sess.run(y, feed_dict=&#123;x:rand_array&#125;))# 执行结果# [[ 0.88505751 0.79640609 0.46087515]# [ 0.36539319 0.41709256 0.16832483]# [ 0.75206953 0.90277183 0.37584797]] tf.nn.conv2d卷积运算 Define12conv2d(input, filter, strides, padding, use_cudnn_on_gpu=True, data_format=&#x27;NHWC&#x27;, name=None) Parameter 参数名 必选 类型 说明 input Y tensor 4维的tensor，即[batch, in_height, in_width, in_channels](若input是图像，即[训练时一个batch的图片数量，图片高度，图片宽度，图片的通道数])类型需为float32、float64 filter Y tensor 4维的tensor，即[filter_height, filter_width, in_channels, out_channels](若input是图像，即[卷积核的高度，卷积核的宽度，图像通道数，卷积核个数])filter的in_channels必须与input的in_channels相等 strides Y list 长度为4的list，卷积时在input上每一维的步长，一般strides[0]=strides[3]=1 padding Y string 卷积方式，只能为”SAME”、”VALID”其中之一。SAME：补全方式；VALID：丢弃方式 use_cudnn_on_gpu N boolean 是否使用cudnn加速，默认为true data_format N string 只能为”NHWC”、”NCHW”，默认”NHWC” Name N string 运算名称 Demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import tensorflow as tf&quot;&quot;&quot;@version: ??@author: Gavin@license: Apache Licence @contact: woniuyf@gmail.com@site: https://wonius.top/@software: PyCharm@file: conv2d.py@time: 2018/5/9 20:48&quot;&quot;&quot;a = tf.constant([1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,0,0],dtype=tf.float32,shape=[1,5,5,1])b = tf.constant([1,0,1,0,1,0,1,0,1],dtype=tf.float32,shape=[3,3,1,1])c = tf.nn.conv2d(a,b,strides=[1, 2, 2, 1],padding=&#x27;VALID&#x27;)d = tf.nn.conv2d(a,b,strides=[1, 2, 2, 1],padding=&#x27;SAME&#x27;)with tf.Session() as sess: print (&quot;c shape:&quot;) print (c.get_shape()) print (&quot;c value:&quot;) print (sess.run(c)) print (&quot;d shape:&quot;) print (d.get_shape()) print (&quot;d value:&quot;) print (sess.run(d))# 运算结果# c shape:# (1, 2, 2, 1)# c value:# [[[[ 4.]# [ 4.]]## [[ 2.]# [ 4.]]]]# d shape:# (1, 3, 3, 1)# d value:# [[[[ 2.]# [ 3.]# [ 1.]]## [[ 1.]# [ 4.]# [ 3.]]## [[ 0.]# [ 2.]# [ 1.]]]] tf.nn.relu激活函数 Define1relu(features, name=None) Parameter 参数名 必选 类型 说明 features Y tensor float32、float64、int8、int16、int32、int64、uint8、unit16、half name N string 运算名称 Demo1234567891011121314151617181920import tensorflow as tf&quot;&quot;&quot;@version: ??@author: Gavin@license: Apache Licence @contact: woniuyf@gmail.com@site: https://wonius.top/@software: PyCharm@file: relu.py@time: 2018/5/9 21:30&quot;&quot;&quot;a = tf.constant([1,-2,0,4,-5,6])b = tf.nn.relu(a)with tf.Session() as sess: print (sess.run(b))# 运算结果# [1 0 0 4 0 6] tf.nn.max_pool池化 Define12max_pool(value, ksize, strides, padding, data_format=&#x27;NHWC&#x27;, name=None) Parameter 参数名 必选 类型 说明 value Y tensor 4维的张量，即[batch, height, width, channels]，类型为tf.float32 ksize Y list 池化窗口的大小，长度为4的list，一般是[1，height，width，1]，因为不在batch和channels上做池化，所以第一个和最后一个维度为1 strides Y list 池化窗口在每一个维度上的步长。一般strides[0]=strides[3]=1 padding Y string 只能为”VALID”、”SAME”其中之一，这个值决定了不同的池化方式。VALID：丢弃方式；SAME：补全方式 data_format N string 只能为”NHWC”、”NCHW”。默认”NHWC” name N string 运算名称 Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445import tensorflow as tf&quot;&quot;&quot;@version: ??@author: Gavin@license: Apache Licence @contact: woniuyf@gmail.com@site: https://wonius.top/@software: PyCharm@file: max_pool.py@time: 2018/5/10 20:38&quot;&quot;&quot;a = tf.constant([1,3,2,1,2,9,1,1,1,3,2,3,5,6,1,2], dtype=tf.float32, shape=[1,4,4,1])b = tf.nn.max_pool(a, ksize=[1,2,2,1], strides=[1, 2, 2, 1], padding=&#x27;SAME&#x27;)c = tf.nn.max_pool(a, ksize=[1,2,2,1], strides=[1,2,2,1], padding=&#x27;VALID&#x27;)with tf.Session() as sess: print (&quot;b.shape&quot;) print (b.get_shape()) print (&quot;b.value&quot;) print (sess.run(b)) print (&quot;c.shape&quot;) print (c.get_shape()) print (&quot;c.value&quot;) print (sess.run(c))# 运算结果# b.shape# (1, 2, 2, 1)# b.value# [[[[ 9.]# [ 2.]]## [[ 6.]# [ 3.]]]]# c.shape# (1, 2, 2, 1)# c.value# [[[[ 9.]# [ 2.]]## [[ 6.]# [ 3.]]]] tf.nn.dropout丢弃函数。在训练过程中，按照一定概率将一部分神经网络单元暂时从网络中丢弃，相当于从原始网络中找到一个更瘦的网络 Define1dropout(x, keep_prob, noise_shape=None, seed=None, name=None) Parameter 参数名 必选 类型 说明 x Y tensor x中keep_prob概率的元素，除以keep_prob。或者为0 keep_prob Y scalar dropout的概率，一般先用占位符 noise_shape N tensor 默认情况下，每个元素是否dropout是相互独立的。如果noise_shape[i]==shape(x)[i]，该维度元素相互独立；如果noise_shape[i]!=shape(x)[i]，该维度元素不相互独立，即要么一起dropout，要么一起保留 seed N 数值 如果指定该值，每次dropout结果相同 name N string 运算名称 Demo1234567891011121314151617181920212223import tensorflow as tf&quot;&quot;&quot;@version: ??@author: Gavin@license: Apache Licence @contact: woniuyf@gmail.com@site: https://wonius.top/@software: PyCharm@file: dropout.py@time: 2018/5/10 20:58&quot;&quot;&quot;a = tf.constant([1,2,3,4,5,6], shape=[2,3], dtype=tf.float32)b = tf.placeholder(tf.float32)c = tf.nn.dropout(a, b, [2,1], 1)with tf.Session() as sess: sess.run(tf.global_variables_initializer()) print (sess.run(c, feed_dict=&#123;b:0.75&#125;))# 运算结果# [[ 0. 0. 0. ]# [ 5.33333349 6.66666651 8. ]] tf.nn.sigmoid_cross_entropy_with_logits计算交叉熵函数。先对 logits 进行 sigmoid 计算，再计算交叉熵 交叉熵：Loss函数的一种。常见的Loss函数为均方平方差； sigmoid：激活函数的一种； 另外除了tf.nn.sigmoid_cross_entropy_with_logits以外，还有 tf.nn.softmax_cross_entropy_with_logits（参数logits必须为未经缩放的，函数中会对logits进行sigmoid运算） tf.nn.sparse_softmax_cross_entropy_with_logits tf.nn.weighted_cross_entropy_with_logits三种交叉熵函数 Define1sigmoid_cross_entropy_with_logits(_sentinel=None, labels=None, logits=None, name=None) Parameter 参数名 必选 类型 说明 _sentinel N None 一般不使用 logits N tensor float32、float64 labels N tensor shape与logits相同 name N string 运算名称 Demo1234567891011121314151617181920212223import tensorflow as tf&quot;&quot;&quot;@version: ??@author: Gavin@license: Apache Licence @contact: woniuyf@gmail.com@site: https://wonius.top/@software: PyCharm@file: sigmod_cross_entropy_with_logits.py.py@time: 2018/5/11 09:27&quot;&quot;&quot;x = tf.constant([1,2,3,4,5,6,7], dtype=tf.float64)y = tf.constant([1,1,1,0,0,1,0], dtype=tf.float64)loss = tf.nn.sigmoid_cross_entropy_with_logits(logits=x, labels=y)with tf.Session() as sess: print (sess.run(loss))# 运算结果# [3.13261688e-01 1.26928011e-01 4.85873516e-02 4.01814993e+00# 5.00671535e+00 2.47568514e-03 7.00091147e+00] 该函数返回值是一个向量，并不是一个数。 如果要求交叉熵，需要进一步做tf.reduce_sum操作，即对向量里所有元素求和； 如果要求Loss（常见），需要进一步做tf.reduce_mean操作，对向量求平均值； tf.nn.bias_add将偏差项 bias 加到 value 上面，可以看做是 tf.add 的一个特例。其中 bias 必须是一维的，并且维度和 value 的最后一维相同，数据类型必须和 value 相同 Define1bias_add(value, bias, data_format=None, name=None) Parameter 参数名 必选 类型 说明 value Y tensor Float、double、int64、int32、int16、int8、uint8、complex64、complex128 bias Y 1维tensor 维度必须和value最后一维维度相等 data_format N string 支持”NHWC”、”NCHW” name N string 运算名称 Demo123456789101112131415161718192021222324252627282930313233343536373839404142import tensorflow as tf&quot;&quot;&quot;@version: ??@author: Gavin@license: Apache Licence @contact: woniuyf@gmail.com@site: https://wonius.top/@software: PyCharm@file: bias_add.py@time: 2018/5/11 11:45&quot;&quot;&quot;a = tf.constant([[1.0, 2.0],[1.0, 2.0],[1.0, 2.0]])b = tf.constant([2.0,1.0])c = tf.constant([1.0])with tf.Session() as sess: print (&quot;bias_add(a, b)&quot;) print (sess.run(tf.nn.bias_add(a, b))) # print (sess.run(tf.nn.bias_add(a, c))) error print (&quot;-----------------&quot;) print (&quot;tf.add(a, b)&quot;) print (sess.run(tf.add(a, b))) print (&quot;-----------------&quot;) print (&quot;tf.add(a, c&quot;) print (sess.run(tf.add(a, c)))# bias_add(a, b)# [[ 3. 3.]# [ 3. 3.]# [ 3. 3.]]# -----------------# tf.add(a, b)# [[ 3. 3.]# [ 3. 3.]# [ 3. 3.]]# -----------------# tf.add(a, c# [[ 2. 3.]# [ 2. 3.]# [ 2. 3.]] tf.truncated_normal在截断的正态分布中输出随机数，取值范围[ mean - 2 * stddev, mean + 2 * stddev ] Define1truncated_normal(shape, mean=0.0, stddev=1.0, dtype=tf.float32, seed=None, name=None) Parameter 参数名 必选 类型 说明 shape Y 1维整型张量、array 输出张量的维度 mean N 0维张量、数值 均值 stddev N 0维张量、数值 标准差 dtype N dtype 输出类型 seed N 数值 随机种子，若seed复制，每次产生相同随机数 name N string 运算名称 Demo1234567891011121314151617181920import tensorflow as tf&quot;&quot;&quot;@version: ??@author: Gavin@license: Apache Licence @contact: woniuyf@gmail.com@site: https://wonius.top/@software: PyCharm@file: truncated_nomal.py@time: 2018/5/11 09:52&quot;&quot;&quot;initial = tf.truncated_normal(shape=[3,3], mean=0, stddev=1)print (tf.Session().run(initial))# 运算结果# [[-0.49039015 0.67874366 1.00580561]# [ 0.97545707 0.15845388 -0.73228759]# [-0.60446167 -0.87802863 0.24452373]] tf.reduce_mean计算张量input_tensor的平均值 Define1reduce_mean(input_tensor, axis=None, keep_dims=False, name=None, reduction_indices=None) Parameter 参数名 必选 类型 说明 input_tensor Y 张量 待求平均值的张量 axis N None、0、1 None：全局球平均值0：求每一列平均值1：求每一行平均值 keep_dims N boolean 保留原来的维度（例如不会从二维矩阵降为一维） name N string 运算名称 reduction_indices N None 和axis等价，已弃用 Demo123456789101112131415161718192021222324252627import tensorflow as tf&quot;&quot;&quot;@version: ??@author: Gavin@license: Apache Licence @contact: woniuyf@gmail.com@site: https://wonius.top/@software: PyCharm@file: reduce_mean.py@time: 2018/5/11 13:46&quot;&quot;&quot;initial = [[1.,1.],[2.,2.]]x = tf.Variable(initial, dtype=tf.float32)init_op = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init_op) print (sess.run(tf.reduce_mean(x))) print (sess.run(tf.reduce_mean(x, 0))) #column print (sess.run(tf.reduce_mean(x, 1))) #row# 运算结果# 1.5# [ 1.5 1.5]# [ 1. 2.] tf.square计算张量对应元素的平方 Define1square(x, name=None) Parameter 参数名 必选 类型 说明 x Y tensor half、float32、float64、int32、int64、complex64、complex128 name N string 运算名称 Demo12345678910111213141516171819202122232425import tensorflow as tf&quot;&quot;&quot;@version: ??@author: Gavin@license: Apache Licence @contact: woniuyf@gmail.com@site: https://wonius.top/@software: PyCharm@file: square.py@time: 2018/5/11 13:59&quot;&quot;&quot;initial_x = [[1.,1.], [2.,2.]]x = tf.Variable(initial_x, dtype=tf.float32)x_2 = tf.square(initial_x)init_op = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init_op) print (sess.run(x_2))# 运算结果# [[ 1. 1.]# [ 4. 4.]] tf.squared_difference计算张量x、y对应元素差平方 Define1squared_difference(x, y, name=None) Parameter 参数名 必选 类型 说明 x Y tensor half、float32、float64、int32、int64、complex64、complex128 y Y tensor half、float32、float64、int32、int64、complex64、complex128 name N string 运算名称 Demo12345678910111213141516171819202122232425262728import tensorflow as tf&quot;&quot;&quot;@version: ??@author: Gavin@license: Apache Licence @contact: woniuyf@gmail.com@site: https://wonius.top/@software: PyCharm@file: squared_difference.py@time: 2018/5/11 13:54&quot;&quot;&quot;initial_x = [[1.,1.], [2.,2.]]x = tf.Variable(initial_x, dtype=tf.float32)initial_y = [[3.,3.], [4.,4.]]y = tf.Variable(initial_y, dtype=tf.float32)diff = tf.squared_difference(x, y)init_op = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init_op) print (sess.run(diff))# 运算名称# [[ 4. 4.]# [ 4. 4.]] tf.Variable类，维护图在执行过程中的状态信息，例如神经网络权重值的变化 Define123__init__(initial_value=None, trainable=True, collections=None, validate_shape=True, caching_device=None, name=None, variable_def=None, dtype=None, expected_shape=None, import_scope=None) Parameter 参数名 类型 说明 initial_value tensor Variable类的初始值。这个张量必须制定shape信息，否则后面validate_shape需设为False trainable boolean 是否把变量添加到 GraphKeys.TRAINABLE_VARIABLES中。（ collection 是一种全局存储，不受变量名生存空间影响，一处保存，到处可取） collections Graph collections 全局存储，默认是 GraphKeys.GLOBAL_VARIABLES validate_shape boolean 是否允许被位置维度的initial_value初始化 caching_device string 指明哪个device用来缓存变量 name string 变量名 dtype dtype 如果设置，初始化的值按照该类型初始化 expected_shape tensorShape 要是设置了，那么初始的值会是这种维度 Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201import tensorflow as tf&quot;&quot;&quot;@version: ??@author: Gavin@license: Apache Licence @contact: woniuyf@gmail.com@site: https://wonius.top/@software: PyCharm@file: Variable.py@time: 2018/5/11 14:46&quot;&quot;&quot;initial = tf.truncated_normal(shape=[10, 10], mean=0, stddev=1)W = tf.Variable(initial)list = [[1.,1.], [2.,2.]]X = tf.Variable(list, dtype=tf.float32)init_op = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init_op) print (&quot;------------------------------------------------------------&quot;) print (sess.run(W)) print (&quot;------------------------------------------------------------&quot;) print (sess.run(W[:2,:2])) op = W[:2,:2].assign(22.*tf.ones((2,2))) print (&quot;------------------------------------------------------------&quot;) print (sess.run(op)) print (&quot;------------------------------------------------------------&quot;) print (W.eval(sess)) # computes and returns the value of this variable print (W.eval()) # user with the default session print (&quot;------------------------------------------------------------&quot;) print (W.dtype) print (sess.run(W.initial_value)) print (sess.run(W.op)) print (W.shape) print (&quot;------------------------------------------------------------&quot;) print (sess.run(X))# 运算结果# ------------------------------------------------------------# [[ -1.36460924e+00 -8.78410161e-01 1.87626636e+00 1.27253577e-01# 1.77748889e-01 -2.79777735e-01 -1.29324961e+00 1.18464601e+00# 5.91014000e-03 3.91639054e-01]# [ 1.09924674e+00 -1.08868659e+00 -1.12289786e+00 -6.78496242e-01# 4.25694019e-01 1.06920172e-02 8.05350840e-01 -7.63205171e-01# 3.23375136e-01 4.49576497e-01]# [ -1.05841234e-01 -2.85442650e-01 1.01552248e+00 -1.69130695e+00# -1.15725782e-03 1.47837210e+00 6.69513494e-02 4.84152675e-01# -3.82478178e-01 -1.20722222e+00]# [ 3.09620090e-02 -7.98057988e-02 5.60789108e-01 -1.78828037e+00# 1.95968688e-01 -2.27404922e-01 -1.72476351e+00 -1.23355138e+00# -9.63081241e-01 -1.60457373e+00]# [ 3.23699638e-02 -5.90677261e-01 -1.92470342e-01 -4.10615206e-01# 3.35628651e-02 -1.41288012e-01 -3.40104014e-01 1.13289797e+00# 6.52421772e-01 9.17639136e-01]# [ 5.11528432e-01 1.64260656e-01 -7.84879684e-01 -2.26418376e-01# -8.90385628e-01 -3.38358462e-01 1.96581781e+00 -7.17314780e-02# 1.23814851e-01 7.64766455e-01]# [ 2.22003132e-01 -1.70102561e+00 -1.60155982e-01 1.10927892e+00# -1.14349496e+00 -6.86953589e-02 -3.56495827e-01 -5.14335275e-01# 1.98457405e-01 -2.56361932e-01]# [ -6.98417068e-01 -1.91254735e-01 2.43045017e-01 1.62485635e+00# 1.34399071e-01 4.48576242e-01 9.65317804e-03 2.63324082e-01# 1.71964037e+00 1.81242809e-01]# [ -3.06579232e-01 6.82186067e-01 -1.34259194e-01 8.21067274e-01# 2.75264233e-01 2.36507237e-01 -5.18465579e-01 2.66540438e-01# -4.08049405e-01 4.00008321e-01]# [ 6.39303386e-01 -3.73077720e-01 -3.93441260e-01 1.44391823e+00# -4.43163812e-01 -2.28796184e-01 -9.21004534e-01 -6.29425883e-01# -1.04850844e-01 5.76163709e-01]]# ------------------------------------------------------------# [[-1.36460924 -0.87841016]# [ 1.09924674 -1.08868659]]# ------------------------------------------------------------# [[ 2.20000000e+01 2.20000000e+01 1.87626636e+00 1.27253577e-01# 1.77748889e-01 -2.79777735e-01 -1.29324961e+00 1.18464601e+00# 5.91014000e-03 3.91639054e-01]# [ 2.20000000e+01 2.20000000e+01 -1.12289786e+00 -6.78496242e-01# 4.25694019e-01 1.06920172e-02 8.05350840e-01 -7.63205171e-01# 3.23375136e-01 4.49576497e-01]# [ -1.05841234e-01 -2.85442650e-01 1.01552248e+00 -1.69130695e+00# -1.15725782e-03 1.47837210e+00 6.69513494e-02 4.84152675e-01# -3.82478178e-01 -1.20722222e+00]# [ 3.09620090e-02 -7.98057988e-02 5.60789108e-01 -1.78828037e+00# 1.95968688e-01 -2.27404922e-01 -1.72476351e+00 -1.23355138e+00# -9.63081241e-01 -1.60457373e+00]# [ 3.23699638e-02 -5.90677261e-01 -1.92470342e-01 -4.10615206e-01# 3.35628651e-02 -1.41288012e-01 -3.40104014e-01 1.13289797e+00# 6.52421772e-01 9.17639136e-01]# [ 5.11528432e-01 1.64260656e-01 -7.84879684e-01 -2.26418376e-01# -8.90385628e-01 -3.38358462e-01 1.96581781e+00 -7.17314780e-02# 1.23814851e-01 7.64766455e-01]# [ 2.22003132e-01 -1.70102561e+00 -1.60155982e-01 1.10927892e+00# -1.14349496e+00 -6.86953589e-02 -3.56495827e-01 -5.14335275e-01# 1.98457405e-01 -2.56361932e-01]# [ -6.98417068e-01 -1.91254735e-01 2.43045017e-01 1.62485635e+00# 1.34399071e-01 4.48576242e-01 9.65317804e-03 2.63324082e-01# 1.71964037e+00 1.81242809e-01]# [ -3.06579232e-01 6.82186067e-01 -1.34259194e-01 8.21067274e-01# 2.75264233e-01 2.36507237e-01 -5.18465579e-01 2.66540438e-01# -4.08049405e-01 4.00008321e-01]# [ 6.39303386e-01 -3.73077720e-01 -3.93441260e-01 1.44391823e+00# -4.43163812e-01 -2.28796184e-01 -9.21004534e-01 -6.29425883e-01# -1.04850844e-01 5.76163709e-01]]# ------------------------------------------------------------# [[ 2.20000000e+01 2.20000000e+01 1.87626636e+00 1.27253577e-01# 1.77748889e-01 -2.79777735e-01 -1.29324961e+00 1.18464601e+00# 5.91014000e-03 3.91639054e-01]# [ 2.20000000e+01 2.20000000e+01 -1.12289786e+00 -6.78496242e-01# 4.25694019e-01 1.06920172e-02 8.05350840e-01 -7.63205171e-01# 3.23375136e-01 4.49576497e-01]# [ -1.05841234e-01 -2.85442650e-01 1.01552248e+00 -1.69130695e+00# -1.15725782e-03 1.47837210e+00 6.69513494e-02 4.84152675e-01# -3.82478178e-01 -1.20722222e+00]# [ 3.09620090e-02 -7.98057988e-02 5.60789108e-01 -1.78828037e+00# 1.95968688e-01 -2.27404922e-01 -1.72476351e+00 -1.23355138e+00# -9.63081241e-01 -1.60457373e+00]# [ 3.23699638e-02 -5.90677261e-01 -1.92470342e-01 -4.10615206e-01# 3.35628651e-02 -1.41288012e-01 -3.40104014e-01 1.13289797e+00# 6.52421772e-01 9.17639136e-01]# [ 5.11528432e-01 1.64260656e-01 -7.84879684e-01 -2.26418376e-01# -8.90385628e-01 -3.38358462e-01 1.96581781e+00 -7.17314780e-02# 1.23814851e-01 7.64766455e-01]# [ 2.22003132e-01 -1.70102561e+00 -1.60155982e-01 1.10927892e+00# -1.14349496e+00 -6.86953589e-02 -3.56495827e-01 -5.14335275e-01# 1.98457405e-01 -2.56361932e-01]# [ -6.98417068e-01 -1.91254735e-01 2.43045017e-01 1.62485635e+00# 1.34399071e-01 4.48576242e-01 9.65317804e-03 2.63324082e-01# 1.71964037e+00 1.81242809e-01]# [ -3.06579232e-01 6.82186067e-01 -1.34259194e-01 8.21067274e-01# 2.75264233e-01 2.36507237e-01 -5.18465579e-01 2.66540438e-01# -4.08049405e-01 4.00008321e-01]# [ 6.39303386e-01 -3.73077720e-01 -3.93441260e-01 1.44391823e+00# -4.43163812e-01 -2.28796184e-01 -9.21004534e-01 -6.29425883e-01# -1.04850844e-01 5.76163709e-01]]# [[ 2.20000000e+01 2.20000000e+01 1.87626636e+00 1.27253577e-01# 1.77748889e-01 -2.79777735e-01 -1.29324961e+00 1.18464601e+00# 5.91014000e-03 3.91639054e-01]# [ 2.20000000e+01 2.20000000e+01 -1.12289786e+00 -6.78496242e-01# 4.25694019e-01 1.06920172e-02 8.05350840e-01 -7.63205171e-01# 3.23375136e-01 4.49576497e-01]# [ -1.05841234e-01 -2.85442650e-01 1.01552248e+00 -1.69130695e+00# -1.15725782e-03 1.47837210e+00 6.69513494e-02 4.84152675e-01# -3.82478178e-01 -1.20722222e+00]# [ 3.09620090e-02 -7.98057988e-02 5.60789108e-01 -1.78828037e+00# 1.95968688e-01 -2.27404922e-01 -1.72476351e+00 -1.23355138e+00# -9.63081241e-01 -1.60457373e+00]# [ 3.23699638e-02 -5.90677261e-01 -1.92470342e-01 -4.10615206e-01# 3.35628651e-02 -1.41288012e-01 -3.40104014e-01 1.13289797e+00# 6.52421772e-01 9.17639136e-01]# [ 5.11528432e-01 1.64260656e-01 -7.84879684e-01 -2.26418376e-01# -8.90385628e-01 -3.38358462e-01 1.96581781e+00 -7.17314780e-02# 1.23814851e-01 7.64766455e-01]# [ 2.22003132e-01 -1.70102561e+00 -1.60155982e-01 1.10927892e+00# -1.14349496e+00 -6.86953589e-02 -3.56495827e-01 -5.14335275e-01# 1.98457405e-01 -2.56361932e-01]# [ -6.98417068e-01 -1.91254735e-01 2.43045017e-01 1.62485635e+00# 1.34399071e-01 4.48576242e-01 9.65317804e-03 2.63324082e-01# 1.71964037e+00 1.81242809e-01]# [ -3.06579232e-01 6.82186067e-01 -1.34259194e-01 8.21067274e-01# 2.75264233e-01 2.36507237e-01 -5.18465579e-01 2.66540438e-01# -4.08049405e-01 4.00008321e-01]# [ 6.39303386e-01 -3.73077720e-01 -3.93441260e-01 1.44391823e+00# -4.43163812e-01 -2.28796184e-01 -9.21004534e-01 -6.29425883e-01# -1.04850844e-01 5.76163709e-01]]# ------------------------------------------------------------# &lt;dtype: &#x27;float32_ref&#x27;&gt;# [[-1.26520741 0.15191878 -0.20875564 -1.3333143 -1.2195878 1.98078632# -0.37404546 -0.08800519 1.59779143 0.43416482]# [-0.49763143 1.67703199 -0.75461388 1.39778709 -0.59904957 1.07046878# -0.66246015 1.20341682 -0.91598368 0.02659398]# [ 0.15760519 1.58692122 -1.64905691 -0.82413578 -1.35249043 -0.05494672# 0.1835352 -1.16055572 0.06633712 -0.60654968]# [ 0.44664332 1.32015193 1.19064319 1.04832637 -1.35440087 1.46269107# -0.73073471 1.79925811 -0.81201482 -0.52865958]# [ 0.86693144 0.58485049 0.74763191 0.16709246 0.87199962 -0.01152798# -0.45584357 1.63553476 -0.97385317 0.22666731]# [ 0.88356006 0.02941392 0.48637423 0.6196385 0.72364163 0.73068076# 0.24449067 -1.82126474 0.43334225 -0.57979202]# [ 0.90533078 -0.46376067 1.15587556 -0.83500886 0.61234719 0.32427955# 1.49570584 -0.48938131 -1.18225038 0.19612415]# [ 0.66482532 1.62603843 0.83715767 0.93517244 -1.04942799 1.2456522# 1.45724511 0.82795757 -0.39859715 -1.37503803]# [ 0.84474677 -0.97584003 -0.23359941 0.02022619 0.15871523 0.07553232# -0.58795238 -1.66832328 -1.08443391 -0.25014412]# [ 0.00373921 0.82514638 -0.06235779 0.58550674 -0.90887821 -0.91024882# 0.57362115 -1.92959452 1.00629067 -0.69716936]]# None# (10, 10)# ------------------------------------------------------------# [[ 1. 1.]# [ 2. 2.]]","categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://wonius.github.io/categories/TensorFlow/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://wonius.github.io/tags/TensorFlow/"}]},{"title":"搭建shadowsocks服务","slug":"服务器搭建shadowsocks服务","date":"2018-05-06T05:53:55.000Z","updated":"2020-11-03T13:43:53.000Z","comments":true,"path":"2018/05/06/服务器搭建shadowsocks服务/","link":"","permalink":"https://wonius.github.io/2018/05/06/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAshadowsocks%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"安装shadowsocks服务Centos123sudo yum install python-pipsudo pip install shadowsockssudo pip install --upgrade pip Ubuntu12345sudo -sapt-get updateapt-get install python-pippip install shadowsockspip install --upgrade pip 配置文件123456789101112131415mkdir /etc/shadowsocksvim /etc/shadowsocks/ss.json//拷贝，别忘了改密码&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:443, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;XXXXXXX&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;:false, &quot;workers&quot;: 1&#125; server_port中配的端口，需要服务器上对外开放 启动12345678sudo /usr/local/bin/ssserver -c /etc/shadowsocks/ss.json -d startsudo /usr/local/bin/ssserver -c /etc/shadowsocks/ss.json -d stopsudo /usr/local/bin/ssserver -c /etc/shadowsocks/ss.json -d restart//设置开机自启vim /etc/rc.local//末尾添加sudo /usr/local/bin/ssserver -c /etc/shadowsocks/ss.json -d start","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://wonius.github.io/categories/shadowsocks/"}],"tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://wonius.github.io/tags/shadowsocks/"}]},{"title":"Vimium快捷键","slug":"Vimium快捷键","date":"2018-05-03T09:17:22.000Z","updated":"2018-05-03T09:19:17.000Z","comments":true,"path":"2018/05/03/Vimium快捷键/","link":"","permalink":"https://wonius.github.io/2018/05/03/Vimium%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"常用快捷键1234567891011121314151617向下/上/左/右移动 j/k/h/l向下/上跳动 d/u回到顶/尾部 gg/G窗口打开模式 本窗口/新窗口 f/F查找历史记录+书签 o/O关闭/恢复标签 x/X查找书签 b/B（当前/新窗口打开）选择左/右标签 J/K搜索剪贴板关键字 在当前/新窗口 p/P跳转到当前url上一级/最高级 gu/gU创建/查看标签页 t/T将焦点聚集在第一个输入框 gi (2gi就是第二个输入框)刷新 r新标签中打开多个链接 &lt;a-f&gt; 即：alt+f开/关静音 &lt;a-m&gt;即：alt+m固定标签栏 &lt;a-p&gt;即 alt+p上一个标签 ^ 不常用快捷键12345678910111213141516查找（不支持中文） / 向下/上查找结果 n/N (回车后直接打开链接，不用再使用f/F定位)复制当前链接 yy新模式 i查看源码 gs查看所以快捷键 ?编辑当前地址栏 g+e/E 并在当前/新窗口中打开复制当前标签页 yt移动当前标签到左/右侧边 &lt;&lt;/&gt;&gt;滚动到页面最左/右边（在有滚动条下才有效果） zH/zL插入模式 i（可以屏蔽掉vimium快捷键，使其不和网页默认快捷键冲突）将标签页移动到新窗口 W创建新标记（可创建多个 m 使用方法 设置当前/全局滚动条位置 m+小/大写字母 跳转到设置的滚动位置 ~+字母切换到复制模式 v 其他技巧12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152作者：小佐链接：https://www.zhihu.com/question/23483616/answer/246787555来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。焦点切换 从地址栏切换回页面 tag翻页 下/上一页 ]] [[ 部分网站不支持 可以使用 Shortcut Manager 插件代替 下一页代码： function next()&#123; var a=$(&quot;.cur&quot;).next().find(&quot;a&quot;).attr(&quot;href&quot;); window.location.assign(a); &#125; next(); 上一页代码： function after()&#123; var a=$(&quot;.cur&quot;).prev().find(&quot;a&quot;).attr(&quot;href&quot;); window.location.assign(a); &#125; after();自定义搜索引擎 设置： 请查看选项：Custom search engines 使用： 按b/B打开搜索框，输入搜索引擎关键字+空格 扩展： 计算功能 g (1+2)*3-4= 进入google搜索模式直接输入公式后面加&quot;=&quot;号打开chrome系统页面 chrome设置页面 about:setting 扩展程序 about:extensions 历史(history)，下载(downloads)，书签(bookmarks),建议使用chrome默认快捷键代替 ctrl+h,ctrl+j,ctrl+shift+o关于&lt;a-p&gt;,&lt;c-e&gt; 是emacs中的表示方法，分别指alt+p,ctrl+e快速定位+复制文本：alt+f,v,hjkl,y四步曲 alt+f 搜索指定关键字，并定位到起始点 再按v切换到复制模式 再使用hjkl控制方向选择范围 最后y复制删除/修改命令 删除指定命令 unmap j 删除命令j unmapAll 删除所有命令 修改命令（后面的命令参数可以在选择里面打开 show available commands找到） map a LinkHints.activateMode 把a定义原来f的功能 map f scrollPageDown 把f定义成原来d的功能本地文件中使用vimium 打开chrome插件设置页面，勾选&quot;允许访问文件网址&quot;","categories":[{"name":"Chrome","slug":"Chrome","permalink":"https://wonius.github.io/categories/Chrome/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://wonius.github.io/tags/Chrome/"}]},{"title":"SpringBoot集成Swagger2","slug":"SpringBoot集成Swagger2","date":"2018-04-27T07:57:56.000Z","updated":"2020-11-03T14:06:26.000Z","comments":true,"path":"2018/04/27/SpringBoot集成Swagger2/","link":"","permalink":"https://wonius.github.io/2018/04/27/SpringBoot%E9%9B%86%E6%88%90Swagger2/","excerpt":"","text":"增加denpendency12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt; 创建Swagger2配置类123456789101112131415161718192021222324@Configuration@EnableSwagger2public class Swagger2Config &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.springboot.controller&quot;)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;SpringBoot中使用Swagger2构建RESTful APIS&quot;) .description(&quot;更多SpringBoot相关文章请关注：http://wonius.top&quot;) .termsOfServiceUrl(&quot;http://wonius.top&quot;) .contact(&quot;Gavin&#x27;s Notes&quot;) .version(&quot;1.0&quot;) .build(); &#125;&#125; 🌰1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@RestController@RequestMapping(value = &quot;/users&quot;)@Api(tags = &quot;用户管理类&quot;)public class UserControllerWithSwagger2 &#123; static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;()); @ApiOperation(value = &quot;获取用户列表&quot;) @RequestMapping(value = &quot;/getUsers&quot;) public List&lt;User&gt; getUsers() &#123; return new ArrayList&lt;User&gt;(users.values()); &#125; @ApiOperation(value = &quot;创建用户&quot;, notes = &quot;根据User对象创建用户&quot;) @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户实体User&quot;, required = true, dataType = &quot;User&quot;) @RequestMapping(value = &quot;/postUser&quot;, method = RequestMethod.POST) public String postUser(@RequestBody User user) &#123; users.put(user.getId(), user); return &quot;success&quot;; &#125; @ApiOperation(value = &quot;获取用户信息&quot;, notes = &quot;根据id获取用户信息&quot;) @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户id&quot;, required = true, dataType = &quot;Long&quot;) @RequestMapping(value = &quot;/getUser&quot;) public User getUser(@PathVariable Long id) &#123; return users.get(id); &#125; @ApiOperation(value = &quot;更新用户详细信息&quot;, notes = &quot;根据id更新对应user&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户id&quot;, required = true, dataType = &quot;Long&quot;), @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户实体user&quot;, required = true, dataType = &quot;User&quot;) &#125;) @RequestMapping(value = &quot;/putUser&quot;, method = RequestMethod.POST) public String putUser(@PathVariable Long id, @RequestBody User user) &#123; User u = users.get(id); u.setHost(user.getHost()); u.setName(user.getName()); users.put(id, u); return &quot;success&quot;; &#125; @ApiOperation(value = &quot;删除用户&quot;, notes = &quot;根据id删除用户&quot;) @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户id&quot;, required = true, dataType = &quot;Long&quot;) @RequestMapping(value = &quot;/deleteUser&quot;, method = RequestMethod.DELETE) public String deleteUser(@PathVariable Long id) &#123; users.remove(id); return &quot;success&quot;; &#125;&#125; 之后访问http://localhost:8080/swagger-ui.html加载。 PS: method一定要写，不然swagger2会将该方法的所有method枚举一遍 常用注解@Api 用在请求的类上，说明该类的作用tags=”说明该类的作用”value=”该参数没什么意义，所以不需要配置” @ApiOperation用在请求的方法上，说明方法的作用value=”说明方法的作用” notes=”方法的备注说明” @ApiImplicitParams/@ApiImplicitParam 用在请求的方法上，请求参数说明@ApiImplicitParams：用在请求的方法上，包含一组参数说明​ @ApiImplicitParam：用在 @ApiImplicitParams 注解中，指定一个请求参数的配置信息​ name：参数名​ value：参数的汉字说明、解释​ required：参数是否必须传​ paramType：参数放在哪个地方​ · header –&gt; 请求参数的获取：@RequestHeader​ · query –&gt; 请求参数的获取：@RequestParam​ · path（用于restful接口）–&gt; 请求参数的获取：@PathVariable​ · body（不常用）​ · form（不常用）​ dataType：参数类型，默认String，其它值dataType=”Integer”​ defaultValue：参数的默认值 @ApiResponses/@ApiResponse用在请求的方法上，响应参数说明@ApiResponses：用于请求的方法上，表示一组响应​ @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息​ code：数字，例如400​ message：信息，例如”请求参数没填好”​ response：抛出异常的类 @ApiModel/@ApiModelProperty用在响应类上，表示响应数据的信息@ApiModel：用于响应类上，表示一个返回响应数据的信息​ （这种一般用在post创建的时候，使用@RequestBody这样的场景，​ 请求参数无法使用@ApiImplicitParam注解进行描述的时候）​ @ApiModelProperty：用在属性上，描述响应类的属性","categories":[{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/categories/Spring/"},{"name":"SpringBoot","slug":"Spring/SpringBoot","permalink":"https://wonius.github.io/categories/Spring/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wonius.github.io/tags/SpringBoot/"},{"name":"Swagger2","slug":"Swagger2","permalink":"https://wonius.github.io/tags/Swagger2/"}]},{"title":"SpringBoot集成TestNG","slug":"SpringBoot集成TestNG","date":"2018-04-27T03:21:06.000Z","updated":"2020-11-03T14:06:40.000Z","comments":true,"path":"2018/04/27/SpringBoot集成TestNG/","link":"","permalink":"https://wonius.github.io/2018/04/27/SpringBoot%E9%9B%86%E6%88%90TestNG/","excerpt":"","text":"增加dependency123456&lt;dependency&gt; &lt;groupId&gt;org.testng&lt;/groupId&gt; &lt;artifactId&gt;testng&lt;/artifactId&gt; &lt;version&gt;6.1.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 配置maven-surefire-plugin1234567891011&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;suiteXmlFiles&gt; &lt;suiteXmlFile&gt;$&#123;basedir&#125;/src/test/resources/MyTestNG.xml&lt;/suiteXmlFile&gt; &lt;/suiteXmlFiles&gt; &lt;!-- 不单独开线程启动test --&gt; &lt;forkMode&gt;never&lt;/forkMode&gt; &lt;/configuration&gt;&lt;/plugin&gt; 增加MyTestNG.xml12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot; &gt;&lt;suite name=&quot;Suite&quot;&gt; &lt;test name=&quot;test1&quot; verbose=&quot;2&quot;&gt; &lt;classes&gt; &lt;class name=&quot;com.springboot.testng.FirstTest&quot;&gt; &lt;methods&gt; &lt;include name=&quot;test&quot;&gt;&lt;/include&gt; &lt;/methods&gt; &lt;/class&gt; &lt;/classes&gt; &lt;/test&gt; &lt;test name=&quot;test2&quot; verbose=&quot;2&quot;&gt; &lt;groups&gt; &lt;run&gt; &lt;include name=&quot;testGroup&quot;&gt;&lt;/include&gt; &lt;/run&gt; &lt;/groups&gt; &lt;/test&gt;&lt;/suite&gt; 增加对应的类 注解常用注解就那么几个，可以见下面的文章 https://blog.csdn.net/dragonpeng2008/article/details/70820902","categories":[{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/categories/Spring/"},{"name":"SpringBoot","slug":"Spring/SpringBoot","permalink":"https://wonius.github.io/categories/Spring/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wonius.github.io/tags/SpringBoot/"},{"name":"TestNG","slug":"TestNG","permalink":"https://wonius.github.io/tags/TestNG/"}]},{"title":"SpringBoot集成MockServer","slug":"SpringBoot集成MockServer","date":"2018-04-25T15:25:25.000Z","updated":"2020-11-03T14:05:23.000Z","comments":true,"path":"2018/04/25/SpringBoot集成MockServer/","link":"","permalink":"https://wonius.github.io/2018/04/25/SpringBoot%E9%9B%86%E6%88%90MockServer/","excerpt":"","text":"背景最近项目中在引入Mock，其中有一项是屏蔽掉外部依赖，包括关联系统的REST接口。做了下技术调研，打算使用MockServer对外部接口进行mock 插件集成 在pom文件中增加mockserver的maven插件： 1234567891011121314151617181920212223242526272829&lt;plugin&gt; &lt;groupId&gt;org.mock-server&lt;/groupId&gt; &lt;artifactId&gt;mockserver-maven-plugin&lt;/artifactId&gt; &lt;version&gt;5.3.0&lt;/version&gt; &lt;configuration&gt; &lt;serverPort&gt;1080&lt;/serverPort&gt; &lt;!-- 可根据情况是否设置porxyPort。我没设置 --&gt; &lt;proxyPort&gt;1090&lt;/proxyPort&gt; &lt;logLevel&gt;DEBUG&lt;/logLevel&gt;&lt;!-- 该类为初始化类，按照自己的文件配置，即下一步中的类 --&gt; &lt;initializationClass&gt;org.mockserver.maven.ExampleInitializationClass&lt;/initializationClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 指定在该生命周期时调用该插件 --&gt; &lt;id&gt;process-test-classes&lt;/id&gt; &lt;phase&gt;process-test-classes&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;start&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;verify&lt;/id&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;stop&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 创建自己的MockServerInitializer类（类名一定不要定义为MockServerInitializer，官方有这个类），实现ExpectationInitializer接口： 12345678public class HttpMockServerInitializer implements ExpectationInitializer &#123; @Override public void initializeExpectations(MockServerClient mockServerClient) &#123; mockServerClient.when(HttpRequest.request().withMethod(&quot;POST&quot;).withPath(&quot;/test&quot;)) .respond(HttpResponse.response().withStatusCode(200).withBody(&quot;success&quot;)); &#125;&#125; PS：如果你在用idea编辑器，一定要打开idea的自动编译功能，默认该功能是不开启的。打开方式 运行mockserver服务： 1mvn mockserver:run 然后就可以使用postman请求，得到预设的返回。 代码手动创建插件集成比较方便，不过有些场景无法满足。比如需要在MockServer中注入Spring容器中的对象，当运行MockServer时，由于没有初始化Spring容器，导致注入失败。 这种情况就需要手动创建MockServer。 编辑pom.xml，导入依赖： 123456&lt;dependency&gt; &lt;groupId&gt;org.mock-server&lt;/groupId&gt; &lt;artifactId&gt;mockserver-netty&lt;/artifactId&gt; &lt;!-- 成文时最新版本，可以到官网查询目前最新版本 --&gt; &lt;version&gt;5.3.0&lt;/version&gt;&lt;/dependency&gt; 创建mockServer，proxy可不设： 12345678910111213141516171819202122232425262728293031//引入类import static org.mockserver.integration.ClientAndProxy.startClientAndProxy;import static org.mockserver.integration.ClientAndServer.startClientAndServer;/** * 使用@Service将该类注入spring，方便管理 * 实现InitializingBean接口，初始化类对象时，实例化mockServer对象 * 实现DisposableBean接口，销毁类对象时，关闭服务 */@Servicepublic class HttpMockServerManual implements InitializingBean, DisposableBean &#123; //创建对象 private ClientAndProxy proxy; private ClientAndServer mockServer; @Override public void destroy() throws Exception &#123; //别忘了关闭服务 proxy.stop(); mockServer.stop(); &#125; @Override public void afterPropertiesSet() throws Exception &#123; //实例化对象 mockServer = startClientAndServer(1080); proxy = startClientAndProxy(1090); &#125;&#125; mock相关http接口： 12mockServer.when(HttpRequest.request().withMethod(&quot;POST&quot;).withPath(&quot;/test&quot;)) .respond(HttpResponse.response().withStatusCode(200).withBody(&quot;success&quot;)); 更多详情参见官网本文只提供了java实现。官网还有JS等实现，请戳MockServer官网了解。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/categories/Spring/"},{"name":"SpringBoot","slug":"Spring/SpringBoot","permalink":"https://wonius.github.io/categories/Spring/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wonius.github.io/tags/SpringBoot/"},{"name":"MockServer","slug":"MockServer","permalink":"https://wonius.github.io/tags/MockServer/"}]},{"title":"SpringBoot常见报错","slug":"SpringBoot常见报错","date":"2018-04-18T06:50:55.000Z","updated":"2020-11-03T14:04:48.000Z","comments":true,"path":"2018/04/18/SpringBoot常见报错/","link":"","permalink":"https://wonius.github.io/2018/04/18/SpringBoot%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99/","excerpt":"","text":"Whitelabel Error Page这种情况一般是配置不对，仔细检查下。 另外，新手常犯的错误就是，使用@SpringBootApplication注解的Application类，需要与controller同级目录。因为默认从Application类当前目录向下的子目录里扫描。 Detected both xxx.jar and bound xxx.jar on the class pathjar包冲突，根据情况删除其中一个jar包。 由于springboot中很多包打包在一起，下面教大家如何看项目中的包分别包含哪些包： 1、使用idea中的Show Dependencies 打开View - Tool Windows - Maven Projects 点击后，生成包依赖视图 2、 如果你的idea没有这个功能，可以使用maven命令显示结构，是一个树状图 123456789101112131415161718192021222324252627282930313233343536373839404142mvn dependency:tree//生成结构如下：[INFO] com.springboot:myspringbootdemo:jar:0.0.1-SNAPSHOT[INFO] +- org.springframework.boot:spring-boot-starter-jdbc:jar:2.0.1.RELEASE:compile[INFO] | +- org.springframework.boot:spring-boot-starter:jar:2.0.1.RELEASE:compile[INFO] | | +- org.springframework.boot:spring-boot:jar:2.0.1.RELEASE:compile[INFO] | | +- org.springframework.boot:spring-boot-autoconfigure:jar:2.0.1.RELEASE:compile[INFO] | | +- org.springframework.boot:spring-boot-starter-logging:jar:2.0.1.RELEASE:compile[INFO] | | | +- ch.qos.logback:logback-classic:jar:1.2.3:compile[INFO] | | | | \\- ch.qos.logback:logback-core:jar:1.2.3:compile[INFO] | | | +- org.apache.logging.log4j:log4j-to-slf4j:jar:2.10.0:compile[INFO] | | | | \\- org.apache.logging.log4j:log4j-api:jar:2.10.0:compile[INFO] | | | \\- org.slf4j:jul-to-slf4j:jar:1.7.25:compile[INFO] | | +- javax.annotation:javax.annotation-api:jar:1.3.2:compile[INFO] | | \\- org.yaml:snakeyaml:jar:1.19:runtime[INFO] | +- com.zaxxer:HikariCP:jar:2.7.8:compile[INFO] | \\- org.springframework:spring-jdbc:jar:5.0.5.RELEASE:compile[INFO] | +- org.springframework:spring-beans:jar:5.0.5.RELEASE:compile[INFO] | \\- org.springframework:spring-tx:jar:5.0.5.RELEASE:compile[INFO] +- org.springframework.boot:spring-boot-starter-web:jar:2.0.1.RELEASE:compile[INFO] | +- org.springframework.boot:spring-boot-starter-json:jar:2.0.1.RELEASE:compile[INFO] | | +- com.fasterxml.jackson.core:jackson-databind:jar:2.9.5:compile[INFO] | | | +- com.fasterxml.jackson.core:jackson-annotations:jar:2.9.0:compile[INFO] | | | \\- com.fasterxml.jackson.core:jackson-core:jar:2.9.5:compile[INFO] | | +- com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.9.5:compile[INFO] | | +- com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.9.5:compile[INFO] | | \\- com.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.9.5:compile[INFO] | +- org.springframework.boot:spring-boot-starter-tomcat:jar:2.0.1.RELEASE:compile[INFO] | | +- org.apache.tomcat.embed:tomcat-embed-core:jar:8.5.29:compile[INFO] | | +- org.apache.tomcat.embed:tomcat-embed-el:jar:8.5.29:compile[INFO] | | \\- org.apache.tomcat.embed:tomcat-embed-websocket:jar:8.5.29:compile[INFO] | +- org.hibernate.validator:hibernate-validator:jar:6.0.9.Final:compile[INFO] | | +- javax.validation:validation-api:jar:2.0.1.Final:compile[INFO] | | +- org.jboss.logging:jboss-logging:jar:3.3.2.Final:compile[INFO] | | \\- com.fasterxml:classmate:jar:1.3.4:compile[INFO] | +- org.springframework:spring-web:jar:5.0.5.RELEASE:compile[INFO] | \\- org.springframework:spring-webmvc:jar:5.0.5.RELEASE:compile[INFO] | +- org.springframework:spring-aop:jar:5.0.5.RELEASE:compile[INFO] | +- org.springframework:spring-context:jar:5.0.5.RELEASE:compile[INFO] | \\- org.springframework:spring-expression:jar:5.0.5.RELEASE:compile","categories":[{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/categories/Spring/"},{"name":"SpringBoot","slug":"Spring/SpringBoot","permalink":"https://wonius.github.io/categories/Spring/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wonius.github.io/tags/SpringBoot/"}]},{"title":"Redis批量改名key","slug":"Redis批量改名key","date":"2018-04-13T03:04:12.000Z","updated":"2020-11-03T14:02:56.000Z","comments":true,"path":"2018/04/13/Redis批量改名key/","link":"","permalink":"https://wonius.github.io/2018/04/13/Redis%E6%89%B9%E9%87%8F%E6%94%B9%E5%90%8Dkey/","excerpt":"","text":"背景​ 最近接到一个任务，需要将redis中的key进行rename。之前的结构为XXX-XXX-XXX-*，替换为XXX:XXX:XXX:*。 思路&amp;方案​ 第一反应想到是用正则，匹配出对应的key，然后利用redis中也有rename命令，支持重命名。尽量都在redis中处理。 ​ 后来调研了一下，redis中没有类似于find的命令😩，唯一可用的是keys命令，所以调整方案，使用keys+pattern匹配出所有对应的key，流向shell，shell中对key循环，转换key名。 ​ 其中还有一个坑，keys虽然支持正则，但是貌似只支持*，?、+、^都不支持。库中新结构、老结构的数据都有，所以只能枚举了 脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//创建shell脚本vim rename.sh//拷贝如下内容#!/bin/bash##redis主机IPhost=127.0.0.1##redis端口port=6379##密码passwd=123456##pattern模式# patterns=(&quot;[a-zA-Z]*-[a-zA-Z0-9]*&quot; &quot;[a-zA-Z]-[a-zA-Z0-9]*-[a-zA-Z0-9]*&quot; &quot;[a-zA-Z]-[a-zA-Z0-9]*-[a-zA-Z0-9]*-*&quot;)patterns=(&quot;Answer-*-*-*&quot; &quot;FaqInfo-*-*&quot; &quot;ModelInfo-*-*&quot; &quot;RelatedFaq-*-*-*&quot; &quot;SensitiveWord-*&quot; &quot;Term-*-*-*&quot;)##备份redisredis-cli -h $host -p $port -a $passwd saveecho &#x27;备份至=&gt;&#x27;redis-cli -h $host -p $port -a $passwd config get dirfor p in $&#123;patterns[@]&#125; do ##循环获取key并删除 re=$(redis-cli -h $host -p $port -a $passwd --raw keys $p) echo $re ##转成数组 arr=($re) ##打印数组长度 echo &#x27;arr.len:&#x27;$&#123;#arr[@]&#125; ##循环数组 for key in $&#123;arr[@]&#125; do # echo $key # echo &quot;key:&quot;$key newKey=$(echo $&#123;key/\\-/\\:&#125;) newKey=$(echo $&#123;newKey/\\-/\\:&#125;) newKey=$(echo $&#123;newKey/\\-/\\:&#125;) echo $newKey redis-cli -h $host -p $port -a $passwd rename $key $newKey donedoneecho &#x27;done&#x27;//授执行权限chmod 777 rename.sh//执行sh rename.sh XXXX XX XX 恢复备份​ 脚本中会先将当前库中内容进行备份，备份到脚本运行目录中，文件名为dump.rdb。 恢复备份操作： 停止Redis服务：redis-cli shutdown； 将dump.rdb文件拷贝到redis安装目录下的bin目录（我的是/usr/local/Cellar/redis/3.2.9/bin）； 重启redis服务 redis-server &amp;;","categories":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://wonius.github.io/tags/Shell/"},{"name":"Redis","slug":"Redis","permalink":"https://wonius.github.io/tags/Redis/"}]},{"title":"MacOS搭建Aria2","slug":"MacOS搭建Aria2","date":"2018-03-30T06:09:16.000Z","updated":"2020-11-03T13:56:02.000Z","comments":true,"path":"2018/03/30/MacOS搭建Aria2/","link":"","permalink":"https://wonius.github.io/2018/03/30/MacOS%E6%90%AD%E5%BB%BAAria2/","excerpt":"","text":"安装Aria2安装MacOs安装Aria2十分简单，使用homebrew安装就可以 1brew install aria2 配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//创建配置目录mkdir ~/.aria2//编辑配置文件vim ~/.aria2/aria2.conf//将下面配置拷贝到aria2.conf中，并且修改dir为自己的下载目录#用户名#rpc-user=user#密码#rpc-passwd=passwd#上面的认证方式不建议使用,建议使用下面的token方式#设置加密的密钥#rpc-secret=token#允许rpcenable-rpc=true#允许所有来源, web界面跨域权限需要rpc-allow-origin-all=true#允许外部访问，false的话只监听本地端口rpc-listen-all=true#RPC端口, 仅当默认端口被占用时修改#rpc-listen-port=6800#最大同时下载数(任务数), 路由建议值: 3max-concurrent-downloads=5#断点续传continue=true#同服务器连接数max-connection-per-server=5#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要min-split-size=10M#单文件最大线程数, 路由建议值: 5split=10#下载速度限制max-overall-download-limit=0#单文件速度限制max-download-limit=0#上传速度限制max-overall-upload-limit=0#单文件速度限制max-upload-limit=0#断开速度过慢的连接#lowest-speed-limit=0#验证用，需要1.16.1之后的release版本#referer=*#文件保存路径, 默认为当前启动位置dir=/Users/woniu/Downloads#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本#disk-cache=0#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)#enable-mmap=true#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长#所需时间 none &lt; falloc ? trunc « prealloc, falloc和trunc需要文件系统和内核支持file-allocation=prealloc 运行aria21234aria2c//检查是否已启动ps aux|grep aria2c UI设置访问https://ziahamza.github.io/webui-aria2/ 然后点击设置-链接设置 将主机修改为：localhost 端口：6800 取消ssl/ssh的勾选 安装百度云插件下载百度插件，解压 在chrome浏览器中，设置-更多工具-扩展程序-开启开发者模式-加载已解压的拓展程序 安装之后，随便打开一个百度网盘的资源，发现多了一个导出下载的选项，里面有ARIA2 RPC，使用这个下载rpc文件，然后自动会使用aria2进行下载 安装迅雷插件（迅雷已屏蔽）该方案目前已经被迅雷屏蔽","categories":[{"name":"MacOS","slug":"MacOS","permalink":"https://wonius.github.io/categories/MacOS/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"https://wonius.github.io/tags/MacOS/"},{"name":"Aria2","slug":"Aria2","permalink":"https://wonius.github.io/tags/Aria2/"}]},{"title":"SSH通过Key登录服务器","slug":"SSH通过Key登录服务器","date":"2018-03-18T12:40:52.000Z","updated":"2020-11-03T14:09:56.000Z","comments":true,"path":"2018/03/18/SSH通过Key登录服务器/","link":"","permalink":"https://wonius.github.io/2018/03/18/SSH%E9%80%9A%E8%BF%87Key%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"服务器上创建访问用户该步为可选，根据个人需要创建。不推荐直接使用root用户。 12345678910# 创建用户adduser gavin# 设置密码passwd gavin# 增加sudo权限vim /etc/sudoers# 添加下行gavin ALL=(ALL) ALL 通常为了增加密码复杂度，我会用在线生成密码工具 生成密码 本机创建秘钥/公钥对（Key）网上很多帖子都直接用ssh-keygen，或者ssh-keygen -t rsa，这样会生成名为id_rsa的Key（默认名），这样当你每次需要生成新的Key时，会覆盖以前的。如果你的所有认证共用一组Key，也可以，不过不推荐。 下为用rsa算法，在~/.ssh/下生成名为id_rsa.qcloud，注释为qcloud的Key： 12# qcloud对应腾讯云，可以根据自己情况取名ssh-keygen -t rsa -f ~/.ssh/id_rsa.qcloud -C &quot;qcloud&quot; 然后一路Enter（可以选择输入passphrase） 12cd ~/.ssh/ll 查看生成的id_rsa.qcloud、id_rsa.qcloud.pub 将公钥拷贝到服务器私钥存本地，公钥放到服务器 123456789# 用gavin用户登录服务器，创建.ssh目录mkdir .ssh# 本机拷贝到服务器scp -r ~/.ssh/id_rsa.qcloud.pub gavin@XXX.XXX.XXX.XXX:/home/gavin/.ssh/authorized_keys# 修改服务器上.ssh、authorized_keys权限，仅当前用户可操作chmod 700 .sshchmod 600 .ssh/authorized_keys 服务器开启秘钥验证1234567891011vim /etc/ssh/sshd_config# 开启秘钥验证RSAAuthentication yesPubkeyAuthentication yes# 另外可以关闭密码验证PasswordAuthentication no# 重启服务service sshd restart 本机设置别名前面设置完，就可以无密码登录了。不过每次都要输入服务器ip，比较反人类。可以进一步设置别名，使体验更友好。 12345678vim /etc/ssh/ssh_config (或者~/.ssh/ssh_config)# 添加，保存退出Host qcloudHostName XXX.XXX.XXX.XXXUser gavinIdentitiesOnly yesIdentityFile ~/.ssh/id_rsa.pub 如此设置之后，就可以直接ssh qcloud登录，方便快捷。","categories":[{"name":"运维","slug":"运维","permalink":"https://wonius.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wonius.github.io/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"https://wonius.github.io/tags/SSH/"}]},{"title":"Docker常用方法","slug":"Docker","date":"2018-03-18T05:24:40.000Z","updated":"2020-11-03T13:48:02.000Z","comments":true,"path":"2018/03/18/Docker/","link":"","permalink":"https://wonius.github.io/2018/03/18/Docker/","excerpt":"","text":"安装Docker1234567891011//源中有，直接yum安装yum install docker-io -y//查看docker版本docker -v//启动service docker start//设置开机自启chkconfig docker on 配置Docker123456//设置腾讯云镜像源echo &quot;OPTIONS=&#x27;--registry-mirror=https://mirror.ccs.tencentyun.com&#x27;&quot; &gt;&gt; /etc/sysconfig/docker//重新加载服务，重启systemctl daemon-reloadservice docker restart 安装镜像12345//拉取一个centos镜像docker pull centos//查看docker中有的镜像docker images 运行镜像1234567891011//运行docker容器中的centos，并使用bash shelldocker run -it centos /bin/bash//直接运行镜像docker run -it -p port:port centos//登录后可以按自己需要做操作······//退出镜像exit 保存镜像12345//查看容器信息，获取容器iddocker ps -a//保存docker commit -m=&quot;你的备注&quot; 容器id 镜像id 打包镜像1234docker build -t imageName .// 查看镜像docker images | grep imageName 删除镜像12345678910111213docker images docker rmi imageid// 如果已经运行，先删除容器iddocker ps -adocker rm containeriddocker rmi imageid// 如果有镜像from该镜像，先删除子镜像(报image has dependent child images)// 查看有哪些依赖子镜像docker image inspect --format=&#x27;&#123;&#123;.RepoTags&#125;&#125; &#123;&#123;.Id&#125;&#125; &#123;&#123;.Parent&#125;&#125;&#x27; $(docker image ls -q --filter since=*****)// 删除子镜像docker rmi *** *** *** Tips: 如果镜像被覆盖，导致后面的tag为&lt;none&gt;，无法对其进行操作的话： docker tag imgId xxxxx docker rmi xxxxx 导入、导出镜像1234567# export &amp; import（容器操作）docker export -o xxx.tar xxxid(容器id)cat xxx.tar | docker import - xxxname(镜像名xxx/xxx:1.0)# save &amp; load（镜像操作）docker save -o xxx.tar xxxid(容器id)docker load -I xxx.tar 镜像仓库12345678# 登录远程仓库docker login hub.yun.***** -u xxx# 推送镜像到远程仓库，需先登录docker push imageName# 查看远程仓库中的镜像docker search imageName Dockerfile语法12345678910111213141516171819202122232425262728293031323334353637383940//拉取基础镜像FROM &lt;IMAGE&gt;//设置镜像作者MAINTAINER &lt;NAME&gt; &lt;EMAIL&gt;//为后续的 RUN 、 CMD 、 ENTRYPOINT 指定工作目录WORKDIR &lt;PATH&gt;//创建镜像时执行RUN &lt;COMMAND&gt;//镜像创建成功后，在镜像中执行。如果有多条，只执行最后一条。可被docker run覆盖CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]使用exec执行，推荐 CMD command param1 param2，在/bin/sh上执行 CMD [&quot;param1&quot;, &quot;param2&quot;] 提供给ENTRYPOINT做默认参数。//与CMD类似。不可被docker run覆盖，除非加上--entrypointENTRYPOINT command param1 param2//复制，src可以为Dockerfile所在目录的相对路径，也可以是url。如果是url，会下载并复制到dest；可自动解压ADD &lt;SRC&gt; &lt;DEST&gt;//复制，src为Dockerfile所在目录的相对路径COPY &lt;SRC&gt; &lt;DEST&gt;//容器暴露的端口号。多个以空格间隔EXPOSE &lt;PORT&gt;//设置环境变量ENV &lt;KEY&gt; &lt;VALUE&gt;//指定运行容器时的用户名或UID，后续的RUN、CMD、ENTRYPOINT使用该用户USER daemon//在主机上创建一个挂载，挂载到容器的指定路径。不如docker run -v强大VOLUME &lt;PATH&gt;//其他镜像FROM该镜像时，执行ONBUILD [INSTRUCTION] 举个🌰 1234567891011FROM centosMAINTAINER nobody &quot;xx@163.com&quot;RUN mkdir -p /opt/jdk/RUN mkdir -p /opt/tomcat/ADD jdk1.7.0_79 /opt/jdk/ADD tomcat /opt/tomcat/ENV CATALINA_HOME /opt/tomcatENV JAVA_HOME /opt/jdkEXPOSE 8080ENV PATH $PATH:$JAVA_HOME/binCMD [&quot;/opt/tomcat/bin/catalina.sh&quot;,&quot;run&quot;]","categories":[{"name":"Docker","slug":"Docker","permalink":"https://wonius.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://wonius.github.io/tags/Docker/"}]},{"title":"NodeJs更换npm源","slug":"NodeJs更换npm镜像","date":"2018-03-17T14:43:02.000Z","updated":"2020-11-03T14:01:32.000Z","comments":true,"path":"2018/03/17/NodeJs更换npm镜像/","link":"","permalink":"https://wonius.github.io/2018/03/17/NodeJs%E6%9B%B4%E6%8D%A2npm%E9%95%9C%E5%83%8F/","excerpt":"","text":"​ 最近在做一些Node的应用，安装模块时官方的源不仅速度慢，很多模块无法下载（科学上网也不行）。没办法╮(╯_╰)╭，只好换成taobao源，整理了几种方法。 使用一次12//使用一次安装express服务npm --registry https://registry.npm.taobao.org install express 永久替换12345678//可以先查看原来的源地址，做好备份npm get registry//将npm源直接替换npm config set registry https://registry.npm.taobao.org//换回官方源npm config set registry https://registry.npmjs.org 同时使用npm、cnpm12345//安装cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org//之后可以使用cnpm安装服务，不影响npmcnpm install express","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://wonius.github.io/categories/Frontend/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://wonius.github.io/tags/NodeJs/"}]},{"title":"技能图谱-Apollo自动驾驶","slug":"技能图谱-Apollo自动驾驶","date":"2018-03-17T13:22:29.000Z","updated":"2018-03-24T09:47:05.000Z","comments":true,"path":"2018/03/17/技能图谱-Apollo自动驾驶/","link":"","permalink":"https://wonius.github.io/2018/03/17/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1-Apollo%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/","excerpt":"","text":"​ 今年参加AICon大会时，参与活动获得了一些知识图谱手册，在这里分享给大家","categories":[{"name":"技能图谱","slug":"技能图谱","permalink":"https://wonius.github.io/categories/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/"}],"tags":[{"name":"Apollo","slug":"Apollo","permalink":"https://wonius.github.io/tags/Apollo/"},{"name":"技能图谱","slug":"技能图谱","permalink":"https://wonius.github.io/tags/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/"}]},{"title":"技能图谱-大数据","slug":"技能图谱-大数据","date":"2018-03-17T13:22:00.000Z","updated":"2018-03-24T09:47:25.000Z","comments":true,"path":"2018/03/17/技能图谱-大数据/","link":"","permalink":"https://wonius.github.io/2018/03/17/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1-%E5%A4%A7%E6%95%B0%E6%8D%AE/","excerpt":"","text":"​ 今年参加AICon大会时，参与活动获得了一些知识图谱手册，在这里分享给大家","categories":[{"name":"技能图谱","slug":"技能图谱","permalink":"https://wonius.github.io/categories/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/"}],"tags":[{"name":"技能图谱","slug":"技能图谱","permalink":"https://wonius.github.io/tags/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/"},{"name":"大数据","slug":"大数据","permalink":"https://wonius.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"技能图谱-机器学习","slug":"技能图谱-机器学习","date":"2018-03-17T13:21:44.000Z","updated":"2018-05-12T14:12:32.000Z","comments":true,"path":"2018/03/17/技能图谱-机器学习/","link":"","permalink":"https://wonius.github.io/2018/03/17/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"​ 今年参加AICon大会时，参与活动获得了一些知识图谱手册，在这里分享给大家","categories":[{"name":"技能图谱","slug":"技能图谱","permalink":"https://wonius.github.io/categories/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/"}],"tags":[{"name":"ML","slug":"ML","permalink":"https://wonius.github.io/tags/ML/"},{"name":"技能图谱","slug":"技能图谱","permalink":"https://wonius.github.io/tags/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/"}]},{"title":"技能图谱-前端","slug":"技能图谱-前端","date":"2018-03-17T13:16:18.000Z","updated":"2018-03-24T09:47:12.000Z","comments":true,"path":"2018/03/17/技能图谱-前端/","link":"","permalink":"https://wonius.github.io/2018/03/17/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1-%E5%89%8D%E7%AB%AF/","excerpt":"","text":"​ 今年参加AICon大会时，参与活动获得了一些知识图谱手册，在这里分享给大家","categories":[{"name":"技能图谱","slug":"技能图谱","permalink":"https://wonius.github.io/categories/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/"}],"tags":[{"name":"技能图谱","slug":"技能图谱","permalink":"https://wonius.github.io/tags/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/"},{"name":"前端","slug":"前端","permalink":"https://wonius.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"AWS免费EC2创建记录","slug":"AWS免费EC2创建记录","date":"2018-03-17T06:30:26.000Z","updated":"2018-04-23T12:46:51.000Z","comments":true,"path":"2018/03/17/AWS免费EC2创建记录/","link":"","permalink":"https://wonius.github.io/2018/03/17/AWS%E5%85%8D%E8%B4%B9EC2%E5%88%9B%E5%BB%BA%E8%AE%B0%E5%BD%95/","excerpt":"","text":"注册AWS账号如果没有AWS账号，请先注册。注意AWS账号与Amazon商城是两套账号系统，不能共用。AWS主页 选择机房选择加州机房，速度快： 选择系统镜像注意选择免费套餐： 选择实例同样，选择免费套餐： 实例配置默认配置就可以： 设置存储默认5G，可以调整到30G： 设置标签即实例标签，用来区分不同实例。这里我添加了Name标签，并为该实例命名： 设置安全组设置开放的接口，将常用的ssh、http、https协议开放： 设置秘钥对设置秘钥对，并下载。使用ssh访问服务器时用于校验： SSH访问创建完成后，查看创建好的实例，系统会介绍如何通过ssh访问服务器。将上一步下载好的pem文件保存到本地，设置权限，并在该目录下使用命令进行链接： 每次都要到pem所在目录访问，比较麻烦。可以将pem加入到ssh中，就可以在任何目录下访问了(别忘了先将pem文件权限修改为400)： 连接服务器：","categories":[{"name":"云服务器","slug":"云服务器","permalink":"https://wonius.github.io/categories/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"https://wonius.github.io/tags/AWS/"}]},{"title":"Java常见报错","slug":"Java常见报错","date":"2018-03-06T12:07:22.000Z","updated":"2020-03-25T03:23:44.000Z","comments":true,"path":"2018/03/06/Java常见报错/","link":"","permalink":"https://wonius.github.io/2018/03/06/Java%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99/","excerpt":"","text":"List(Arrays.asList)后add或remove出现UnsupportedOperationException当使用Arrays.asList()，将Array转换为List后，如果使用List.add()、List.remove()方法，会报改错。 根本原因是转换后创建的对象是一个ArrayList对象，该对象集成了AbstractList，没有实现add、remove方法，所以使用的时候会报错。 改正： new ArrayList&lt;&gt;(Arrays.asList());","categories":[{"name":"Java","slug":"Java","permalink":"https://wonius.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wonius.github.io/tags/Java/"}]},{"title":"CentOS安装NodeJS","slug":"CentOS安装NodeJS","date":"2018-02-06T03:09:48.000Z","updated":"2020-11-03T13:44:53.000Z","comments":true,"path":"2018/02/06/CentOS安装NodeJS/","link":"","permalink":"https://wonius.github.io/2018/02/06/CentOS%E5%AE%89%E8%A3%85NodeJS/","excerpt":"","text":"​ 最近需要在服务器上安装nodejs，网上搜了一下，文章都是转来转去，都出到9.x版本了还在讲如何装6.x，很无语。所以自己整理一下。 选择合适的版本​ yum安装自带nodjs版本太低，到node源码版本上选择合适的版本，我安装了最新版本，9.x 1curl -sL https://rpm.nodesource.com/setup_9.x | bash - 安装1yum install -y nodejs 检查node、npm版本12node -vnpm -v one more thing​ 除了在线安装，还有下载安装包、加压、编译安装的方法，操作繁琐，不推荐。","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://wonius.github.io/categories/Frontend/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://wonius.github.io/tags/NodeJs/"}]},{"title":"阿里云ECS升级HTTPS","slug":"阿里云ECS升级HTTPS","date":"2018-02-05T16:29:32.000Z","updated":"2020-11-03T13:42:24.000Z","comments":true,"path":"2018/02/06/阿里云ECS升级HTTPS/","link":"","permalink":"https://wonius.github.io/2018/02/06/%E9%98%BF%E9%87%8C%E4%BA%91ECS%E5%8D%87%E7%BA%A7HTTPS/","excerpt":"","text":"背景​ 最近系统准备开发小程序，增加流量入口，而小程序的后端接口需要支持https协议，顺便给网站安全升下级。 制作证书​ 阿里云上有证书服务，填写完整信息可以在线制作，省时省力。登录阿里云后，点开安全（云盾）- CA证书服务，点击右上角购买证书，填写信息，域名验证类型选择DNS，因为域名也是在阿里买的，所以勾上自动完成域名授权验证，完成。很快，10min左右就审核通过了。 配置安全组​ 在ECS中点击管理实例，添加安全组规则，公网入方向中加入443/443，地址段为0.0.0.0/0。 防火墙打开443端口​ 打开防火墙端口 123456# 编辑vim /etc/sysconfig/iptables# 添加记录-A INPUT -p tcp -m tcp --dport 443 -j ACCEPT # 重启服务service iptables restart Nginx配置​ 将证书下载，在服务器上nginx目录下建立/cert，将证书解压，scp到/cert目录下： 123456789101112131415161718192021222324252627282930#在conf.d下建立单独conf文件vim ssl.yuming.conf#增加如下配置server &#123; listen 443; server_name 域名; ssl on; root html; index index.html; ssl_certificate /etc/nginx/cert/XXXXXXXXXX.pem; ssl_certificate_key /etc/nginx/cert/XXXXXXXXXXX.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL; ssl_prefer_server_ciphers on; #需要加上，一开始没加，访问一直404，找了半天原因 location / &#123; proxy_pass http://localhost:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; #与下方tomcat配置对应，解决request.getScheme()问题。不需要可以不用配 &#125;&#125;# 重启nginxservice nginx restart Tomcat配置​ 做完上面的配置之后，可以通过https协议访问网站，不过代码中使用request.getScheme()取到的协议仍是http，不是https，有报错，还需在server.xml中的Engine模块中添加，需重启。 1234&lt;Valve className=&quot;org.apache.catalina.valves.RemoteIpValve&quot; remoteIpHeader=&quot;X-Forwarded-For&quot; protocolHeader=&quot;X-Forwarded-Proto&quot; protocolHeaderHttpsValue=&quot;https&quot;/&gt; one more thing​ 如果需要将所有请求强制使用https协议，在监听80端口处增加如下配置： 1rewrite ^(.*)$ https://$&#123;server_name&#125;$1 permanent;","categories":[{"name":"安全","slug":"安全","permalink":"https://wonius.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://wonius.github.io/tags/SSL/"}]},{"title":"SSH连接保持会话","slug":"SSH连接保持会话","date":"2018-02-03T06:02:23.000Z","updated":"2020-11-03T14:08:45.000Z","comments":true,"path":"2018/02/03/SSH连接保持会话/","link":"","permalink":"https://wonius.github.io/2018/02/03/SSH%E8%BF%9E%E6%8E%A5%E4%BF%9D%E6%8C%81%E4%BC%9A%E8%AF%9D/","excerpt":"","text":"会话保持​ 相信玩服务器的朋友都遇到过这个问题，终端里的ssh连接服务器经常超时，自动断开链接； 而又不想专门下载一个ssh客户端，一方面是因为安全问题，另一方面是觉得有些鸡肋。所以查了一下能否将ssh的会话保持住，不自动断开连接，还真有。 ​ 主要有两个参数： 1234#发送保持活跃的数据包时间间隔，单位为秒，默认300秒ServerAliveInterval 60 #系统ssh服务维持最大的保活连接数量，默认是3ServerAliveCountMax 10 ​ 如果需要更改全部用户的设置，修改/etc/ssh/ssh_config中的文件； ​ 如果只改某一个用户中的设置，修改~/etc/ssh/ssh_config中的文件； PS: Host * :Host后面加的是服务器ip、ip端，*代表所有服务器 设置别名​ 为经常访问的服务器设置别名，就不用每次都写全信息了。同样，还是编辑ssh_config文件 123456789//添加，后保存退出Host prdHostName 120.52.145.22User logIdentitiesOnly yesIdentityFile ~/.ssh/id_rsa.pub//使用别名登录(如果不行重启下ssh服务:sudo service ssh reload)ssh prd 其中，Host、HostName、User为必须，其他可以根据自己需要配置。各属性含义如下： Host 别名 HostName 指定登录的主机名或IP地址 Port 指定登录的端口号 User 登录用户名 IdentityFile 登录的公钥文件（如果是pem文件，可以将pem添加到ssh，ssh-add命令） IdentitiesOnly 只接受SSH key 登录 PubkeyAuthentication","categories":[{"name":"运维","slug":"运维","permalink":"https://wonius.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wonius.github.io/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"https://wonius.github.io/tags/SSH/"}]},{"title":"Mysql常见问题","slug":"Mysql常见问题","date":"2018-01-30T14:21:12.000Z","updated":"2020-11-03T13:57:05.000Z","comments":true,"path":"2018/01/30/Mysql常见问题/","link":"","permalink":"https://wonius.github.io/2018/01/30/Mysql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"ERROR 1044 (42000): Access denied for user ‘‘@’localhost’ to database ‘XXX’​ 今天在DB里用普通用户做操作时，会报这个错误。主要是因为user表中有匿名用户，将匿名用户删除就可以了。 12345678910111213141516#首先进入mysqlmysql -uroot -p#切换到mysql数据库user mysql;#查看当前用户select host, user, password from user;#删除匿名用户delete from user where user=&#x27;&#x27;;#写入flush privileges;#退出\\q#重启服务service mysqld restart ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: YES)​ 一般由于密码错误，或者有用户没有密码的情况。 可以先设置成无密码模式进入，再将有问题的用户进行调整。 1234567891011121314151617181920212223#修改my.cnfvim /etc/my.cnf#在[mysqld]中加入skip-grant-tables#保存退出后，重启mysqlservice mysqld restart#无需密码直接进入mysql#先看一下用户的状态，在判断要做什么操作select user, password, host from mysql.user;#删除不需要的用户drop from mysql.user where password=&#x27;&#x27;;#或者更新用户密码update mysql.user set password=password(&quot;你的新密码&quot;) where user=&quot;XXX&quot;;#写入flush privileges;#退出\\q#重启服务service mysqld restart","categories":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://wonius.github.io/tags/Mysql/"}]},{"title":"Mysql迁移","slug":"Mysql迁移","date":"2018-01-24T03:05:46.000Z","updated":"2020-11-03T13:58:07.000Z","comments":true,"path":"2018/01/24/Mysql迁移/","link":"","permalink":"https://wonius.github.io/2018/01/24/Mysql%E8%BF%81%E7%A7%BB/","excerpt":"","text":"背景​ 生产环境上的Mysql服务器资源有限，需要迁移到另外一台资源更多的服务器。 准备工作 新服务器安装mysql（如果本身有Mysql，重装Mysql，一定要重启服务; 将mysql服务加入到开机自启列表; 停服，备份数据; 开始 目标服务器上新建Mysql用户、数据库； 传输备份脚本； 刚开始使用scp命令将备份脚本传输到目标服务器，使用Mysql命令恢复DB。备份脚本500多M，压缩后150多，采用这种方式实在是太慢。 摸索其他方式，最后通过Mysql Workbench里的Schema Transfer Wizard功能进行同步，大大缩短了同步时间。 应用连接Mysql进行验证，成功； 调优​ 迁移到新服务器之后，检测到应用响应时间过长，主要是因为数据库返回比较慢。对Mysql进行调优，主要是开启Mysql查询缓存，应用恢复正常响应速度。下面列举一些常用配置 查询缓存的设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#查看查询缓存的设置#如下参数都可是使用 select @@global.XXXX; 单独查询show variables like &#x27;%query_cache%&#x27;;hava_query_cache 查询缓存是否可用，YES/NOquery_cache_limit 缓存大小，超过该值不会进行缓存，默认1Mquery_cache_min_res_unit 双刃剑，默认4KB，设置值大对大数据查询有好处，如果都是小数据查询，易造成内存碎片和浪费query_cache_size 缓存内存大小。 设置方法：set @@global.query_cache_size=1000000; query_cache_type 查询缓存是否使用，OFF(0)/ON(1)/DEMAND(2) 当DEMAND时，必须使用SQL_CACHE关键字才会缓存，如select SQL_CACHE user_name from user; 当ON时，不想使用缓存使用sql_no_cache关键字，如select sql_no_cache user_name from user;另外，SQL中有用到mysql函数也不会缓存。 设置方法： set session query_cache_type=off; query_cache_wlock_invalidate #查看查询缓存的状态show status like &#x27;%Qcache%&#x27;;Qcache_free_blocks 目前处于空闲状态的 Query Cache中内存Block数量Qcache_free_memory 目前处于空闲状态的 Query Cache内存总量Qcache_hits Query Cache 命中次数Qcache_inserts 向 Query Cache中插入新的 Query Cache的次数，即没命中的次数Qcache_lowmem_prunes 当 Query Cache内存容量不走，删除老的 Query Cache给新对象的次数Qcache_not_cached 没有被Cache的SQL数，包含无法被Cache的SQL、由于query_cache_type设置不会被Cache的SQLQcache_queries_in_cache 目前 Query Cache中的SQL数量Qcache_total_blocks Query Cache中总Block数量#调优1. query_cache_min_res_unit的设置query_cache_min_res_unit = (query_cache_size - Qcache_free_memory)/ Qcache_queries_in_cache2. Qcache_Lowmem_prunes值较大，说明查询缓存区较小，需调大；3. Qcache_free_blocks 较多，说明内存碎片较多，需清理，FLUSH QUERY CACHE4. 查询缓存碎片率： Qcache_free_blocks / Qcache_total_blocks * 100%该值超过20%，使用FLUSH QUERY CACHE整理缓存碎片，或者调小query_cache_min_res_unit5. 查询缓存利用率：(query_cache_size - Qcache_free_memory) / query_cache_size * 100%该值在25%以下，说明query_cache_siz设置过大，可适当减小；该值在80%以上，且Qcache_lowmem_prunes &gt; 50，说明query_cache_siz有点小，或者碎片太大；6. 查询缓存命中率：(Qcache_hits - Qcache_inserts) / Qcache_hits * 100%该值较低，说明写操作比较频繁，或者有些碎片 其他配置 大部分应用，设置查询缓存的配置就可以满足需要了，如果不够可以设置其他参数 http://blog.csdn.net/nightelve/article/details/17393631 one more thing还有一点需要注意，有时设置了各项参数调整之后，Mysql反应还是很慢，这时候可以查看磁盘使用情况，有可能是磁盘容量不够，限制了读写导致查询效率低。","categories":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://wonius.github.io/tags/Mysql/"},{"name":"运维","slug":"运维","permalink":"https://wonius.github.io/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"工欲善其事，必先利其器","slug":"工欲善其事，必先利其器","date":"2018-01-20T06:02:49.000Z","updated":"2018-10-02T01:49:23.000Z","comments":true,"path":"2018/01/20/工欲善其事，必先利其器/","link":"","permalink":"https://wonius.github.io/2018/01/20/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%EF%BC%8C%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/","excerpt":"","text":"MacOS 软件 简介 Typora md编辑利器，MacWeb也不错 番茄土豆(Pomotodo) 番茄钟+todoList，全平台支持 CheatSheet 所有软件快捷键，一查便知 IINA 视频播放器 ShadowsocksX 科学上网软件，需配置ss服务器 CleanMyMac 相当于电脑管家 VSSH、 SecureCRT for mac、 ssh tunnel mac、 SSH Shell for Mac ssh客户端 XMind ZEN 思维导图 PDF Expert PDF工具 HazeOver 专注办公软件。简而言之可以让你专注在激活窗口 Fliqlo 数字时钟屏保 截图 如其名，其实自带的快捷键也很好用，不过不能编辑 Franz 多通讯工具整合软件，支持WeChat、twitter、telegram、github、steam、facebook等。均为网页版登录。 Alfred2 快捷访问 Airmail 邮件客户端 iOS App 简介 AppSo App推荐平台，而且经常会有iOS限免通知 XMind 思维导图软件 SsrConnectPro 科学上网软件，需配置ss服务器。之前用openwingy，可惜中国区下架了 Seed 英文资讯App，可以一键翻译中文 Podcasts iOS自带 Lingvist 英语单词学习软件 Seed 英文资讯软件，一键中英文对照 行程助手 旅游行程软件，可以帮助生成行程单，而且可以加好友共享 Android App 简介 影梭(shadowsocks) 科学上网软件，需配置ss服务器 AirDroid（多平台） 跨平台文件传输工具 滴答清单 todo-list类App Win App 简介 everything 本地文件搜索软件，自带搜索秒成渣 Clover 文件窗口合并，还可以添加书签 Chrome App 简介 Secure Shell SSH插件 Vimium 通过vim方式控制浏览器 剪藏 使用印象笔记的都有吧 油猴 js脚本管理器，很多脚本 公众号 App 简介 36氪 互联网资讯 差评 比较杂，什么专题都有 鼠绘漫画网 漫画 混子曰 漫画看历史、聊车。不过现在好久才推一篇文章 旅行雷达 旅行类 少数派 会推一些App、以及使用文章 AI前线 AI类文章","categories":[{"name":"工具","slug":"工具","permalink":"https://wonius.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://wonius.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Mysql重装后无法正常启动","slug":"Mysql重装后无法正常启动","date":"2018-01-17T14:23:19.000Z","updated":"2020-11-03T13:58:39.000Z","comments":true,"path":"2018/01/17/Mysql重装后无法正常启动/","link":"","permalink":"https://wonius.github.io/2018/01/17/Mysql%E9%87%8D%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8/","excerpt":"","text":"背景​ 最近在做服务器上的DB迁移，服务器上的Mysql重新安装后无法正常启动服务，查看版本信息正常。 ​ 当使用mysql -uroot -p命令登录时，报 1ERROR 2002 (HY000): Can&#x27;t connect to local MySQL server through socket &#x27;/var/lib/mysql/mysql.sock&#x27; (2) ​ 怀疑服务没有启动，启动服务时service mysqld start，报 123MySQL Daemon failed to start.Starting mysqld: [FAILED] 处理​ 百度了一下，有的说没有权限，需要授权，有的说需要在/etc/my.cnf中加配置。试过都不行。最后尝试将mysql所有文件删掉，杀掉所有进程重启，终于成功。 1234567//删除文件、自启服务、杀掉进程rm -rf /var/lib/mysql/rm /var/lock/subsys/mysqldkillall mysqld//启动服务service mysqld start one more thing​ 除了以上情况出现“ERROR 2002 (HY000) Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ (2)”报错，还有另外一种情况，已经安装好mysql服务，然后将mysql移动到另外的目录，启动mysql时找不到mysql.sock，是因为my.cnf中配置的路径还是原来的目录，将my.cnf中的配置修改就可以了 12345678910#编辑my.cnf，事先可以使用cp命令备份vim /etc/my.cnf#修改新的目录，我的是/data1/mysql[mysqld]datadir=/data1/mysqlsocket=/data1/mysql/mysql.sock[mysql]socket=/data1/mysql/mysql.sock","categories":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://wonius.github.io/tags/Mysql/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2018-01-16T13:58:57.000Z","updated":"2020-11-03T13:54:57.000Z","comments":true,"path":"2018/01/16/Linux常用命令/","link":"","permalink":"https://wonius.github.io/2018/01/16/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"cat12345678910111213//查看前1000行head -n 1000 filename//查看后1000行tail -n 1000 filename//查看1000之后tail -n +1000 filename//实时查看tail -f filename//查看最后1000行数据cat filename | tail -n 1000//查看1000到3000行的数据cat file | head -n 3000 | tail -n +1000 grep12345678//匹配文件中所有foo关键字上下1000行grep -C 1000 foo filename//匹配文件中所有foo关键字及前1000行grep -B 1000 foo filename//匹配文件中所有foo关键字及后1000行grep -A 1000 foo filename sed12//显示第1000到3000行的数据sed -n &#x27;1000,3000p&#x27; filename find-文件搜索1find / -name filename ps-查找进程123ps -ef | grep XXXkill -9 pid scp-跨服务器拷贝1scp file user@localhost:dir tar-压缩、解压 压缩 12345678910111213#只打包tar -cvf file.tar file#使用gzip压缩，再打包tar -czf file.tar.gz file#使用bzip2压缩，再打包tar -cjf file.tar.bz2 file#使用compress压缩，再打包tar -cZf file.tar.Z file#rar压缩,需先安装rar服务rar a file.rar file#zip压缩，需先安装zip服务zip file.zip file 解压 12345678910111213#解压常规包tar -xvf file.tar#解压gzip包tar -xzvf file.tar.gz#解压bzip2包tar -xjvf file.tar.bz2#解压compress包tar -xZvf file.tar.Z#解压rarunrar e file.rar#解压zipunzip file.zip 参数解析 12345678910111213141516#必须参数，且只能选一个-c: 建立压缩文档-x: 解压-t: 查看文件-r: 压缩文件末尾追加文件-u: 更新原压缩文件中的文件#可选参数，根据需要添加-z: gzip-j: bz2-Z: compress-v: 显示所有过程-O: 将文件解开到标准输出#必选参数-f: 在所有参数最后，后面接文档名 创建软连接12#源文件指要被链接的文件，目标文件指新建的软连接ln -s 源文件 目标文件 匹配进程并kill12//查找hello相关进程并killps -ef |grep hello |awk &#x27;&#123;print $2&#125;&#x27;|xargs kill -9 sed: 替换文本12//将book替换为bookssed &#x27;s/book/books/g&#x27; file 查看文件大小1234567891011# 磁盘使用情况df -h# 显示所有文件(包含子目录)du -ah# 只显示/rootdu -ah /root# 显示总计du -sh *","categories":[{"name":"Linux","slug":"Linux","permalink":"https://wonius.github.io/categories/Linux/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://wonius.github.io/tags/Shell/"},{"name":"Linux","slug":"Linux","permalink":"https://wonius.github.io/tags/Linux/"}]},{"title":"02创建Android Things工程","slug":"02创建Android-Things工程","date":"2018-01-16T13:52:14.000Z","updated":"2020-11-03T14:13:39.000Z","comments":true,"path":"2018/01/16/02创建Android-Things工程/","link":"","permalink":"https://wonius.github.io/2018/01/16/02%E5%88%9B%E5%BB%BAAndroid-Things%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"https://partner.android.com/things/console/#/ https://developer.android.com/things/training/first-device/create-studio-project.html https://developer.android.com/studio/projects/create-project.html","categories":[{"name":"IoT","slug":"IoT","permalink":"https://wonius.github.io/categories/IoT/"}],"tags":[{"name":"Android-Things","slug":"Android-Things","permalink":"https://wonius.github.io/tags/Android-Things/"}]},{"title":"CentOS定时服务、开启自启","slug":"Linux服务器常用服务","date":"2018-01-06T12:54:56.000Z","updated":"2020-11-03T13:55:06.000Z","comments":true,"path":"2018/01/06/Linux服务器常用服务/","link":"","permalink":"https://wonius.github.io/2018/01/06/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"加入定时任务1234567891011121314151617181920212223242526#创建shell脚本vim bakup.sh#赋予执行权限chmod -R 777 bakup.sh#加入定时任务vim /etc/crontab#最后一行加入。每天凌晨1点执行0 1 * * * root /usr/bakup.sh#重启crontab服务service crond restart#常用cron表达式 每五分钟执行 */5 * * * * 每小时执行 0 * * * * 每天执行 0 0 * * * 每周执行 0 0 * * 0 每月执行 0 0 1 * * 每年执行 0 0 1 1 * 加入自启动服务主要有两种方法，chkconfig命令和修改rc.local文件 chkconfig命令 12345678910111213//首先查看要启动的服务是否在chkconfig列表中chkconfig --list//如果列表中没有，需要单服务添加到列表chkconfig --add XX//打开自启动chkconfig mysqld on//取消自启动chkconfig mysqld offps:2~5为on，就是表明打开自启动开关了 修改/etc/rc.d/rc.local 12345//编辑rc.localvim /etc/rc.d/rc.local//添加服务/etc/rc.d/init.d/mysqld start","categories":[{"name":"Linux","slug":"Linux","permalink":"https://wonius.github.io/categories/Linux/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://wonius.github.io/tags/Shell/"},{"name":"Linux","slug":"Linux","permalink":"https://wonius.github.io/tags/Linux/"},{"name":"运维","slug":"运维","permalink":"https://wonius.github.io/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"01Pico Pro Maker Kit 刷入Android-Things","slug":"01Pico-Pro-Maker-Kit-刷入Android-Things","date":"2018-01-06T03:39:12.000Z","updated":"2020-11-03T14:13:25.000Z","comments":true,"path":"2018/01/06/01Pico-Pro-Maker-Kit-刷入Android-Things/","link":"","permalink":"https://wonius.github.io/2018/01/06/01Pico-Pro-Maker-Kit-%E5%88%B7%E5%85%A5Android-Things/","excerpt":"","text":"背景​ 2017年底，参加了GDD上海活动，初次接触了Android Things，并且拿到了一块开发板，Pico Pro Maker Kit，拿回来后有事一直闲置。最近有时间掏出来研究下。 组装​ 组装很简单，按照官网教程做，很快就组装好了。 ​ https://developer.android.google.cn/things/hardware/imx7d-kit.html#install-at ​ 不过我拿到的是阉割版，没有Rainbow HAT，差评… 下载Android-Things​ 到官网下载Android things setup utility。可是官网上的链接一直无法下载，后来联系了google里的开发人员，发到我的邮箱才拿到。已经上传到百度网盘，可以直接下载。（之前在网上有搜到某同学上传到csdn，下载还需要积分，没积分的宝宝心里苦/(ㄒoㄒ)/~~） 链接: https://pan.baidu.com/s/1dgmIvk 密码: rsps 配置fastboot​ 在写入镜像之前，需要确保已安装SDK（我装了Android Studio，内置SDK。你也可以单独装）。将fastboot所在目录加入到环境变量中，不然无法成功执行fastboot命令。 查找fastboot文件目录，并确保fastboot有执行权限，并且属主正确： 加入环境变量： 1234567891011# 我安装了ohmyzsh插件，所以需要编辑.zshrc。同学们根据实际配置修改vim ~/.zshrc# 文件末尾中加入export PATH=$PATH:/Users/woniu/Library/Android/sdk/platform-tools# 别忘了编译source ~/.zshrc# 检测是否可用fastboot -h 写入Android-Things​ 下载Android things setup utility成功之后，解压，运行android-things-setup-utility-macos，按照提示选择，在线下载镜像并且刷入（需要科学上网。没有条件的同学也可以到我的百度云下载iot_imx7d_pico镜像，手动安装。链接: https://pan.baidu.com/s/1hticxNI 密码: 4rvc）。 从上图可以看到，最后报错了，原因是找不到fastboot命令。当我配置好fastboot后重新在线安装，一直无法下载。只好下载镜像手动安装。 下载iot_imx7d_pico后，解压，到该目录下执行： 1./flash-all.sh //Win系统下执行flash-all.bat 之后静待安装，完成后会自动重启，就可以了：","categories":[{"name":"IoT","slug":"IoT","permalink":"https://wonius.github.io/categories/IoT/"}],"tags":[{"name":"Android-Things","slug":"Android-Things","permalink":"https://wonius.github.io/tags/Android-Things/"}]},{"title":"setTimeOut()与jQuery中的$.ajax合用，导致内存泄漏","slug":"setTimeOut-与jQuery中的-ajax合用，导致内存泄漏","date":"2017-12-18T14:10:07.000Z","updated":"2018-04-27T07:22:49.000Z","comments":true,"path":"2017/12/18/setTimeOut-与jQuery中的-ajax合用，导致内存泄漏/","link":"","permalink":"https://wonius.github.io/2017/12/18/setTimeOut-%E4%B8%8EjQuery%E4%B8%AD%E7%9A%84-ajax%E5%90%88%E7%94%A8%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/","excerpt":"","text":"最近遇到这个问题，记录一下","categories":[],"tags":[]},{"title":"Hexo相关配置","slug":"Hexo常用命令","date":"2017-12-18T14:09:22.000Z","updated":"2020-11-03T13:51:30.000Z","comments":true,"path":"2017/12/18/Hexo常用命令/","link":"","permalink":"https://wonius.github.io/2017/12/18/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"创建新文档1hexo new filename 启动本地服务12#启动本地服务，然后访问http://localhost:4000/hexo s 重新编译并且发布1hexo g &amp;&amp; hexo d 清理缓存1hexo clean 部署到vps一般使用Hexo搭建blog，都是采用Hexo+Github的结构，但是由于Github屏蔽了百度的爬虫，所以建好的blog百度搜不到，满足不了知识分享（装逼）的需求。解决办法有很多，最简单的就是买一块vps，将blog直接推送到自己的vps上。 1234567891011121314151617181920//安装hexo-deployer-rsyncnpm install hexo-deployer-rsync --save//修改Hexo中的_confg.xml的deploy- type: git repo: github: https://github.com/XXXX/xxxx.github.io.git coding: https://git.coding.net/XXXX/xxxx.git branch: master- type: rsync host: 140.143.251.238 user: root root: /data/www/hexo port: 22 delete: true verbose: true ignore_errors: false //生成并部署hexo g &amp;&amp; hexo d 参数讲解： 参数 描述 默认值 host 远程主机的地址 user 使用者名称 root 远程主机的根目录 port 端口 22 delete 删除远程主机上的旧文件 true verbose 显示调试信息 true ignore_errors 忽略错误 true","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://wonius.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://wonius.github.io/tags/Hexo/"}]},{"title":"CentOS安装zsh和oh-my-zsh","slug":"CentOs安装zsh和oh-my-zsh","date":"2017-12-18T14:05:54.000Z","updated":"2020-11-03T13:46:14.000Z","comments":true,"path":"2017/12/18/CentOs安装zsh和oh-my-zsh/","link":"","permalink":"https://wonius.github.io/2017/12/18/CentOs%E5%AE%89%E8%A3%85zsh%E5%92%8Coh-my-zsh/","excerpt":"","text":"查看系统当前的shell1echo $SHELL 返回结果如下： 1/bin/bash PS.默认的shell一般都是bash 查看bin下是否有zsh包1cat /etc/shells 返回结果如下： 123456/bin/sh/bin/bash/sbin/nologin/bin/dash/bin/tcsh/bin/csh PS：默认没有安装zsh 安装zsh包1yum -y install zsh 安装完成后查看shell列表： 1cat /etc/shells 返回结果如下： 1234567/bin/sh/bin/bash/sbin/nologin/bin/dash/bin/tcsh/bin/csh/bin/zsh 切换shell至zsh1chsh -s /bin/zsh chsh用法请自行查找，返回结果如下： 1Shell changed. 此时查看shell，已经更换为zsh： 1echo $SHELL 返回结果如下： 1/bin/bash 需要重启才能生效： 1sudo reboot 重启后查看shell： 1echo $SHELL 返回结果： 1/bin/zsh 安装git1yum -y install git 安装oh-my-zsh1wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 出现如下界面显示安装成功： 1234567891011 __ __ ____ / /_ ____ ___ __ __ ____ _____/ /_ / __ \\/ __ \\ / __ `__ \\/ / / / /_ / / ___/ __ \\ / /_/ / / / / / / / / / / /_/ / / /_(__ ) / / / \\____/_/ /_/ /_/ /_/ /_/\\__, / /___/____/_/ /_/ /____/ ....is now installed!Please look over the ~/.zshrc file to select plugins, themes, and options.p.s. Follow us at https://twitter.com/ohmyzsh.p.p.s. Get stickers and t-shirts at http://shop.planetargon.com. 添加插件、换themes修改文件 如果执行命令时提示==warning: cannot set LC_CTYPE locale==，修改profile文件： 1vim /etc/profile 在文件末尾处添加： 12export LC_ALL=en_US.UTF-8export LC_CTYPE=en_US.UTF-8 修改后更新： 1source /etc/profile 主题设置1234567//查看系统自带的主题ls ~/.oh-my-zsh/themes//找到ZSH_THEME，将后面的值改为自己喜欢的主题vim ~/.zshrc//设置其他主题，先将主题安装到$ZSH_CUSTOM/themes目录，再设置 推荐几个主题： ys aussiegeek bira agnoster 更多主题： https://github.com/robbyrussell/oh-my-zsh/wiki/themes 插件设置这里列举几个常用的插件，设置方法一样。插件很多，按需索取。否则会影响shell加载速度 git默认自带git插件，可以用下面命令查看有哪些快捷指令 1alias | grep git zsh-autosuggestions（命令补全）123456//安装插件git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions//添加配置vim ~/.zshrc//找到plugins，将zsh-autosuggestions添加到括号里 zsh-syntax-highlighting（命令高亮）123456//安装插件git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting//添加配置vim ~/.zshrc//找到plugins，将zsh-syntax-highlighting添加到括号里 autojump（目录快速跳转）12345//安装autojumpbrew install autojump//配置.zshrc。下面这段，在安装完成后会有提示，直接拷贝[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh 其他系统安装方法可以到官方上去看。另外注意，只有进过的目录，才会直接进入 https://github.com/wting/autojump 更多插件https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins","categories":[{"name":"Shell","slug":"Shell","permalink":"https://wonius.github.io/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://wonius.github.io/tags/Shell/"},{"name":"zsh","slug":"zsh","permalink":"https://wonius.github.io/tags/zsh/"}]},{"title":"CentOS彻底删除并重装、升级Mysql","slug":"CentOs彻底删除并重装Mysql","date":"2017-12-18T14:05:18.000Z","updated":"2020-11-03T13:46:46.000Z","comments":true,"path":"2017/12/18/CentOs彻底删除并重装Mysql/","link":"","permalink":"https://wonius.github.io/2017/12/18/CentOs%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E5%B9%B6%E9%87%8D%E8%A3%85Mysql/","excerpt":"","text":"删除Mysql1234567891011121314151617//备份数据mysqldump -u xxx -h xxx -P 3306 -p --all-databases &gt; databases.sqlmysqldump -u xxx -h xxx -P 3306 -p *** &gt; ***.sql//停止服务service mysqld stop//卸载相关软件yum remove mysql mysql-*//找到遗留文件，并删除find / -name mysqlsudo rm -rf **//找到依赖包，并卸载rpm -qa| grep mysqlyum remove *** 重装Mysql12//重新安装yum install mysql mysql-server mysql-libs 升级高版本Mysql1234567891011121314151617181920212223242526272829//查看系统信息，el版本、i686还是x86——64等uname -r//到镜像中找适合自己的镜像，拿到链接http://mirrors.sohu.com/mysql///下载镜像(适合我系统的镜像)weget http://mirrors.sohu.com/mysql/MySQL-5.7/mysql-5.7.18-1.el6.x86_64.rpm-bundle.tar//下载后解压tar xvf mysql-5.7.18-1.el6.x86_64.rpm-bundle.tar//依次安装服务yum localinstall mysql-***-common-***.rpm mysql-***-libs-***.rpm mysql-***-client-***.rmp mysql-***-server-***.rpm//查看mysql版本mysql -V//启动mysqlservice mysqld start//查看root用户初始密码grep &#x27;temporary password&#x27; /var/log/mysqld.log (或/root/.mysql_secret)//使用密码登录之后，用下面命令修改密码ALTER USER ‘root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;你的密码&#x27;//将Mysql加到服务自启动chkconfig mysqld on","categories":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://wonius.github.io/tags/Mysql/"},{"name":"CentOS","slug":"CentOS","permalink":"https://wonius.github.io/tags/CentOS/"}]},{"title":"Mybatis使用association，结果返回数组","slug":"Mybatis使用association，结果返回数组-1","date":"2017-10-14T13:04:57.000Z","updated":"2020-11-03T13:56:54.000Z","comments":true,"path":"2017/10/14/Mybatis使用association，结果返回数组-1/","link":"","permalink":"https://wonius.github.io/2017/10/14/Mybatis%E4%BD%BF%E7%94%A8association%EF%BC%8C%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84-1/","excerpt":"","text":"关于association、collection标签网上很多帖子，这里就不赘述，直接讲问题。 问题我DAO接口返回的数据格式为 List&lt;Map&lt;String, Object&gt;&gt;，Map中的数据对象为如下，Book是一个实体。 1234567891011&lt;resultMap type=&quot;HashMap&quot; id=&quot;PushInfo&quot;&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;pushDate&quot; property=&quot;pushDate&quot;/&gt; &lt;association property=&quot;book&quot; select=&quot;selectBookById&quot; column=&quot;book_id&quot; javaType=&quot;Book&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectBookById&quot; resultType=&quot;Book&quot;&gt; SELECT book.*,user.nickName AS `createUser.nickName` FROM book LEFT JOIN `user` ON user.id = book.createUser WHERE book.id = #&#123;bookId&#125;&lt;/select&gt; 实际返回的结果，出现了格式不一致的问题: 1234567891011121314151617181920212223242526272829303132333435 &#123; &quot;pushDate&quot;: 1494645459000, &quot;book&quot;: &#123; //该处，book是实体对象，是正常的 &quot;status&quot;: null, &quot;createUser&quot;: null, &quot;tags&quot;: &quot;[唐家三少, 斗罗大陆, 玄幻, 网络小说, 小说, 三少的书，很经典, 奇幻, 魔幻小说]&quot;, &quot;imgUrl&quot;: &quot;https://img3.doubanio.com/lpic/s6847563.jpg&quot;, &quot;enable&quot;: true, &quot;author&quot;: &quot;唐家三少&quot;, &quot;doubanScore&quot;: 7.5, &quot;createDate&quot;: 1420038859000, &quot;name&quot;: &quot;斗罗大陆（全14卷）&quot;, &quot;content&quot;: &quot;&quot;, &quot;book_id&quot;: 3249 &#125; &#125;, &#123; &quot;pushDate&quot;: 1494571741000, &quot;book&quot;: [ //此时，却变成了book实体的数组对象 &#123; &quot;status&quot;: null, &quot;createUser&quot;: null, &quot;tags&quot;: &quot;[唐家三少, 斗罗大陆, 玄幻, 网络小说, 小说, 三少的书，很经典, 奇幻, 魔幻小说]&quot;, &quot;imgUrl&quot;: &quot;https://img3.doubanio.com/lpic/s6847563.jpg&quot;, &quot;enable&quot;: true, &quot;author&quot;: &quot;唐家三少&quot;, &quot;doubanScore&quot;: 7.5, &quot;createDate&quot;: 1420038859000, &quot;name&quot;: &quot;斗罗大陆（全14卷）&quot;, &quot;content&quot;: &quot;&quot;, &quot;book_id&quot;: 3249 &#125; ] &#125;··········· 解决方案新建了BookPush实体类，指定book类型。 12345&lt;resultMap type=&quot;BookPush&quot; id=&quot;PushInfo&quot;&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;pushDate&quot; property=&quot;pushDate&quot;/&gt; &lt;association property=&quot;book&quot; select=&quot;selectBookById&quot; column=&quot;book_id&quot; javaType=&quot;Book&quot;/&gt; &lt;/resultMap&gt; 分析仔细核查数据可以发现，当父查询返回的book_id有重复时，第二个book_id查出来的数据，返回的一定是一个数组。比如上面，book_id都为3249，第一个结果为实体，第二个结果为数组。 我猜测association标签在执行时，会将同一个事务中的数据缓存。先在缓存中查，发现有一个实体，所以就创建了数组，然后再执行sql，查出来的结果与缓存中的一样，所以数组中只有一个元素。 但是感觉跟数据类型也有关系 以后有空看看这部分的源码","categories":[{"name":"Backend","slug":"Backend","permalink":"https://wonius.github.io/categories/Backend/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://wonius.github.io/tags/Mybatis/"}]},{"title":"com.sun.image.codec.jpeg不存在","slug":"错误-程序包com-sun-image-codec-jpeg不存在","date":"2017-09-18T09:51:00.000Z","updated":"2020-11-03T13:43:56.000Z","comments":true,"path":"2017/09/18/错误-程序包com-sun-image-codec-jpeg不存在/","link":"","permalink":"https://wonius.github.io/2017/09/18/%E9%94%99%E8%AF%AF-%E7%A8%8B%E5%BA%8F%E5%8C%85com-sun-image-codec-jpeg%E4%B8%8D%E5%AD%98%E5%9C%A8/","excerpt":"","text":"问题​ 最近项目中有个应用，需要将上传图片压缩为缩略图，用到了JPEGCodec等类。开发过程中一切正常，程序也能运行。当使用maven发布时，程序报错了： 过程​ 度娘了一下，maven的插件maven-compiler-plugin在编译的时候，没有加载/jre/lib内的包。而我们用到的JPEGCodec等类，恰好在/jre/lib/rt.jar包内。为了解决该问题，我们可以使用bootclasspath标签。该标签会将你指定路径下的包，通知到maven进行加载。 12345678910111213141516&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;UTF8&lt;/encoding&gt; &lt;!-- 设置指定包的路径 --&gt; &lt;compilerArguments&gt; &lt;verbose /&gt; &lt;!-- 有两点需要注意 --&gt; &lt;bootclasspath&gt;$&#123;env.JAVA_HOME&#125;/jre/lib/rt.jar:$&#123;env.JAVA_HOME&#125;/jre/lib/jce.jarr&lt;/bootclasspath&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt;&lt;/plugin&gt; Attention: ${JAVA_HOME}设置为全局变量。我用的是Mac+IDEA，刚开始改过之后，IDEA的编辑器显示一直为红色。因为过度相信工具，所以一直以为全局变量设置的有问题，走了弯路。所以只要echo正常，就不要怀疑。 当bootclasspath标签内，有多个变量时，Mac/Linux系统以 ：分隔，Windows系统以 ; 分隔。否则也会有异常。​","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://wonius.github.io/categories/JAVA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wonius.github.io/tags/Java/"}]},{"title":"IE8遇到的坑","slug":"IE8坑","date":"2017-08-23T14:06:26.000Z","updated":"2020-11-03T13:52:35.000Z","comments":true,"path":"2017/08/23/IE8坑/","link":"","permalink":"https://wonius.github.io/2017/08/23/IE8%E5%9D%91/","excerpt":"","text":"new Date()​ 当new Date()时，IE8与IE11产生的结果不同。 12345678910//IE8，date1格式为‘2017年8月23日’。当将该参数传递到rest接口时，无法绑定到date类型//另外，使用oracle的to_date()方法时，to_date(&#x27;&#x27;, &#x27;yyyy&quot;年&quot;MM&quot;月&quot;dd&quot;日&quot;&#x27;)var date1 = new Date();//IE11，date2格式为‘2017/8/23’var date2 =new Date();//为了兼容IE8和IE11，需在前端对日期做处理var date = new Date();var today = date.getFullYear()+&quot;-&quot;+date.getMonth()+&quot;-&quot;+date.getDay(); for(var i in obj)​ IE8支持JS版本较低，Array.prototype中的函数无法使用。比如forEach、indexOf等。一般为了兼容，使在IE8下也可以使用这些函数，会重写Array.prototype，加上这些函数。 12345if(!Array.prototype.forEach) &#123; Array.prototype.forEach = function() &#123; &#125;&#125; ​ 但是，对于对象原型的操作，是很危险的事情，严重会导致导致原型链断裂。不过这次讨论的不是这个问题。 ​ 当IE8解析for in 方法时，会将forEach等添加到prototype上的方法当做变量，一起循环。所以循环体里如果对变量进行了操作，会导致报错。 123for(var i in params) &#123; console.log(params[i].length);&#125; ​ 解决方法： 在使用for..in时，使用 hasOwnProperty() 对变量进行判断： 1234for(var i in params) &#123; if(params.hasOwnProperty(params[i])) console.log(params[i].length);&#125; for循环的另一种写法： 123for(var i = 0; i &lt; params.length; i++) &#123; console.log(params[i].length);&#125; 使用框架封装好的接口，_.forEach，如果不想引入框架，可以自己写一个forEach函数。","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://wonius.github.io/categories/Frontend/"}],"tags":[{"name":"IE8","slug":"IE8","permalink":"https://wonius.github.io/tags/IE8/"}]},{"title":"JSON类库对比","slug":"JSON类库对比","date":"2017-08-19T13:20:31.000Z","updated":"2020-03-25T03:23:34.000Z","comments":true,"path":"2017/08/19/JSON类库对比/","link":"","permalink":"https://wonius.github.io/2017/08/19/JSON%E7%B1%BB%E5%BA%93%E5%AF%B9%E6%AF%94/","excerpt":"","text":"json-lib（性能差）json-lib最开始的也是应用最广泛的json解析工具，json-lib 不好的地方确实是依赖于很多第三方包，包括commons-beanutils.jar，commons-collections-3.2.jar，commons-lang-2.6.jar，commons-logging-1.1.1.jar，ezmorph-1.0.6.jar，对于复杂类型的转换，json-lib对于json转换成bean还有缺陷，比如一个类里面会出现另一个类的list或者map集合，json-lib从json到bean的转换就会出现问题。json-lib在功能和性能上面都不能满足现在互联网化的需求。 Jackson相比json-lib框架，Jackson所依赖的jar包较少，简单易用并且性能也要相对高些。而且Jackson社区相对比较活跃，更新速度也比较快。Jackson对于复杂类型的json转换bean会出现问题，一些集合Map，List的转换出现问题。Jackson对于复杂类型的bean转换Json，转换的json格式不是标准的Json格式 GsonGson是目前功能最全的Json解析神器，Gson当初是为因应Google公司内部需求而由Google自行研发而来，但自从在2008年五月公开发布第一版后已被许多公司或用户应用。Gson的应用主要为toJson与fromJson两个转换函数，无依赖，不需要例外额外的jar，能够直接跑在JDK上。而在使用这种对象转换之前需先创建好对象的类型以及其成员才能成功的将JSON字符串成功转换成相对应的对象。类里面只要有get和set方法，Gson完全可以将复杂类型的json到bean或bean到json的转换，是JSON解析的神器。Gson在功能上面无可挑剔，但是性能上面比FastJson有所差距。 fastjsonFastjson是一个Java语言编写的高性能的JSON处理器,由阿里巴巴公司开发。无依赖，不需要例外额外的jar，能够直接跑在JDK上。FastJson在复杂类型的Bean转换Json上会出现一些问题，可能会出现引用的类型，导致Json转换出错，需要制定引用。FastJson采用独创的算法，将parse的速度提升到极致，超过所有json库。 fastjson这么快老外为啥还是热衷 jackson? 比较选择一个合适的JSON库要从多个方面进行考虑： 字符串解析成JSON性能 字符串解析成JavaBean性能 JavaBean构造JSON性能 集合构造JSON性能 易用性 性能 字符串解析成JavaBean（反序列化）：当数据量较少时首选FastJson，数据量较大使用Jackson。但是Jackson无法堆一个对象集合进行解析，只能转成一个Map集合，这点Gson和FastJson处理的比较好。 字符串解析成JSON：当数据量较少时首选FastJson，数据量较大使用Jackson。 JavaBean构造JSON（序列化）：当数据量较少时选择Gson，数据量较大可使用Jackson。 集合构造JSON（序列化）：首先Jackson，其次Fastjson。 易用性 FastJson的API设计的最简单，最方便使用，直接使用JSON的两个静态方法即可完成四种操作； Gson和Jackson都需要new一个对象，虽然这个对象可以复用，但是在实际使用过程中还需要用一个全局变量来保存改变量，同时API设计的也不是很好理解，对于FastJson来说复杂的API是因为他支持流式解析，适合对JSON进行大量且复杂的操作，但是实际应用中对于JSON的操作都是简单的解析成JavaBean，然后JavaBean序列化成JSON字符串即可，复杂的操作很少； 结论综上4种Json技术的比较，在项目选型的时候，如果性能没有什么要求，可以使用Jackson； 如果性能上有要求，可以Jackson（或Gson）与FastJson两种并行使用，使用Jackson（或Gson）将bean转换成json，使用FastJson将Json转换Bean。 one more thing在使用JS的JSON.parse(data)转换时： 当data为 ‘undefined’ 时，转换异常。为 ‘null’ 时，转换正常； 如果data不是key、value形式的字符串，是 ‘1234’ 这种只有一个值的字符串，也可以转换，转换后还是原值；","categories":[{"name":"Java","slug":"Java","permalink":"https://wonius.github.io/categories/Java/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"https://wonius.github.io/tags/JSON/"}]},{"title":"NodeJs对session的处理、进程间通信","slug":"NodeJs对session的处理、进程间通信","date":"2017-08-19T04:52:53.000Z","updated":"2020-11-03T14:00:51.000Z","comments":true,"path":"2017/08/19/NodeJs对session的处理、进程间通信/","link":"","permalink":"https://wonius.github.io/2017/08/19/NodeJs%E5%AF%B9session%E7%9A%84%E5%A4%84%E7%90%86%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"","text":"对于session的处理​ 最近项目中有用到NodeJs，也在学习。开发过程中发现，NodeJs对于session的处理方式与普通服务器不同。 NodeJs服务器收到请求后，会为本次请求创建session，但是如果这次请求中没有对session的处理（放值等操作），在请求返回时不会做set-cookie操作，该次请求不会生成cookie。所以重复调用该请求每次都会生成一个新的session； 请求处理函数中对session有操作，返回时有set-cookie，生成cookie，下次请求时不会生成新的session； 进程通信​ Node开始时是单线程，为了有效利用资源，后来增加了child_process可以多进程。后来又封装了cluster模块，更好的处理多进程。进程间通信主要依赖于监听。 1234567891011121314151617181920212223242526272829303132333435363738var cluster = require(&#x27;cluster&#x27;);var numCPUs = require(&#x27;os&#x27;).cpus().length;//主进程if (cluster.isMaster) &#123; console.log(&#x27;[master] &#x27; + &quot;start master...&quot;); //根据CPU数量创建子进程 for (var i = 0; i &lt; numCPUs; i++) &#123; cluster.fork(); &#125; //cluster监听 cluster.on(&#x27;listening&#x27;, function (worker, address) &#123; console.log(&#x27;[master] &#x27; + &#x27;listening: worker&#x27; + worker.id + &#x27;,pid:&#x27; + worker.process.pid + &#x27;, Address:&#x27; + address.address + &quot;:&quot; + address.port); &#125;); Object.keys(cluster.workers).forEach(function (id) &#123; //监听所有的worker cluster.workers[id].on(&#x27;message&#x27;, function (msg) &#123; console.log(&#x27;[master] &#x27; + &#x27;received msg:&#x27; + msg + &#x27;from worker&#x27; + id); &#125;); //向子进程发送信息 cluster.workers[id].send(&#x27;[master] &#x27; + &#x27;send msg &#x27; + i + &#x27; to worker&#x27; + worker.id); &#125;); &#125; else if (cluster.isWorker) &#123; //子进程 //向父进程发送数据 process.send(data); //监听数据 process.on(&#x27;message&#x27;, function(data) &#123; &#125;); //子进程都监听3000端口 http.createServer(app).listen(3000) ;&#125; cluster对象cluster的各种属性和函数 cluster.setttings:配置集群参数对象 cluster.isMaster:判断是不是master节点 cluster.isWorker:判断是不是worker节点 Event: ‘fork’: 监听创建worker进程事件 Event: ‘online’: 监听worker创建成功事件 Event: ‘listening’: 监听worker向master状态事件 Event: ‘disconnect’: 监听worker断线事件 Event: ‘exit’: 监听worker退出事件 Event: ‘setup’: 监听setupMaster事件 cluster.setupMaster([settings]): 设置集群参数 cluster.fork([env]): 创建worker进程 cluster.disconnect([callback]): 关闭worket进程 cluster.worker: 获得当前的worker对象 cluster.workers: 获得集群中所有存活的worker对象 worker对象worker的各种属性和函数：可以通过cluster.workers, cluster.worket获得。 worker.id: 进程ID号 worker.process: ChildProcess对象 worker.suicide: 在disconnect()后，判断worker是否自杀 worker.send(message, [sendHandle]): master给worker发送消息。注：worker给发master发送消息要用process.send(message) worker.kill([signal=’SIGTERM’]): 杀死指定的worker，别名destory() worker.disconnect(): 断开worker连接，让worker自杀 Event: ‘message’: 监听master和worker的message事件 Event: ‘online’: 监听指定的worker创建成功事件 Event: ‘listening’: 监听master向worker状态事件 Event: ‘disconnect’: 监听worker断线事件 Event: ‘exit’: 监听worker退出事件","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://wonius.github.io/categories/Frontend/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://wonius.github.io/tags/NodeJs/"}]},{"title":"MacOS常用命令","slug":"Mac常用命令","date":"2017-08-14T16:23:31.000Z","updated":"2020-11-03T13:55:40.000Z","comments":true,"path":"2017/08/15/Mac常用命令/","link":"","permalink":"https://wonius.github.io/2017/08/15/Mac%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"查看端口号12345//8080为端口号lsof -i :8080 //killsudo kill -9 pid 设置软件安装来源为所有来源1sudo spctl --master-disable/--master-enable redis1redis-server //启动 mysql1mysql.server start //启动 postgresql1pg_ctl -d /usr/local/var/postgres -l /usr/local/var/postgres/server.log start //启动 远程传递文件1scp **.zip username@**.**.**.**:/目录","categories":[{"name":"MacOS","slug":"MacOS","permalink":"https://wonius.github.io/categories/MacOS/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://wonius.github.io/tags/Shell/"},{"name":"MacOS","slug":"MacOS","permalink":"https://wonius.github.io/tags/MacOS/"}]},{"title":"Sql优化","slug":"Sql优化","date":"2017-08-13T07:39:31.000Z","updated":"2020-11-03T14:08:29.000Z","comments":true,"path":"2017/08/13/Sql优化/","link":"","permalink":"https://wonius.github.io/2017/08/13/Sql%E4%BC%98%E5%8C%96/","excerpt":"","text":"什么情况下可以全表扫公司这边的要求是，Sql的查询数据小于50M时，可以全表扫。 假如一条数据大小为100B，50M对应的数据量为： $5010241024/100=524288$, 约50w条数据。所以当表中数据量小于50w时，可以全表扫。 Oracle分页众所周知，Oracle分页的写法比较麻烦，需要用嵌套查询的方式。举个🌰： 1234567891011Select * from ( select rownum rowno, t.* from (select id, name, salary from worker order by name desc) t //如果分页时需要排序，一定要在子查询里排序完成后，再分页 where rownum &lt;= 10 //&lt; 一定在子查询中。因为rownum是查询出数据之后再给rownum赋值。否则从第2页开始查询结果都为空) where rowno &gt;0; 另外还有一种写法，使用between： 1234select rownum, w.* from worker wwhere rownum between 1 and 10; 这种格式更加简单，不过效率可能会有不同。具体还是要看执行计划，选择最优。 批量更新时，如果参数不固定，造成硬解析比如我们有个场景，需要根据id批量更新某个值。一般都是会将id放到list中，将list作为参数传入。 123456update workerset status = &quot;Y&quot;where id in&lt;iterator open=&quot;(&quot; close=&quot;)&quot; conjunction=&quot;,&quot;&gt; #list[]#&lt;/iterator&gt; 因为入参是list，长度不固定，生成的sql也会不同，数据库在执行时每次都要生成新的执行计划，导致硬解析。 针对这种情况，我能想到的有如下两种方式处理： 将list长度固定 将大批量分成若干小批次，比如每批次更新100条，list定长为100，当最后的批次长度不够100时，后面的数据设置为空。这样生成的sql就是固定的，执行计划相同。 将整个sql循环 将整个sql循环，而不是参数。例如入参是有100个参数的list，循环创建出100条update语句，参数固定为一个，形式如下： 12345&lt;foreach collection=list item=&quot;item&quot; index=&quot;index&quot; open=&quot;begin&quot; close=&quot;;end;&quot; separator=&quot;;&quot;&gt;update worker set status = &quot;Y&quot;where id = #&#123;item.id&#125;&lt;/foreach&gt;","categories":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"}],"tags":[{"name":"Sql","slug":"Sql","permalink":"https://wonius.github.io/tags/Sql/"}]},{"title":"技术栈","slug":"技术栈","date":"2017-08-13T06:23:31.000Z","updated":"2018-09-10T03:50:23.000Z","comments":true,"path":"2017/08/13/技术栈/","link":"","permalink":"https://wonius.github.io/2017/08/13/%E6%8A%80%E6%9C%AF%E6%A0%88/","excerpt":"","text":"名称 语言 领域 说明 Solr lucene 搜索引擎 支持多种格式 ElasticSearch lucene 实时性好；只支持json；分布式易扩展https://www.cnblogs.com/wenbronk/p/6432990.htmlhttps://www.jianshu.com/p/8bb84384566a Freemarker 模板 模板引擎，java端生成模板 Shiro java 安全框架 Rhino.js 基于Java的javascript实现。可以再java中调js，也可以在js中调用java growingio 无埋点 用户行为埋点 mybatis-plus 简化mybatis语句模板 Echarts、AntV（G2） js 图表 walle 部署 Android-Things IoT TensorFlow DL Google家的 PaddlePaddle DL Baidu家的 Docsify、Docute、Showdoc、MinDoc、apidoc API文档 WebAssembly js中运行Chttps://blog.csdn.net/garfielder007/article/details/68215694 Web3.js js 以太坊Dapp http://web3.tryblockchain.org/ Solidity 区块链 http://me.tryblockchain.org/getting-up-to-speed-on-ethereum.html Redisson redis","categories":[{"name":"技术栈","slug":"技术栈","permalink":"https://wonius.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"https://wonius.github.io/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"IE8下，a标签触发onbeforeunload事件","slug":"IE8下，a标签触发onbeforeunload事件","date":"2017-08-03T14:06:26.000Z","updated":"2020-03-25T03:22:42.000Z","comments":true,"path":"2017/08/03/IE8下，a标签触发onbeforeunload事件/","link":"","permalink":"https://wonius.github.io/2017/08/03/IE8%E4%B8%8B%EF%BC%8Ca%E6%A0%87%E7%AD%BE%E8%A7%A6%E5%8F%91onbeforeunload%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"背景&emsp;&emsp;今天开发过程中，遇到个奇怪现象。我们系统针对onbeforeunload事件做了处理，当该事件触发时弹框提示，由用户确认退出。当点击a标签时，IE8下触发了该事件。IE11与Chrome都没有问题。好吧，又是IE的坑。 分析&emsp;&emsp;网上搜索一番，原来点击a标签会以此触发如下事件 onclick-&gt;window.onbeforeunload-&gt;href 所以解决这个问题，在onclick的回调函数末尾，加 return false; ，阻止事件传递到onbeforeunload。 另外还有网友说，href=“###” 也可以解决该问题 补充根据 MSDN 中描述，IE 的 onbeforeunload 事件可由以下这些条件触发： 关闭当前浏览器窗口。 导航到另一个进入一个新的地址或选择一个喜欢的位置。 单击后退，前进，刷新，或主页按钮。 点击一个链接到新页面。 调用 超链接的 click 方法。 调用 document.write 方法。 调用 document.open 方法。 调用 document.close 方法。 调用 window.close 方法。 调用 window.open 方法，窗口名称设置值为 _self。 调用 window.navigate 或 NavigateAndFind 方法。 调用 location.replace 方法。 调用 location.reload 方法。 指定一个 location.href 属性的新值。 使用 submit 按键提交表单，或调用 form.submit 方法。","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://wonius.github.io/categories/Frontend/"}],"tags":[{"name":"onbeforeunload","slug":"onbeforeunload","permalink":"https://wonius.github.io/tags/onbeforeunload/"}]},{"title":"常用Java程序片段","slug":"Java 常用Java程序片段","date":"2017-08-02T15:27:26.000Z","updated":"2020-11-03T13:53:21.000Z","comments":true,"path":"2017/08/02/Java 常用Java程序片段/","link":"","permalink":"https://wonius.github.io/2017/08/02/Java%20%E5%B8%B8%E7%94%A8Java%E7%A8%8B%E5%BA%8F%E7%89%87%E6%AE%B5/","excerpt":"","text":"字符串 &lt;-&gt; 整型123String a = String.valueOf(2); //integer to numeric stringint i = Integer.parseInt(a); //numeric string to an int 字符串 -&gt; 日期123456//Method 1java.util.Date = java.text.DateFormat.getDateInstance().parse(String date);//Method 2SimpleDateFormat sdf = new SimpleDateFormat(“dd.MM.yyyy”);Date date = sdf.parse(myString); util.Date -&gt; sql.Date12java.util.Date utilDate = new java.util.Date();java.sql.Date sqlDate = new java.sql.Date(utilDate.getTime()); Array -&gt; Map1234String[][] countries = &#123;&#123; &quot;United States&quot;, &quot;New York&quot; &#125;, &#123; &quot;United Kingdom&quot;, &quot;London&quot; &#125;, &#123; &quot;Netherland&quot;, &quot;Amsterdam&quot; &#125;, &#123; &quot;Japan&quot;, &quot;Tokyo&quot; &#125;, &#123; &quot;France&quot;, &quot;Paris&quot; &#125;&#125;; Map countryCapitals = ArrayUtils.toMap(countries); 向文件末尾添加内容1234567891011BufferedWriter out = null;try &#123; out = new BufferedWriter(new FileWriter(“fileName”, true)); out.write(“aString”);&#125; catch (IOException e) &#123; //error processing code&#125; finally &#123; if (out != null) &#123; out.close(); &#125;&#125; 得到当前方法的名字1String methodName = Thread.currentThread().getStackTrace()[1].getMethodName(); 发送邮件12345678910111213141516171819202122232425262728293031323334public void postMail( String recipients[ ], String subject, String message , String from) throws MessagingException &#123; boolean debug = false; //Set the host smtp address Properties props = new Properties(); props.put(&quot;mail.smtp.host&quot;, &quot;smtp.example.com&quot;); // create some properties and get the default Session Session session = Session.getDefaultInstance(props, null); session.setDebug(debug); // create a message Message msg = new MimeMessage(session); // set the from and to address InternetAddress addressFrom = new InternetAddress(from); msg.setFrom(addressFrom); InternetAddress[] addressTo = new InternetAddress[recipients.length]; for (int i = 0; i &lt; recipients.length; i++) &#123; addressTo[i] = new InternetAddress(recipients[i]); &#125; msg.setRecipients(Message.RecipientType.TO, addressTo); // Optional : You can also set your custom headers in the Email if you Want msg.addHeader(&quot;MyHeaderName&quot;, &quot;myHeaderValue&quot;); // Setting the Subject and Content Type msg.setSubject(subject); msg.setContent(message, &quot;text/plain&quot;); Transport.send(msg); &#125; 列出文件与目录123456789101112131415161718192021222324252627282930File dir = new File(&quot;directoryName&quot;); String[] children = dir.list(); if (children == null) &#123; // Either dir does not exist or is not a directory &#125; else &#123; for (int i=0; i &lt; children.length; i++) &#123; // Get filename of file or directory String filename = children[i]; &#125; &#125; // It is also possible to filter the list of returned files. // This example does not return any files that start with `.&#x27;. FilenameFilter filter = new FilenameFilter() &#123; public boolean accept(File dir, String name) &#123; return !name.startsWith(&quot;.&quot;); &#125; &#125;; children = dir.list(filter); // The list of files can also be retrieved as File objects File[] files = dir.listFiles(); // This filter only returns directories FileFilter fileFilter = new FileFilter() &#123; public boolean accept(File file) &#123; return file.isDirectory(); &#125; &#125;; files = dir.listFiles(fileFilter); 创建图片缩略图1234567891011121314151617181920212223242526272829303132333435363738private void createThumbnail(String filename, int thumbWidth, int thumbHeight, int quality, String outFilename) throws InterruptedException, FileNotFoundException, IOException &#123; // load image from filename Image image = Toolkit.getDefaultToolkit().getImage(filename); MediaTracker mediaTracker = new MediaTracker(new Container()); mediaTracker.addImage(image, 0); mediaTracker.waitForID(0); // use this to test for errors at this point: System.out.println(mediaTracker.isErrorAny()); // determine thumbnail size from WIDTH and HEIGHT double thumbRatio = (double)thumbWidth / (double)thumbHeight; int imageWidth = image.getWidth(null); int imageHeight = image.getHeight(null); double imageRatio = (double)imageWidth / (double)imageHeight; if (thumbRatio &lt; imageRatio) &#123; thumbHeight = (int)(thumbWidth / imageRatio); &#125; else &#123; thumbWidth = (int)(thumbHeight * imageRatio); &#125; // draw original image to thumbnail image object and // scale it to the new size on-the-fly BufferedImage thumbImage = new BufferedImage(thumbWidth, thumbHeight, BufferedImage.TYPE_INT_RGB); Graphics2D graphics2D = thumbImage.createGraphics(); graphics2D.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR); graphics2D.drawImage(image, 0, 0, thumbWidth, thumbHeight, null); // save thumbnail image to outFilename BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(outFilename)); JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out); JPEGEncodeParam param = encoder.getDefaultJPEGEncodeParam(thumbImage); quality = Math.max(0, Math.min(quality, 100)); param.setQuality((float)quality / 100.0f, false); encoder.setJPEGEncodeParam(param); encoder.encode(thumbImage); out.close(); &#125; 按照规则取目录下的文件名数组123456789101112File rootFile = new File(&quot;/XX/XX&quot;);String[] dirList = rootFile.list(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; //XXX开通的文件 if (name.startsWith(&quot;XXX&quot;)) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125;);","categories":[{"name":"Java","slug":"Java","permalink":"https://wonius.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wonius.github.io/tags/Java/"}]},{"title":"Websocket+Stomp+RabbitMQ应用","slug":"Websocket-Stomp-RabbitMQ","date":"2017-08-02T12:36:08.000Z","updated":"2018-03-24T09:40:59.000Z","comments":true,"path":"2017/08/02/Websocket-Stomp-RabbitMQ/","link":"","permalink":"https://wonius.github.io/2017/08/02/Websocket-Stomp-RabbitMQ/","excerpt":"","text":"背景&emsp;&emsp;最近开发中遇到实时接收关联系统信息的功能，关联系统通过RabbitMQ消息队列发布消息，之前还在想通过浏览器链接自家服务器，然后自家服务器订阅关联系统队列的架构。后来查了一下，不用这么麻烦，直接通过WebSocket+Stomp方式，即可实现浏览器直接订阅关联系统消息队列。","categories":[{"name":"积累","slug":"积累","permalink":"https://wonius.github.io/categories/%E7%A7%AF%E7%B4%AF/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://wonius.github.io/tags/WebSocket/"}]},{"title":"Mysql常用操作","slug":"Mysql常用操作","date":"2017-07-30T13:03:22.000Z","updated":"2020-11-03T13:57:38.000Z","comments":true,"path":"2017/07/30/Mysql常用操作/","link":"","permalink":"https://wonius.github.io/2017/07/30/Mysql%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"MacOs，修改root用户密码mysql版本：5.7.18 1234567891011121314151617181920//先暂停服务mysql.server stop//启动安全模式mysqld_safe --user=mysql --skip-grant-tables//进入mysqlmysql -u root mysql//设置密码SET PASSWORD FOR &#x27;root&#x27;@&#x27;localhost&#x27; = PASSWORD(&#x27;新密码&#x27;);//将变更刷入内存。该步骤我没有执行，也生效了FLUSH PRIVILEGES; //退出\\q//重新启动服务mysql.server start 数据库备份、还原 备份某库 1234mysqldump -u用户名 -p密码 -h主机 数据库 a -w “sql条件” –lock-all-tables &gt; 路径mysqldump -uroot -p1234 dbname a –where “tag=&#x27;88′” –no-create-info&gt; c:\\a.sqlmysqldump -u root -p game &gt; /tmp/game_backup.sql 备份某几个库 1mysqldump -u root -p game game2 &gt; /tmp/game_backup.sql 备份所有库 1mysqldump -u root -p --all-databases &gt; /tmp/all_backup.sql 还原数据 1mysql -u root -p game &lt; /tmp/game_backup.sql 跨主机同步 12#前提是host2主机上已经创建targetDb数据库, -C指示主机间的数据传输使用数据压缩mysqldump --host=host1 --opt sourceDb| mysql --host=host2 -C targetDb 创建用户1234567CREATE USER username IDENTIFIED BY &#x27;password&#x27;;#限定在固定地址localhost登录CREATE USER username@localhost IDENTIFIED BY &#x27;password&#x27;;#当你在服务器主机上创建用户，为了方便远程连接，通常使用%代替，如：CREATE USER username@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27;; 授权1234GRANT ALL PRIVILEGES ON *.* TO user@localhost IDENTIFIED BY &#x27;password&#x27;;#授予某一些权限时GRANT select,insert ON *.* TO test1@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27;; 查看用户拥有的权限1show grants for user; 查看用户1select host, user from mysql.user; 创建库1CREATE DATABASE dbname; 删除库1DROP DATABASE dbname；","categories":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://wonius.github.io/tags/Mysql/"}]},{"title":"JVM","slug":"Java系列","date":"2017-07-29T15:46:10.000Z","updated":"2020-03-25T03:33:12.000Z","comments":true,"path":"2017/07/29/Java系列/","link":"","permalink":"https://wonius.github.io/2017/07/29/Java%E7%B3%BB%E5%88%97/","excerpt":"","text":"JVMBlog 兰亭风雨|深入Java虚拟机 星空的专栏|深入理解Java虚拟机","categories":[{"name":"Java","slug":"Java","permalink":"https://wonius.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://wonius.github.io/tags/JVM/"}]},{"title":"SpringBoot相关资料","slug":"SpringBoot相关资料","date":"2017-07-29T15:05:53.000Z","updated":"2018-06-01T02:37:16.000Z","comments":true,"path":"2017/07/29/SpringBoot相关资料/","link":"","permalink":"https://wonius.github.io/2017/07/29/SpringBoot%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/","excerpt":"","text":"Spring BootBlog 程序员DD-翟永超 纯洁的微笑 liaokailin的专栏 Spring Boot 揭秘与实战 系列 catoop的专栏 方志朋 Spring Boot 专栏 Spring-boot集成 Website Spring Boot 官网 Spring Boot参考指南-中文版 Gradle 中文参考指南 慕课网视频 spring-boot-tutorials Code spring boot官方例子 spring-boot-starter SpringBoot-Learning favorites-web springboot-learning-example spring-boot-all","categories":[{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/categories/Spring/"},{"name":"SpringBoot","slug":"Spring/SpringBoot","permalink":"https://wonius.github.io/categories/Spring/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wonius.github.io/tags/SpringBoot/"}]},{"title":"SpringCloud相关资料","slug":"SpringCloud相关资料","date":"2017-07-29T15:05:53.000Z","updated":"2018-06-01T02:37:00.000Z","comments":true,"path":"2017/07/29/SpringCloud相关资料/","link":"","permalink":"https://wonius.github.io/2017/07/29/SpringCloud%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/","excerpt":"","text":"Spring CloudBlog 程序员DD-翟永超 纯洁的微笑 liaokailin的专栏 周立|Spring Cloud 方志朋 Spring Cloud 专栏 许进 跟我学Spring Cloud Website Spring Cloud 官网 Spring Cloud中文网 Code spring-cloud-starter SpringCloud-Learning","categories":[{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/categories/Spring/"},{"name":"SpringCloud","slug":"Spring/SpringCloud","permalink":"https://wonius.github.io/categories/Spring/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://wonius.github.io/tags/SpringCloud/"}]},{"title":"Hexo中的Next主题常用设置","slug":"Hexo中的NexT主题常用设置","date":"2017-07-20T16:13:50.000Z","updated":"2020-11-03T13:51:59.000Z","comments":true,"path":"2017/07/21/Hexo中的NexT主题常用设置/","link":"","permalink":"https://wonius.github.io/2017/07/21/Hexo%E4%B8%AD%E7%9A%84NexT%E4%B8%BB%E9%A2%98%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"设置favicon.ico（网站logo）&emsp;&emsp;使用主题为next，按照主题内_config.yml所说，将icon放到hexo-site/source/目录下，没有生效。查了些资料，终于好了，设置如下： 找一副自己中意的图片，尽量简单，因为会缩成很小。利用在线工具制作icon，保存。我的大小是32*32，加载时大多时候很流畅，有时也会转啊转； 将保存的favicon.ico移动至hexo-site/themes/next/source/images目录下； 修改next配置文件_config.yml，如下：1favicon: images/favicon.ico hexo g &amp;&amp; hexo s，就可以在本地看到效果了。调试满意后，hexo d发布； 利用Leancloud实现阅读统计，请求异常401&emsp;&emsp;如何配置leancloud在此不做赘述，next作者文档中写的已经很清晰了，可以先移步到NEXT看看。笔者的情况是，博客在github上，在万网买了个域名，绑定到github。 &emsp;&emsp;配置完成之后，发现阅读统计不能正常使用，开始以为缓存原因，过了两天，还是没好，打算解决这个问题。 &emsp;&emsp;分析过程： 接口报错401：Unauthorized，再次检查了一下AppKey、Web安全域名配置，都正常。比较纳闷，开始研究。 用chrome看了下counter的请求，Request URL竟然是https://api.us.leancloud.cn/****。看起来比较诡异，us不是美国吗。难道访问的url错了？ 重新登录leancloud，发现域名是https://leancloud.cn/，没有us。新开tab页，访问https://us.leancloud.cn/，也可以成功登录。登录后仔细对比，才发现原来leancloud右上角有个选项，可以选择国内节点、美国节点。两个节点中的应用是相互隔离的。我的next中配置的是国内节点中应用的配置，请求到美国节点认证，所以认证不通过。明白之后，我在美国节点中也创建了应用，把next中的相关配置更新，部署，果然可以正常显示。 &emsp;&emsp;个人猜测，由于github服务器在美国，所以当请求leancloud时，请求被分发到了美国节点上的服务器上。 补充：后来更新了NexT代码，又必须配置成国内节点才可以访问。 增加关键字、摘要&emsp;&emsp;建议通过在模板中增加属性的方式，添加关键字、摘要。 修改next/_config.yml配置文件:12345auto_excerpt://开启摘要enable: true//默认文章的前150个字符作为摘要length: 150 修改hexo-site/scaffolds/post.md文件，增加keywords、description。1234567891011---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: keywords: //摘要，填写后显示该字段的值。没有该地段，自动取文章前150个字符作为摘要description: --- 修改文章宽度&emsp;&emsp; 修改/next/source/css/_custom/custom.styl。该文件提供给用户配置自定义的样式，用户尽量避免对源代码的改动，以免牵一发而动全身。针对Mist、Muse风格，可以用如下配置 12345// 修改成你期望的宽度$content-desktop = 1080px// 当视窗超过 1600px 后的宽度$content-desktop-large = 1200px 如果是Pisces风格，则需要 123header&#123; width: 90%; &#125;.container .main-inner &#123; width: 90%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125; 新建文章时同时建立同名目录，保存图片12345678//编辑hexo目录下的_config.yml，修改如下配置post_asset_folder:true//新建文件hexo new &#x27;helloworld&#x27;//将图片移动到helloworld目录中，并且在md中引用&#123;% asset_img 2.JPG 这是描述 %&#125; 修改模板默认新建文档的模板是hexo/scaffolds/post.md，所以如果修改模板，直接在该文件中修改。 比如增加页脚，直接在post.md中增加。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://wonius.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://wonius.github.io/tags/Hexo/"}]},{"title":"使用Mybatis时，对于Oracle中boolean类型的处理","slug":"使用Mybatis时对于Oracle中boolean类型的处理","date":"2017-07-15T14:35:41.000Z","updated":"2020-11-03T13:44:32.000Z","comments":true,"path":"2017/07/15/使用Mybatis时对于Oracle中boolean类型的处理/","link":"","permalink":"https://wonius.github.io/2017/07/15/%E4%BD%BF%E7%94%A8Mybatis%E6%97%B6%E5%AF%B9%E4%BA%8EOracle%E4%B8%ADboolean%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%84%E7%90%86/","excerpt":"","text":"DB为Oracle时，参数中存在boolean类型&emsp;&emsp;Oracle不支持boolean类型，针对此类型，Oracle的驱动包中做了转换处理，将true转换为 数字 1，false转换为 数字 0。 &emsp;&emsp;Mybatis解析sqlmapper文件时，调用TypeHandler类中的方法对类型进行处理，针对boolean类型的实现类为BooleanTypeHandler，如下，此类包含在ojdbc包中。其中setNonNullParameter方法为传参时，对入参的处理。 &emsp;&emsp;setBoolean的具体实现。我们可以看到，boolean类型最后转换为Int类型。 &emsp;&emsp;因此，在做insert、update操作时，用decode进行处理，即可将true/false转换成自己想要的值。我通常用Y/N表示状态。 1decode(#&#123;enabled&#125;, 1, &#x27;Y&#x27;, &#x27;N&#x27;) DB为Oracle时，将查询结果转换为boolean类型&emsp;&emsp;同样，由TypeHandler作为入口，查看Mybatis的处理方式。针对不同情况，有三种处理方法，根据入参大体可以猜到每个方法的作用，此处不做展开。挑选一个方法深入，最终找到getBoolean的实现。 &emsp;&emsp;下图中getBoolean方法属于ResultSet类，在JDK中rt.jar包中（我的环境为JDK1.8）。根据注释我们可以知道，如果值为如下类型的 0，返回结果为false；如果值为如下类型的1，返回true。 &emsp;&emsp;所以当你希望将ResultSet中的某个属性转换为boolean类型时，可以使用如下方式。enabled为字段名称。 1decode(enabled, &#x27;Y&#x27;, 1, &#x27;N&#x27;, 0) enabled","categories":[{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://wonius.github.io/tags/Mybatis/"},{"name":"Oracle","slug":"Oracle","permalink":"https://wonius.github.io/tags/Oracle/"}]},{"title":"Git学习笔记","slug":"Git笔记","date":"2017-07-13T16:06:02.000Z","updated":"2020-11-03T13:50:12.000Z","comments":true,"path":"2017/07/14/Git笔记/","link":"","permalink":"https://wonius.github.io/2017/07/14/Git%E7%AC%94%E8%AE%B0/","excerpt":"","text":"本地代码初始化到远程仓库12345678910//create a new repository on the command linegit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/wonius/XXXXXX.gitgit push -u origin master//push an existing repository from the command linegit remote add origin https://github.com/wonius/MySpringBootDemo.gitgit push -u origin master 更新代码时，本地冲突无法更新错误信息： error: Your local changes to the following files would be overwritten by merge: laravel/app/Services/ExpressService.php Please commit your changes or stash them before you merge. 解决办法： 12345git stashgit pullgit stash pop 如果希望更新时覆盖本地文件，命令如下： 12git reset --hardgit pull 回退到某个历史版本 首先查看要回退到哪个历史版本id： 1git log 回退。比如id为784dd834b250d634a7686f28a7c323d5c6402e90 12//该回退动作会将本地所有改动回退，所以一定要记得stash。git reset --hard 784dd834b250d634a7686f28a7c323d5c6402e90 如果想将回退的版本推送到远程服务器，再用push。只回退本地不用此操作: 1git push -f origin master 使用git stash命令进行代码暂存​ 当我们开发过程中，经常会遇到开发进行了一半，需要切换到另外一个分支的情况。stash命令可以将你现在所有变动进行暂存，后续切换回来时，从暂存中恢复就可以了。stash真的是很好用的工具。 123456789101112131415//暂存git stash//查看所有的暂存，暂存信息中包含分支名、stash版本号(形如stash@&#123;0&#125;)git stash list//恢复git stash apply //恢复到最近一次stash版本git stash pop //恢复到最近一次stash版本，并将栈中stash版本删掉git stash apply stash@&#123;0&#125; //恢复到stash@&#123;0&#125;版本git stash pop stash@&#123;0&#125; //恢复到stash@&#123;0&#125;版本，并将栈中stash@&#123;0&#125;版本删掉//删除git stash drop stash@&#123;0&#125; //将栈中stash@&#123;0&#125;版本删除git stash clear //清楚栈中所有stash版本 为了保持git栈的清洁，推荐大家使用git stash pop相关命令 分支命令12345678910111213141516171819202122232425#查看远程分支git branch -a#查看本地分支git branch / git br#创建本地分支git branch test#本地分支推送到远程git push origin test#创建本地分支test1，并跟踪远程分支cigit checkout -b test1 origin/ci#推送到远程仓库git push origin test1#切换分支git checkout test#删除本地分支git br -d test#删除远程分支git branch -r -d origin/testgit push origin :test fatal: refusing to merge unrelated histories通常是因为本地仓库的历史记录，与远程仓库的历史记录不同，git认为是两个完全无关的项目，无法pull 解决办法： 1git pull origin master ----allow-unrelated-histories 代码提交到不同仓库 手动分别推送（如果需要两个库代码不同） 1234567891011// 添加仓库，并设置别名git remote add github https://*****.gitgit remote add gitlab https://*****.git// 删除别名git remote remove github// 推送git push github master:master// 如果是新建的仓库，需要加-f参数git push -f github master:master 一键push所有库（两个库代码完全一样） 1234567//将新仓库URL绑定到origin上git remote set-url --add origin https://*****.git//pushgit push//查看git中配置的urlgit config -e 修改远程仓库地址 命令修改 1git remote set-url origin http://*****.git 先删除再添加 12git remote rm origingit remote add origin http://*****.git 配置文件修改 123cd ***/.gitvim config# 然后修改 rebase提交通常我们都会拉取分支，提交代码时从自己分支往主分支上merge，当分支比较多时，分支树会显得很乱。 使用rebase，将自己分支每次重置为主分支记录，再提交，全程只有主分支的提交历史，比较清晰 12345git add .git commit -m &quot;*****&quot;git rebase master(主分支)git rebase --continuegit push 修改commit内容123git commit --amend# 修改内容git push -f 常用命令Git常用命令","categories":[{"name":"版本管理","slug":"版本管理","permalink":"https://wonius.github.io/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://wonius.github.io/tags/Git/"}]},{"title":"外地驾照更换上海驾照","slug":"外地驾照更换上海驾照","date":"2017-06-05T13:36:51.000Z","updated":"2018-03-24T09:46:44.000Z","comments":true,"path":"2017/06/05/外地驾照更换上海驾照/","link":"","permalink":"https://wonius.github.io/2017/06/05/%E5%A4%96%E5%9C%B0%E9%A9%BE%E7%85%A7%E6%9B%B4%E6%8D%A2%E4%B8%8A%E6%B5%B7%E9%A9%BE%E7%85%A7/","excerpt":"","text":"&emsp;&emsp;驾照近期内过期，网上查了下，外地户口也可以在上海换驾照，省去回家的舟车劳顿。挺好。 Round 1&emsp;&emsp;因为住在浦东，查到杨高中1500号周六也上班。趁某周六朋友聚会，散场后赶紧坐公交过去，好在不远。站在杨高中路1500前，反复在地图上确认，是否来对地方了。面前是一片废墟。心中一群斯巴达草泥马在咆哮。但是我不能表现出来。 &emsp;&emsp;不能接受现实的大脑拒绝工作了10秒。重新聚焦的眼睛发现了残留的一面墙（我记得当时有拍，却找不到了），墙上是蓝底告示，还贴了警徽那种，特正式。上面写了上海所有车管所地址。杨高中路1500那一栏，被黑色签字笔划掉，一个箭头指向若干字，不羁、狂野、洒脱，依稀辨认出来，“康桥路1600号”。 KO. Round 2&emsp;&emsp;日常任务还是要做。第二次，心想进城，城里的车管所肯定靠谱。来到了南京西路1550号。这次楼不仅在，而且还有人😯。不禁为自己的智商点赞。瞧见别人进去都在门口登记，我也上去刷刷刷一通写。还没写完，里屋的50岁左右的大哥（现在这个年龄段比较尴尬，遇见人不知道该喊大哥，还是大爷。就大哥吧），“干啥干啥，你写啥，你来报案啊？”，“不是，我来换驾照。”，“早搬了，你去天目中路600号”。 &emsp;&emsp;喔。 &emsp;&emsp;好在有摩拜。30分钟后，我到门口了。这次我机灵了，先问了门口20来岁的大兄弟，“你好，这里能换驾照不？”，“去天目中路576号”。 &emsp;&emsp;喔。 &emsp;&emsp;好在这次不远，绕到前面拐个弯就是。确认了这里确实能换驾照后，取号，找了个位置坐下，吁了口气。舒坦，终于找对组织了。换驾照需要带上1寸照片、体检证明。没有体检证明，车管所也有体检服务，就是平常的身高、体重、视力等，可以吃早饭。我没有体检证明，等的时候问了下工作人员，上午11：30结束，下午1：30开始。由于几番折腾，我到时正好11：32。没办法，等呗，到下午体检完后再办。有了上午的经历，我没马上走。待会叫号到我时，问清楚体检、办理的流程，省的再出纰漏。到我了。身份证、驾照递过去。相对无言。噼里啪啦一通操作，说，“你是外地驾照？”，“昂”，“外地驾照更换得去哈密路1330号”。 &emsp;&emsp;噗…… &emsp;&emsp;马不停蹄、牛不停犁的，时间刻度往后拨70分钟，场景转换到哈密路1330号。门口很多疑似黄牛的人，没搭理，直接进去。好在这次确实找对组织了。下面是大家关心的流程： 先到10号楼拍照，25元； 然后到9号楼体检，60元（进门左边窗口领照片，表格，填表，共两张，缴费，照片千万不要弄丢了）； 出门左转，约20米，有牌子标识，上二楼体检； 体检完，工作人员会收一张，把另一张盖章后给你。然后到1号楼办理； 到1号楼后，先到二楼复印身份证，1元（有复印件不用去了）； 复印好后到一楼前台，他们会帮忙贴照片、取号（号是两张连着的，注意不要弄丢）； 等着叫号，办理（共有两个显示屏，1号显示器显示办理，2号显示器显示是取证）； 办理完后再到二楼缴费，10元。缴费后再到一楼，看2号显示器，等取证（缴费后才开始制作）； OK，可以回家了。 &emsp;&emsp;PS: 之前网上查到必须带居住证，实际没有用到。当时着急，还有别的事，陀螺似的办完也没细问。 吐槽&emsp;&emsp;时逢信息时代，身处大上海，办理的事情也是普罗大众都会遇到的事情。实际却一波三折。最开始打过电话咨询，工作人员说可以办，详情到官网上看，然后匆匆挂断。百度‘更换上海驾照’，搜索出来的信息基本没用，很多都是广告。有一个网站叫‘上海驾照服务网’，服务费竟然350元。我实际办理，总共花费不到100元。有网友说是黄牛网站，不知真假。另外搜索出来的很多帖子都写着‘上海驾照换证地点一览’。我就是看了这些信息，深受其害。这些信息不知是多久以前的，却被一转再转。大家如果要查询信息，最好到上海交通安全综合服务管理平台查询。在服务导航菜单里，可以选择业务，地图上显示可以办理的地址。针对外地驾照换上海驾照这种业务，却没有说明。也可能我没找到。 诗、和远方假如生活欺骗了你 假如生活欺骗了你​ 不要悲伤，不要心急 忧郁的日子里需要镇静 相信吧，快乐的日子将会来临 心儿永远向往着未来 现在却常是忧郁 一切都是瞬息 一切都将会过去 而那过去了的 就会成为亲切的怀恋 🙂","categories":[{"name":"生活","slug":"生活","permalink":"https://wonius.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://wonius.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}],"categories":[{"name":"MacOS","slug":"MacOS","permalink":"https://wonius.github.io/categories/MacOS/"},{"name":"Python","slug":"Python","permalink":"https://wonius.github.io/categories/Python/"},{"name":"Backend","slug":"Backend","permalink":"https://wonius.github.io/categories/Backend/"},{"name":"算法","slug":"算法","permalink":"https://wonius.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Go","slug":"Go","permalink":"https://wonius.github.io/categories/Go/"},{"name":"生活","slug":"生活","permalink":"https://wonius.github.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"K8S","slug":"K8S","permalink":"https://wonius.github.io/categories/K8S/"},{"name":"路由器","slug":"路由器","permalink":"https://wonius.github.io/categories/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"Hexo","slug":"Hexo","permalink":"https://wonius.github.io/categories/Hexo/"},{"name":"Frontend","slug":"Frontend","permalink":"https://wonius.github.io/categories/Frontend/"},{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/categories/DB/"},{"name":"中间件","slug":"中间件","permalink":"https://wonius.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Docker","slug":"Docker","permalink":"https://wonius.github.io/categories/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://wonius.github.io/categories/Linux/"},{"name":"工具","slug":"工具","permalink":"https://wonius.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"活动","slug":"活动","permalink":"https://wonius.github.io/categories/%E6%B4%BB%E5%8A%A8/"},{"name":"养犬有道","slug":"养犬有道","permalink":"https://wonius.github.io/categories/%E5%85%BB%E7%8A%AC%E6%9C%89%E9%81%93/"},{"name":"积累","slug":"积累","permalink":"https://wonius.github.io/categories/%E7%A7%AF%E7%B4%AF/"},{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/categories/Spring/"},{"name":"Java","slug":"Java","permalink":"https://wonius.github.io/categories/Java/"},{"name":"家有小柴","slug":"家有小柴","permalink":"https://wonius.github.io/categories/%E5%AE%B6%E6%9C%89%E5%B0%8F%E6%9F%B4/"},{"name":"iOS","slug":"iOS","permalink":"https://wonius.github.io/categories/iOS/"},{"name":"SpringBoot","slug":"Spring/SpringBoot","permalink":"https://wonius.github.io/categories/Spring/SpringBoot/"},{"name":"SpringCloud","slug":"Spring/SpringCloud","permalink":"https://wonius.github.io/categories/Spring/SpringCloud/"},{"name":"技能图谱","slug":"技能图谱","permalink":"https://wonius.github.io/categories/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/"},{"name":"BlockChain","slug":"BlockChain","permalink":"https://wonius.github.io/categories/BlockChain/"},{"name":"ML","slug":"ML","permalink":"https://wonius.github.io/categories/ML/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://wonius.github.io/categories/TensorFlow/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://wonius.github.io/categories/shadowsocks/"},{"name":"Chrome","slug":"Chrome","permalink":"https://wonius.github.io/categories/Chrome/"},{"name":"运维","slug":"运维","permalink":"https://wonius.github.io/categories/%E8%BF%90%E7%BB%B4/"},{"name":"云服务器","slug":"云服务器","permalink":"https://wonius.github.io/categories/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"安全","slug":"安全","permalink":"https://wonius.github.io/categories/%E5%AE%89%E5%85%A8/"},{"name":"IoT","slug":"IoT","permalink":"https://wonius.github.io/categories/IoT/"},{"name":"Shell","slug":"Shell","permalink":"https://wonius.github.io/categories/Shell/"},{"name":"JAVA","slug":"JAVA","permalink":"https://wonius.github.io/categories/JAVA/"},{"name":"技术栈","slug":"技术栈","permalink":"https://wonius.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"版本管理","slug":"版本管理","permalink":"https://wonius.github.io/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"https://wonius.github.io/tags/MacOS/"},{"name":"Python","slug":"Python","permalink":"https://wonius.github.io/tags/Python/"},{"name":"EasyNLP","slug":"EasyNLP","permalink":"https://wonius.github.io/tags/EasyNLP/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://wonius.github.io/tags/Mybatis/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://wonius.github.io/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://wonius.github.io/tags/Go/"},{"name":"VS Code","slug":"VS-Code","permalink":"https://wonius.github.io/tags/VS-Code/"},{"name":"床垫","slug":"床垫","permalink":"https://wonius.github.io/tags/%E5%BA%8A%E5%9E%AB/"},{"name":"K8S","slug":"K8S","permalink":"https://wonius.github.io/tags/K8S/"},{"name":"路由器","slug":"路由器","permalink":"https://wonius.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"configMap","slug":"configMap","permalink":"https://wonius.github.io/tags/configMap/"},{"name":"Hexo","slug":"Hexo","permalink":"https://wonius.github.io/tags/Hexo/"},{"name":"NodeJs","slug":"NodeJs","permalink":"https://wonius.github.io/tags/NodeJs/"},{"name":"Redis","slug":"Redis","permalink":"https://wonius.github.io/tags/Redis/"},{"name":"Solr","slug":"Solr","permalink":"https://wonius.github.io/tags/Solr/"},{"name":"Oracle","slug":"Oracle","permalink":"https://wonius.github.io/tags/Oracle/"},{"name":"高可用架构","slug":"高可用架构","permalink":"https://wonius.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/"},{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://wonius.github.io/tags/ZooKeeper/"},{"name":"DB","slug":"DB","permalink":"https://wonius.github.io/tags/DB/"},{"name":"JPA","slug":"JPA","permalink":"https://wonius.github.io/tags/JPA/"},{"name":"Docker","slug":"Docker","permalink":"https://wonius.github.io/tags/Docker/"},{"name":"nginx","slug":"nginx","permalink":"https://wonius.github.io/tags/nginx/"},{"name":"Maven","slug":"Maven","permalink":"https://wonius.github.io/tags/Maven/"},{"name":"MD5","slug":"MD5","permalink":"https://wonius.github.io/tags/MD5/"},{"name":"iTerm","slug":"iTerm","permalink":"https://wonius.github.io/tags/iTerm/"},{"name":"GDD","slug":"GDD","permalink":"https://wonius.github.io/tags/GDD/"},{"name":"狗狗","slug":"狗狗","permalink":"https://wonius.github.io/tags/%E7%8B%97%E7%8B%97/"},{"name":"JSON","slug":"JSON","permalink":"https://wonius.github.io/tags/JSON/"},{"name":"Spring","slug":"Spring","permalink":"https://wonius.github.io/tags/Spring/"},{"name":"lombok","slug":"lombok","permalink":"https://wonius.github.io/tags/lombok/"},{"name":"柴犬","slug":"柴犬","permalink":"https://wonius.github.io/tags/%E6%9F%B4%E7%8A%AC/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://wonius.github.io/tags/Kubernetes/"},{"name":"分词","slug":"分词","permalink":"https://wonius.github.io/tags/%E5%88%86%E8%AF%8D/"},{"name":"iOS","slug":"iOS","permalink":"https://wonius.github.io/tags/iOS/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wonius.github.io/tags/SpringBoot/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://wonius.github.io/tags/SpringCloud/"},{"name":"vim","slug":"vim","permalink":"https://wonius.github.io/tags/vim/"},{"name":"技能图谱","slug":"技能图谱","permalink":"https://wonius.github.io/tags/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/"},{"name":"大数据","slug":"大数据","permalink":"https://wonius.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"BlockChain","slug":"BlockChain","permalink":"https://wonius.github.io/tags/BlockChain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://wonius.github.io/tags/Ethereum/"},{"name":"matlab","slug":"matlab","permalink":"https://wonius.github.io/tags/matlab/"},{"name":"ML","slug":"ML","permalink":"https://wonius.github.io/tags/ML/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://wonius.github.io/tags/TensorFlow/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://wonius.github.io/tags/shadowsocks/"},{"name":"Chrome","slug":"Chrome","permalink":"https://wonius.github.io/tags/Chrome/"},{"name":"Swagger2","slug":"Swagger2","permalink":"https://wonius.github.io/tags/Swagger2/"},{"name":"TestNG","slug":"TestNG","permalink":"https://wonius.github.io/tags/TestNG/"},{"name":"MockServer","slug":"MockServer","permalink":"https://wonius.github.io/tags/MockServer/"},{"name":"Shell","slug":"Shell","permalink":"https://wonius.github.io/tags/Shell/"},{"name":"Aria2","slug":"Aria2","permalink":"https://wonius.github.io/tags/Aria2/"},{"name":"Linux","slug":"Linux","permalink":"https://wonius.github.io/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"https://wonius.github.io/tags/SSH/"},{"name":"Apollo","slug":"Apollo","permalink":"https://wonius.github.io/tags/Apollo/"},{"name":"前端","slug":"前端","permalink":"https://wonius.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"AWS","slug":"AWS","permalink":"https://wonius.github.io/tags/AWS/"},{"name":"Java","slug":"Java","permalink":"https://wonius.github.io/tags/Java/"},{"name":"SSL","slug":"SSL","permalink":"https://wonius.github.io/tags/SSL/"},{"name":"Mysql","slug":"Mysql","permalink":"https://wonius.github.io/tags/Mysql/"},{"name":"运维","slug":"运维","permalink":"https://wonius.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"工具","slug":"工具","permalink":"https://wonius.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Android-Things","slug":"Android-Things","permalink":"https://wonius.github.io/tags/Android-Things/"},{"name":"zsh","slug":"zsh","permalink":"https://wonius.github.io/tags/zsh/"},{"name":"CentOS","slug":"CentOS","permalink":"https://wonius.github.io/tags/CentOS/"},{"name":"IE8","slug":"IE8","permalink":"https://wonius.github.io/tags/IE8/"},{"name":"Sql","slug":"Sql","permalink":"https://wonius.github.io/tags/Sql/"},{"name":"技术栈","slug":"技术栈","permalink":"https://wonius.github.io/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"onbeforeunload","slug":"onbeforeunload","permalink":"https://wonius.github.io/tags/onbeforeunload/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://wonius.github.io/tags/WebSocket/"},{"name":"JVM","slug":"JVM","permalink":"https://wonius.github.io/tags/JVM/"},{"name":"Git","slug":"Git","permalink":"https://wonius.github.io/tags/Git/"},{"name":"生活","slug":"生活","permalink":"https://wonius.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}